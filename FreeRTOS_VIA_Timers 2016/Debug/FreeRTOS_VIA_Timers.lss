
FreeRTOS_VIA_Timers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800200  000031d6  0000326a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000031d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a5e  00800244  00800244  000032ae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000032ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000032e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000450  00000000  00000000  00003320  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003199  00000000  00000000  00003770  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009e7  00000000  00000000  00006909  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000030f1  00000000  00000000  000072f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001078  00000000  00000000  0000a3e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016b0  00000000  00000000  0000b45c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000022e5  00000000  00000000  0000cb0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003e8  00000000  00000000  0000edf1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8d c0       	rjmp	.+282    	; 0x11c <__ctors_end>
       2:	00 00       	nop
       4:	ac c0       	rjmp	.+344    	; 0x15e <__bad_interrupt>
       6:	00 00       	nop
       8:	aa c0       	rjmp	.+340    	; 0x15e <__bad_interrupt>
       a:	00 00       	nop
       c:	a8 c0       	rjmp	.+336    	; 0x15e <__bad_interrupt>
       e:	00 00       	nop
      10:	a6 c0       	rjmp	.+332    	; 0x15e <__bad_interrupt>
      12:	00 00       	nop
      14:	a4 c0       	rjmp	.+328    	; 0x15e <__bad_interrupt>
      16:	00 00       	nop
      18:	a2 c0       	rjmp	.+324    	; 0x15e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a0 c0       	rjmp	.+320    	; 0x15e <__bad_interrupt>
      1e:	00 00       	nop
      20:	9e c0       	rjmp	.+316    	; 0x15e <__bad_interrupt>
      22:	00 00       	nop
      24:	9c c0       	rjmp	.+312    	; 0x15e <__bad_interrupt>
      26:	00 00       	nop
      28:	9a c0       	rjmp	.+308    	; 0x15e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	98 c0       	rjmp	.+304    	; 0x15e <__bad_interrupt>
      2e:	00 00       	nop
      30:	96 c0       	rjmp	.+300    	; 0x15e <__bad_interrupt>
      32:	00 00       	nop
      34:	94 c0       	rjmp	.+296    	; 0x15e <__bad_interrupt>
      36:	00 00       	nop
      38:	92 c0       	rjmp	.+292    	; 0x15e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	90 c0       	rjmp	.+288    	; 0x15e <__bad_interrupt>
      3e:	00 00       	nop
      40:	8e c0       	rjmp	.+284    	; 0x15e <__bad_interrupt>
      42:	00 00       	nop
      44:	8c c0       	rjmp	.+280    	; 0x15e <__bad_interrupt>
      46:	00 00       	nop
      48:	8a c0       	rjmp	.+276    	; 0x15e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	88 c0       	rjmp	.+272    	; 0x15e <__bad_interrupt>
      4e:	00 00       	nop
      50:	86 c0       	rjmp	.+268    	; 0x15e <__bad_interrupt>
      52:	00 00       	nop
      54:	84 c0       	rjmp	.+264    	; 0x15e <__bad_interrupt>
      56:	00 00       	nop
      58:	82 c0       	rjmp	.+260    	; 0x15e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	80 c0       	rjmp	.+256    	; 0x15e <__bad_interrupt>
      5e:	00 00       	nop
      60:	7e c0       	rjmp	.+252    	; 0x15e <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 14 18 	jmp	0x3028	; 0x3028 <__vector_25>
      68:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__vector_26>
      6c:	78 c0       	rjmp	.+240    	; 0x15e <__bad_interrupt>
      6e:	00 00       	nop
      70:	76 c0       	rjmp	.+236    	; 0x15e <__bad_interrupt>
      72:	00 00       	nop
      74:	74 c0       	rjmp	.+232    	; 0x15e <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c0       	rjmp	.+228    	; 0x15e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	70 c0       	rjmp	.+224    	; 0x15e <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 69 09 	jmp	0x12d2	; 0x12d2 <__vector_32>
      84:	6c c0       	rjmp	.+216    	; 0x15e <__bad_interrupt>
      86:	00 00       	nop
      88:	6a c0       	rjmp	.+212    	; 0x15e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	68 c0       	rjmp	.+208    	; 0x15e <__bad_interrupt>
      8e:	00 00       	nop
      90:	66 c0       	rjmp	.+204    	; 0x15e <__bad_interrupt>
      92:	00 00       	nop
      94:	64 c0       	rjmp	.+200    	; 0x15e <__bad_interrupt>
      96:	00 00       	nop
      98:	62 c0       	rjmp	.+196    	; 0x15e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	60 c0       	rjmp	.+192    	; 0x15e <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5e c0       	rjmp	.+188    	; 0x15e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5c c0       	rjmp	.+184    	; 0x15e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	5a c0       	rjmp	.+180    	; 0x15e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	58 c0       	rjmp	.+176    	; 0x15e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	56 c0       	rjmp	.+172    	; 0x15e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	54 c0       	rjmp	.+168    	; 0x15e <__bad_interrupt>
      b6:	00 00       	nop
      b8:	52 c0       	rjmp	.+164    	; 0x15e <__bad_interrupt>
      ba:	00 00       	nop
      bc:	50 c0       	rjmp	.+160    	; 0x15e <__bad_interrupt>
      be:	00 00       	nop
      c0:	4e c0       	rjmp	.+156    	; 0x15e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4c c0       	rjmp	.+152    	; 0x15e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	4a c0       	rjmp	.+148    	; 0x15e <__bad_interrupt>
      ca:	00 00       	nop
      cc:	48 c0       	rjmp	.+144    	; 0x15e <__bad_interrupt>
      ce:	00 00       	nop
      d0:	46 c0       	rjmp	.+140    	; 0x15e <__bad_interrupt>
      d2:	00 00       	nop
      d4:	44 c0       	rjmp	.+136    	; 0x15e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	42 c0       	rjmp	.+132    	; 0x15e <__bad_interrupt>
      da:	00 00       	nop
      dc:	40 c0       	rjmp	.+128    	; 0x15e <__bad_interrupt>
      de:	00 00       	nop
      e0:	3e c0       	rjmp	.+124    	; 0x15e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	5e 03       	fmul	r21, r22
      e6:	5e 03       	fmul	r21, r22
      e8:	5e 03       	fmul	r21, r22
      ea:	b8 03       	fmulsu	r19, r16
      ec:	98 03       	fmulsu	r17, r16
      ee:	b3 03       	fmuls	r19, r19
      f0:	5e 03       	fmul	r21, r22
      f2:	5e 03       	fmul	r21, r22
      f4:	b8 03       	fmulsu	r19, r16
      f6:	98 03       	fmulsu	r17, r16

000000f8 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	1f 92       	push	r1
      fe:	1f 92       	push	r1
     100:	cd b7       	in	r28, 0x3d	; 61
     102:	de b7       	in	r29, 0x3e	; 62
     104:	9a 83       	std	Y+2, r25	; 0x02
     106:	89 83       	std	Y+1, r24	; 0x01
     108:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvCheckTasksWaitingTermination>
     10c:	80 91 2c 0c 	lds	r24, 0x0C2C	; 0x800c2c <pxReadyTasksLists>
     110:	82 30       	cpi	r24, 0x02	; 2
     112:	08 f0       	brcs	.+2      	; 0x116 <prvIdleTask+0x1e>
     114:	69 d7       	rcall	.+3794   	; 0xfe8 <vPortYield>
     116:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <vApplicationIdleHook>
     11a:	f6 cf       	rjmp	.-20     	; 0x108 <prvIdleTask+0x10>

0000011c <__ctors_end>:
     11c:	11 24       	eor	r1, r1
     11e:	1f be       	out	0x3f, r1	; 63
     120:	cf ef       	ldi	r28, 0xFF	; 255
     122:	d1 e2       	ldi	r29, 0x21	; 33
     124:	de bf       	out	0x3e, r29	; 62
     126:	cd bf       	out	0x3d, r28	; 61
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	0c bf       	out	0x3c, r16	; 60

0000012c <__do_copy_data>:
     12c:	12 e0       	ldi	r17, 0x02	; 2
     12e:	a0 e0       	ldi	r26, 0x00	; 0
     130:	b2 e0       	ldi	r27, 0x02	; 2
     132:	e6 ed       	ldi	r30, 0xD6	; 214
     134:	f1 e3       	ldi	r31, 0x31	; 49
     136:	00 e0       	ldi	r16, 0x00	; 0
     138:	0b bf       	out	0x3b, r16	; 59
     13a:	02 c0       	rjmp	.+4      	; 0x140 <__do_copy_data+0x14>
     13c:	07 90       	elpm	r0, Z+
     13e:	0d 92       	st	X+, r0
     140:	a4 34       	cpi	r26, 0x44	; 68
     142:	b1 07       	cpc	r27, r17
     144:	d9 f7       	brne	.-10     	; 0x13c <__do_copy_data+0x10>

00000146 <__do_clear_bss>:
     146:	2c e0       	ldi	r18, 0x0C	; 12
     148:	a4 e4       	ldi	r26, 0x44	; 68
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	01 c0       	rjmp	.+2      	; 0x150 <.do_clear_bss_start>

0000014e <.do_clear_bss_loop>:
     14e:	1d 92       	st	X+, r1

00000150 <.do_clear_bss_start>:
     150:	a2 3a       	cpi	r26, 0xA2	; 162
     152:	b2 07       	cpc	r27, r18
     154:	e1 f7       	brne	.-8      	; 0x14e <.do_clear_bss_loop>
     156:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <main>
     15a:	0c 94 e9 18 	jmp	0x31d2	; 0x31d2 <_exit>

0000015e <__bad_interrupt>:
     15e:	0c 94 cd 17 	jmp	0x2f9a	; 0x2f9a <__vector_default>

00000162 <xTimerCreateTimerTask>:
const char * pcTimerGetTimerName( TimerHandle_t xTimer )
{
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	return pxTimer->pcTimerName;
}
     162:	af 92       	push	r10
     164:	bf 92       	push	r11
     166:	cf 92       	push	r12
     168:	df 92       	push	r13
     16a:	ef 92       	push	r14
     16c:	ff 92       	push	r15
     16e:	0f 93       	push	r16
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	1f 92       	push	r1
     176:	cd b7       	in	r28, 0x3d	; 61
     178:	de b7       	in	r29, 0x3e	; 62
     17a:	19 82       	std	Y+1, r1	; 0x01
     17c:	aa d3       	rcall	.+1876   	; 0x8d2 <prvCheckForValidListAndQueue>
     17e:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     182:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     186:	89 2b       	or	r24, r25
     188:	91 f0       	breq	.+36     	; 0x1ae <xTimerCreateTimerTask+0x4c>
     18a:	a1 2c       	mov	r10, r1
     18c:	b1 2c       	mov	r11, r1
     18e:	c1 2c       	mov	r12, r1
     190:	d1 2c       	mov	r13, r1
     192:	e1 2c       	mov	r14, r1
     194:	f1 2c       	mov	r15, r1
     196:	05 e0       	ldi	r16, 0x05	; 5
     198:	20 e0       	ldi	r18, 0x00	; 0
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	49 eb       	ldi	r20, 0xB9	; 185
     19e:	50 e0       	ldi	r21, 0x00	; 0
     1a0:	62 e0       	ldi	r22, 0x02	; 2
     1a2:	72 e0       	ldi	r23, 0x02	; 2
     1a4:	86 ef       	ldi	r24, 0xF6	; 246
     1a6:	91 e0       	ldi	r25, 0x01	; 1
     1a8:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskGenericCreate>
     1ac:	89 83       	std	Y+1, r24	; 0x01
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	0f 91       	pop	r16
     1b8:	ff 90       	pop	r15
     1ba:	ef 90       	pop	r14
     1bc:	df 90       	pop	r13
     1be:	cf 90       	pop	r12
     1c0:	bf 90       	pop	r11
     1c2:	af 90       	pop	r10
     1c4:	08 95       	ret

000001c6 <xTimerCreate>:
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
     1ce:	cd b7       	in	r28, 0x3d	; 61
     1d0:	de b7       	in	r29, 0x3e	; 62
     1d2:	2b 97       	sbiw	r28, 0x0b	; 11
     1d4:	0f b6       	in	r0, 0x3f	; 63
     1d6:	f8 94       	cli
     1d8:	de bf       	out	0x3e, r29	; 62
     1da:	0f be       	out	0x3f, r0	; 63
     1dc:	cd bf       	out	0x3d, r28	; 61
     1de:	9c 83       	std	Y+4, r25	; 0x04
     1e0:	8b 83       	std	Y+3, r24	; 0x03
     1e2:	7e 83       	std	Y+6, r23	; 0x06
     1e4:	6d 83       	std	Y+5, r22	; 0x05
     1e6:	4f 83       	std	Y+7, r20	; 0x07
     1e8:	39 87       	std	Y+9, r19	; 0x09
     1ea:	28 87       	std	Y+8, r18	; 0x08
     1ec:	1b 87       	std	Y+11, r17	; 0x0b
     1ee:	0a 87       	std	Y+10, r16	; 0x0a
     1f0:	8d 81       	ldd	r24, Y+5	; 0x05
     1f2:	9e 81       	ldd	r25, Y+6	; 0x06
     1f4:	89 2b       	or	r24, r25
     1f6:	19 f4       	brne	.+6      	; 0x1fe <xTimerCreate+0x38>
     1f8:	1a 82       	std	Y+2, r1	; 0x02
     1fa:	19 82       	std	Y+1, r1	; 0x01
     1fc:	30 c0       	rjmp	.+96     	; 0x25e <xTimerCreate+0x98>
     1fe:	83 e1       	ldi	r24, 0x13	; 19
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <pvPortMalloc>
     206:	9a 83       	std	Y+2, r25	; 0x02
     208:	89 83       	std	Y+1, r24	; 0x01
     20a:	89 81       	ldd	r24, Y+1	; 0x01
     20c:	9a 81       	ldd	r25, Y+2	; 0x02
     20e:	89 2b       	or	r24, r25
     210:	31 f1       	breq	.+76     	; 0x25e <xTimerCreate+0x98>
     212:	5f d3       	rcall	.+1726   	; 0x8d2 <prvCheckForValidListAndQueue>
     214:	89 81       	ldd	r24, Y+1	; 0x01
     216:	9a 81       	ldd	r25, Y+2	; 0x02
     218:	2b 81       	ldd	r18, Y+3	; 0x03
     21a:	3c 81       	ldd	r19, Y+4	; 0x04
     21c:	fc 01       	movw	r30, r24
     21e:	31 83       	std	Z+1, r19	; 0x01
     220:	20 83       	st	Z, r18
     222:	89 81       	ldd	r24, Y+1	; 0x01
     224:	9a 81       	ldd	r25, Y+2	; 0x02
     226:	2d 81       	ldd	r18, Y+5	; 0x05
     228:	3e 81       	ldd	r19, Y+6	; 0x06
     22a:	fc 01       	movw	r30, r24
     22c:	35 87       	std	Z+13, r19	; 0x0d
     22e:	24 87       	std	Z+12, r18	; 0x0c
     230:	89 81       	ldd	r24, Y+1	; 0x01
     232:	9a 81       	ldd	r25, Y+2	; 0x02
     234:	2f 81       	ldd	r18, Y+7	; 0x07
     236:	fc 01       	movw	r30, r24
     238:	26 87       	std	Z+14, r18	; 0x0e
     23a:	89 81       	ldd	r24, Y+1	; 0x01
     23c:	9a 81       	ldd	r25, Y+2	; 0x02
     23e:	28 85       	ldd	r18, Y+8	; 0x08
     240:	39 85       	ldd	r19, Y+9	; 0x09
     242:	fc 01       	movw	r30, r24
     244:	30 8b       	std	Z+16, r19	; 0x10
     246:	27 87       	std	Z+15, r18	; 0x0f
     248:	89 81       	ldd	r24, Y+1	; 0x01
     24a:	9a 81       	ldd	r25, Y+2	; 0x02
     24c:	2a 85       	ldd	r18, Y+10	; 0x0a
     24e:	3b 85       	ldd	r19, Y+11	; 0x0b
     250:	fc 01       	movw	r30, r24
     252:	32 8b       	std	Z+18, r19	; 0x12
     254:	21 8b       	std	Z+17, r18	; 0x11
     256:	89 81       	ldd	r24, Y+1	; 0x01
     258:	9a 81       	ldd	r25, Y+2	; 0x02
     25a:	02 96       	adiw	r24, 0x02	; 2
     25c:	9c d3       	rcall	.+1848   	; 0x996 <vListInitialiseItem>
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	2b 96       	adiw	r28, 0x0b	; 11
     264:	0f b6       	in	r0, 0x3f	; 63
     266:	f8 94       	cli
     268:	de bf       	out	0x3e, r29	; 62
     26a:	0f be       	out	0x3f, r0	; 63
     26c:	cd bf       	out	0x3d, r28	; 61
     26e:	df 91       	pop	r29
     270:	cf 91       	pop	r28
     272:	1f 91       	pop	r17
     274:	0f 91       	pop	r16
     276:	08 95       	ret

00000278 <xTimerGenericCommand>:
     278:	0f 93       	push	r16
     27a:	1f 93       	push	r17
     27c:	cf 93       	push	r28
     27e:	df 93       	push	r29
     280:	cd b7       	in	r28, 0x3d	; 61
     282:	de b7       	in	r29, 0x3e	; 62
     284:	2f 97       	sbiw	r28, 0x0f	; 15
     286:	0f b6       	in	r0, 0x3f	; 63
     288:	f8 94       	cli
     28a:	de bf       	out	0x3e, r29	; 62
     28c:	0f be       	out	0x3f, r0	; 63
     28e:	cd bf       	out	0x3d, r28	; 61
     290:	98 87       	std	Y+8, r25	; 0x08
     292:	8f 83       	std	Y+7, r24	; 0x07
     294:	69 87       	std	Y+9, r22	; 0x09
     296:	5b 87       	std	Y+11, r21	; 0x0b
     298:	4a 87       	std	Y+10, r20	; 0x0a
     29a:	3d 87       	std	Y+13, r19	; 0x0d
     29c:	2c 87       	std	Y+12, r18	; 0x0c
     29e:	1f 87       	std	Y+15, r17	; 0x0f
     2a0:	0e 87       	std	Y+14, r16	; 0x0e
     2a2:	19 82       	std	Y+1, r1	; 0x01
     2a4:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     2a8:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     2ac:	89 2b       	or	r24, r25
     2ae:	d1 f1       	breq	.+116    	; 0x324 <xTimerGenericCommand+0xac>
     2b0:	89 85       	ldd	r24, Y+9	; 0x09
     2b2:	8a 83       	std	Y+2, r24	; 0x02
     2b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     2b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     2b8:	9c 83       	std	Y+4, r25	; 0x04
     2ba:	8b 83       	std	Y+3, r24	; 0x03
     2bc:	8f 81       	ldd	r24, Y+7	; 0x07
     2be:	98 85       	ldd	r25, Y+8	; 0x08
     2c0:	9e 83       	std	Y+6, r25	; 0x06
     2c2:	8d 83       	std	Y+5, r24	; 0x05
     2c4:	89 85       	ldd	r24, Y+9	; 0x09
     2c6:	86 30       	cpi	r24, 0x06	; 6
     2c8:	04 f5       	brge	.+64     	; 0x30a <xTimerGenericCommand+0x92>
     2ca:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <xTaskGetSchedulerState>
     2ce:	82 30       	cpi	r24, 0x02	; 2
     2d0:	71 f4       	brne	.+28     	; 0x2ee <xTimerGenericCommand+0x76>
     2d2:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     2d6:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     2da:	4e 85       	ldd	r20, Y+14	; 0x0e
     2dc:	5f 85       	ldd	r21, Y+15	; 0x0f
     2de:	be 01       	movw	r22, r28
     2e0:	6e 5f       	subi	r22, 0xFE	; 254
     2e2:	7f 4f       	sbci	r23, 0xFF	; 255
     2e4:	20 e0       	ldi	r18, 0x00	; 0
     2e6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xQueueGenericSend>
     2ea:	89 83       	std	Y+1, r24	; 0x01
     2ec:	1b c0       	rjmp	.+54     	; 0x324 <xTimerGenericCommand+0xac>
     2ee:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     2f2:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     2f6:	be 01       	movw	r22, r28
     2f8:	6e 5f       	subi	r22, 0xFE	; 254
     2fa:	7f 4f       	sbci	r23, 0xFF	; 255
     2fc:	20 e0       	ldi	r18, 0x00	; 0
     2fe:	40 e0       	ldi	r20, 0x00	; 0
     300:	50 e0       	ldi	r21, 0x00	; 0
     302:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xQueueGenericSend>
     306:	89 83       	std	Y+1, r24	; 0x01
     308:	0d c0       	rjmp	.+26     	; 0x324 <xTimerGenericCommand+0xac>
     30a:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     30e:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     312:	4c 85       	ldd	r20, Y+12	; 0x0c
     314:	5d 85       	ldd	r21, Y+13	; 0x0d
     316:	be 01       	movw	r22, r28
     318:	6e 5f       	subi	r22, 0xFE	; 254
     31a:	7f 4f       	sbci	r23, 0xFF	; 255
     31c:	20 e0       	ldi	r18, 0x00	; 0
     31e:	0e 94 67 0b 	call	0x16ce	; 0x16ce <xQueueGenericSendFromISR>
     322:	89 83       	std	Y+1, r24	; 0x01
     324:	89 81       	ldd	r24, Y+1	; 0x01
     326:	2f 96       	adiw	r28, 0x0f	; 15
     328:	0f b6       	in	r0, 0x3f	; 63
     32a:	f8 94       	cli
     32c:	de bf       	out	0x3e, r29	; 62
     32e:	0f be       	out	0x3f, r0	; 63
     330:	cd bf       	out	0x3d, r28	; 61
     332:	df 91       	pop	r29
     334:	cf 91       	pop	r28
     336:	1f 91       	pop	r17
     338:	0f 91       	pop	r16
     33a:	08 95       	ret

0000033c <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
     33c:	0f 93       	push	r16
     33e:	1f 93       	push	r17
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	cd b7       	in	r28, 0x3d	; 61
     346:	de b7       	in	r29, 0x3e	; 62
     348:	27 97       	sbiw	r28, 0x07	; 7
     34a:	0f b6       	in	r0, 0x3f	; 63
     34c:	f8 94       	cli
     34e:	de bf       	out	0x3e, r29	; 62
     350:	0f be       	out	0x3f, r0	; 63
     352:	cd bf       	out	0x3d, r28	; 61
     354:	9d 83       	std	Y+5, r25	; 0x05
     356:	8c 83       	std	Y+4, r24	; 0x04
     358:	7f 83       	std	Y+7, r23	; 0x07
     35a:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
     35c:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     360:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     364:	fc 01       	movw	r30, r24
     366:	85 81       	ldd	r24, Z+5	; 0x05
     368:	96 81       	ldd	r25, Z+6	; 0x06
     36a:	fc 01       	movw	r30, r24
     36c:	86 81       	ldd	r24, Z+6	; 0x06
     36e:	97 81       	ldd	r25, Z+7	; 0x07
     370:	9a 83       	std	Y+2, r25	; 0x02
     372:	89 83       	std	Y+1, r24	; 0x01

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	9a 81       	ldd	r25, Y+2	; 0x02
     378:	02 96       	adiw	r24, 0x02	; 2
     37a:	e3 d3       	rcall	.+1990   	; 0xb42 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	9a 81       	ldd	r25, Y+2	; 0x02
     380:	fc 01       	movw	r30, r24
     382:	86 85       	ldd	r24, Z+14	; 0x0e
     384:	81 30       	cpi	r24, 0x01	; 1
     386:	f1 f4       	brne	.+60     	; 0x3c4 <prvProcessExpiredTimer+0x88>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
     388:	89 81       	ldd	r24, Y+1	; 0x01
     38a:	9a 81       	ldd	r25, Y+2	; 0x02
     38c:	fc 01       	movw	r30, r24
     38e:	24 85       	ldd	r18, Z+12	; 0x0c
     390:	35 85       	ldd	r19, Z+13	; 0x0d
     392:	8c 81       	ldd	r24, Y+4	; 0x04
     394:	9d 81       	ldd	r25, Y+5	; 0x05
     396:	b9 01       	movw	r22, r18
     398:	68 0f       	add	r22, r24
     39a:	79 1f       	adc	r23, r25
     39c:	2c 81       	ldd	r18, Y+4	; 0x04
     39e:	3d 81       	ldd	r19, Y+5	; 0x05
     3a0:	4e 81       	ldd	r20, Y+6	; 0x06
     3a2:	5f 81       	ldd	r21, Y+7	; 0x07
     3a4:	89 81       	ldd	r24, Y+1	; 0x01
     3a6:	9a 81       	ldd	r25, Y+2	; 0x02
     3a8:	de d0       	rcall	.+444    	; 0x566 <prvInsertTimerInActiveList>
     3aa:	81 30       	cpi	r24, 0x01	; 1
     3ac:	59 f4       	brne	.+22     	; 0x3c4 <prvProcessExpiredTimer+0x88>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
     3ae:	4c 81       	ldd	r20, Y+4	; 0x04
     3b0:	5d 81       	ldd	r21, Y+5	; 0x05
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	9a 81       	ldd	r25, Y+2	; 0x02
     3b6:	00 e0       	ldi	r16, 0x00	; 0
     3b8:	10 e0       	ldi	r17, 0x00	; 0
     3ba:	20 e0       	ldi	r18, 0x00	; 0
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	60 e0       	ldi	r22, 0x00	; 0
     3c0:	5b df       	rcall	.-330    	; 0x278 <xTimerGenericCommand>
     3c2:	8b 83       	std	Y+3, r24	; 0x03
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
     3c4:	89 81       	ldd	r24, Y+1	; 0x01
     3c6:	9a 81       	ldd	r25, Y+2	; 0x02
     3c8:	fc 01       	movw	r30, r24
     3ca:	21 89       	ldd	r18, Z+17	; 0x11
     3cc:	32 89       	ldd	r19, Z+18	; 0x12
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	9a 81       	ldd	r25, Y+2	; 0x02
     3d2:	f9 01       	movw	r30, r18
     3d4:	19 95       	eicall
}
     3d6:	27 96       	adiw	r28, 0x07	; 7
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	de bf       	out	0x3e, r29	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	cd bf       	out	0x3d, r28	; 61
     3e2:	df 91       	pop	r29
     3e4:	cf 91       	pop	r28
     3e6:	1f 91       	pop	r17
     3e8:	0f 91       	pop	r16
     3ea:	08 95       	ret

000003ec <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
     3ec:	cf 93       	push	r28
     3ee:	df 93       	push	r29
     3f0:	00 d0       	rcall	.+0      	; 0x3f2 <prvTimerTask+0x6>
     3f2:	1f 92       	push	r1
     3f4:	1f 92       	push	r1
     3f6:	cd b7       	in	r28, 0x3d	; 61
     3f8:	de b7       	in	r29, 0x3e	; 62
     3fa:	9d 83       	std	Y+5, r25	; 0x05
     3fc:	8c 83       	std	Y+4, r24	; 0x04

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
     3fe:	ce 01       	movw	r24, r28
     400:	03 96       	adiw	r24, 0x03	; 3
     402:	4d d0       	rcall	.+154    	; 0x49e <prvGetNextExpireTime>
     404:	9a 83       	std	Y+2, r25	; 0x02
     406:	89 83       	std	Y+1, r24	; 0x01

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
     408:	2b 81       	ldd	r18, Y+3	; 0x03
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	9a 81       	ldd	r25, Y+2	; 0x02
     40e:	62 2f       	mov	r22, r18
     410:	02 d0       	rcall	.+4      	; 0x416 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
     412:	14 d1       	rcall	.+552    	; 0x63c <prvProcessReceivedCommands>
	}
     414:	f4 cf       	rjmp	.-24     	; 0x3fe <prvTimerTask+0x12>

00000416 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
     416:	cf 93       	push	r28
     418:	df 93       	push	r29
     41a:	00 d0       	rcall	.+0      	; 0x41c <prvProcessTimerOrBlockTask+0x6>
     41c:	00 d0       	rcall	.+0      	; 0x41e <prvProcessTimerOrBlockTask+0x8>
     41e:	cd b7       	in	r28, 0x3d	; 61
     420:	de b7       	in	r29, 0x3e	; 62
     422:	9d 83       	std	Y+5, r25	; 0x05
     424:	8c 83       	std	Y+4, r24	; 0x04
     426:	6e 83       	std	Y+6, r22	; 0x06
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
     428:	0e 94 7f 10 	call	0x20fe	; 0x20fe <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
     42c:	ce 01       	movw	r24, r28
     42e:	03 96       	adiw	r24, 0x03	; 3
     430:	6b d0       	rcall	.+214    	; 0x508 <prvSampleTimeNow>
     432:	9a 83       	std	Y+2, r25	; 0x02
     434:	89 83       	std	Y+1, r24	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
     436:	8b 81       	ldd	r24, Y+3	; 0x03
     438:	88 23       	and	r24, r24
     43a:	31 f5       	brne	.+76     	; 0x488 <prvProcessTimerOrBlockTask+0x72>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
     43c:	8e 81       	ldd	r24, Y+6	; 0x06
     43e:	88 23       	and	r24, r24
     440:	81 f4       	brne	.+32     	; 0x462 <prvProcessTimerOrBlockTask+0x4c>
     442:	2c 81       	ldd	r18, Y+4	; 0x04
     444:	3d 81       	ldd	r19, Y+5	; 0x05
     446:	89 81       	ldd	r24, Y+1	; 0x01
     448:	9a 81       	ldd	r25, Y+2	; 0x02
     44a:	82 17       	cp	r24, r18
     44c:	93 07       	cpc	r25, r19
     44e:	48 f0       	brcs	.+18     	; 0x462 <prvProcessTimerOrBlockTask+0x4c>
			{
				( void ) xTaskResumeAll();
     450:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
     454:	29 81       	ldd	r18, Y+1	; 0x01
     456:	3a 81       	ldd	r19, Y+2	; 0x02
     458:	8c 81       	ldd	r24, Y+4	; 0x04
     45a:	9d 81       	ldd	r25, Y+5	; 0x05
     45c:	b9 01       	movw	r22, r18
     45e:	6e df       	rcall	.-292    	; 0x33c <prvProcessExpiredTimer>
     460:	15 c0       	rjmp	.+42     	; 0x48c <prvProcessTimerOrBlockTask+0x76>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
     462:	2c 81       	ldd	r18, Y+4	; 0x04
     464:	3d 81       	ldd	r19, Y+5	; 0x05
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	9a 81       	ldd	r25, Y+2	; 0x02
     46a:	28 1b       	sub	r18, r24
     46c:	39 0b       	sbc	r19, r25
     46e:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     472:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     476:	b9 01       	movw	r22, r18
     478:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
     47c:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
     480:	88 23       	and	r24, r24
     482:	21 f4       	brne	.+8      	; 0x48c <prvProcessTimerOrBlockTask+0x76>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
     484:	b1 d5       	rcall	.+2914   	; 0xfe8 <vPortYield>
     486:	02 c0       	rjmp	.+4      	; 0x48c <prvProcessTimerOrBlockTask+0x76>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
     488:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
		}
	}
}
     48c:	26 96       	adiw	r28, 0x06	; 6
     48e:	0f b6       	in	r0, 0x3f	; 63
     490:	f8 94       	cli
     492:	de bf       	out	0x3e, r29	; 62
     494:	0f be       	out	0x3f, r0	; 63
     496:	cd bf       	out	0x3d, r28	; 61
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	08 95       	ret

0000049e <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
     49e:	cf 93       	push	r28
     4a0:	df 93       	push	r29
     4a2:	00 d0       	rcall	.+0      	; 0x4a4 <prvGetNextExpireTime+0x6>
     4a4:	1f 92       	push	r1
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	9c 83       	std	Y+4, r25	; 0x04
     4ac:	8b 83       	std	Y+3, r24	; 0x03
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
     4ae:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     4b2:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     4b6:	fc 01       	movw	r30, r24
     4b8:	90 81       	ld	r25, Z
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	99 23       	and	r25, r25
     4be:	09 f0       	breq	.+2      	; 0x4c2 <prvGetNextExpireTime+0x24>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	28 2f       	mov	r18, r24
     4c4:	8b 81       	ldd	r24, Y+3	; 0x03
     4c6:	9c 81       	ldd	r25, Y+4	; 0x04
     4c8:	fc 01       	movw	r30, r24
     4ca:	20 83       	st	Z, r18
	if( *pxListWasEmpty == pdFALSE )
     4cc:	8b 81       	ldd	r24, Y+3	; 0x03
     4ce:	9c 81       	ldd	r25, Y+4	; 0x04
     4d0:	fc 01       	movw	r30, r24
     4d2:	80 81       	ld	r24, Z
     4d4:	88 23       	and	r24, r24
     4d6:	69 f4       	brne	.+26     	; 0x4f2 <prvGetNextExpireTime+0x54>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
     4d8:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     4dc:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     4e0:	fc 01       	movw	r30, r24
     4e2:	85 81       	ldd	r24, Z+5	; 0x05
     4e4:	96 81       	ldd	r25, Z+6	; 0x06
     4e6:	fc 01       	movw	r30, r24
     4e8:	80 81       	ld	r24, Z
     4ea:	91 81       	ldd	r25, Z+1	; 0x01
     4ec:	9a 83       	std	Y+2, r25	; 0x02
     4ee:	89 83       	std	Y+1, r24	; 0x01
     4f0:	02 c0       	rjmp	.+4      	; 0x4f6 <prvGetNextExpireTime+0x58>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
     4f2:	1a 82       	std	Y+2, r1	; 0x02
     4f4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xNextExpireTime;
     4f6:	89 81       	ldd	r24, Y+1	; 0x01
     4f8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     4fa:	0f 90       	pop	r0
     4fc:	0f 90       	pop	r0
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
     502:	df 91       	pop	r29
     504:	cf 91       	pop	r28
     506:	08 95       	ret

00000508 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	00 d0       	rcall	.+0      	; 0x50e <prvSampleTimeNow+0x6>
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
     514:	9c 83       	std	Y+4, r25	; 0x04
     516:	8b 83       	std	Y+3, r24	; 0x03
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
     518:	0e 94 17 11 	call	0x222e	; 0x222e <xTaskGetTickCount>
     51c:	9a 83       	std	Y+2, r25	; 0x02
     51e:	89 83       	std	Y+1, r24	; 0x01

	if( xTimeNow < xLastTime )
     520:	80 91 5c 02 	lds	r24, 0x025C	; 0x80025c <xLastTime.2138>
     524:	90 91 5d 02 	lds	r25, 0x025D	; 0x80025d <xLastTime.2138+0x1>
     528:	29 81       	ldd	r18, Y+1	; 0x01
     52a:	3a 81       	ldd	r19, Y+2	; 0x02
     52c:	28 17       	cp	r18, r24
     52e:	39 07       	cpc	r19, r25
     530:	38 f4       	brcc	.+14     	; 0x540 <prvSampleTimeNow+0x38>
	{
		prvSwitchTimerLists();
     532:	38 d1       	rcall	.+624    	; 0x7a4 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
     534:	8b 81       	ldd	r24, Y+3	; 0x03
     536:	9c 81       	ldd	r25, Y+4	; 0x04
     538:	21 e0       	ldi	r18, 0x01	; 1
     53a:	fc 01       	movw	r30, r24
     53c:	20 83       	st	Z, r18
     53e:	04 c0       	rjmp	.+8      	; 0x548 <prvSampleTimeNow+0x40>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
     540:	8b 81       	ldd	r24, Y+3	; 0x03
     542:	9c 81       	ldd	r25, Y+4	; 0x04
     544:	fc 01       	movw	r30, r24
     546:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
     548:	89 81       	ldd	r24, Y+1	; 0x01
     54a:	9a 81       	ldd	r25, Y+2	; 0x02
     54c:	90 93 5d 02 	sts	0x025D, r25	; 0x80025d <xLastTime.2138+0x1>
     550:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <xLastTime.2138>

	return xTimeNow;
     554:	89 81       	ldd	r24, Y+1	; 0x01
     556:	9a 81       	ldd	r25, Y+2	; 0x02
}
     558:	0f 90       	pop	r0
     55a:	0f 90       	pop	r0
     55c:	0f 90       	pop	r0
     55e:	0f 90       	pop	r0
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	08 95       	ret

00000566 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	cd b7       	in	r28, 0x3d	; 61
     56c:	de b7       	in	r29, 0x3e	; 62
     56e:	29 97       	sbiw	r28, 0x09	; 9
     570:	0f b6       	in	r0, 0x3f	; 63
     572:	f8 94       	cli
     574:	de bf       	out	0x3e, r29	; 62
     576:	0f be       	out	0x3f, r0	; 63
     578:	cd bf       	out	0x3d, r28	; 61
     57a:	9b 83       	std	Y+3, r25	; 0x03
     57c:	8a 83       	std	Y+2, r24	; 0x02
     57e:	7d 83       	std	Y+5, r23	; 0x05
     580:	6c 83       	std	Y+4, r22	; 0x04
     582:	5f 83       	std	Y+7, r21	; 0x07
     584:	4e 83       	std	Y+6, r20	; 0x06
     586:	39 87       	std	Y+9, r19	; 0x09
     588:	28 87       	std	Y+8, r18	; 0x08
BaseType_t xProcessTimerNow = pdFALSE;
     58a:	19 82       	std	Y+1, r1	; 0x01

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
     58c:	8a 81       	ldd	r24, Y+2	; 0x02
     58e:	9b 81       	ldd	r25, Y+3	; 0x03
     590:	2c 81       	ldd	r18, Y+4	; 0x04
     592:	3d 81       	ldd	r19, Y+5	; 0x05
     594:	fc 01       	movw	r30, r24
     596:	33 83       	std	Z+3, r19	; 0x03
     598:	22 83       	std	Z+2, r18	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
     59a:	8a 81       	ldd	r24, Y+2	; 0x02
     59c:	9b 81       	ldd	r25, Y+3	; 0x03
     59e:	2a 81       	ldd	r18, Y+2	; 0x02
     5a0:	3b 81       	ldd	r19, Y+3	; 0x03
     5a2:	fc 01       	movw	r30, r24
     5a4:	31 87       	std	Z+9, r19	; 0x09
     5a6:	20 87       	std	Z+8, r18	; 0x08

	if( xNextExpiryTime <= xTimeNow )
     5a8:	2c 81       	ldd	r18, Y+4	; 0x04
     5aa:	3d 81       	ldd	r19, Y+5	; 0x05
     5ac:	8e 81       	ldd	r24, Y+6	; 0x06
     5ae:	9f 81       	ldd	r25, Y+7	; 0x07
     5b0:	82 17       	cp	r24, r18
     5b2:	93 07       	cpc	r25, r19
     5b4:	e8 f0       	brcs	.+58     	; 0x5f0 <prvInsertTimerInActiveList+0x8a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
     5b6:	2e 81       	ldd	r18, Y+6	; 0x06
     5b8:	3f 81       	ldd	r19, Y+7	; 0x07
     5ba:	88 85       	ldd	r24, Y+8	; 0x08
     5bc:	99 85       	ldd	r25, Y+9	; 0x09
     5be:	28 1b       	sub	r18, r24
     5c0:	39 0b       	sbc	r19, r25
     5c2:	8a 81       	ldd	r24, Y+2	; 0x02
     5c4:	9b 81       	ldd	r25, Y+3	; 0x03
     5c6:	fc 01       	movw	r30, r24
     5c8:	84 85       	ldd	r24, Z+12	; 0x0c
     5ca:	95 85       	ldd	r25, Z+13	; 0x0d
     5cc:	28 17       	cp	r18, r24
     5ce:	39 07       	cpc	r19, r25
     5d0:	18 f0       	brcs	.+6      	; 0x5d8 <prvInsertTimerInActiveList+0x72>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	89 83       	std	Y+1, r24	; 0x01
     5d6:	28 c0       	rjmp	.+80     	; 0x628 <prvInsertTimerInActiveList+0xc2>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
     5d8:	8a 81       	ldd	r24, Y+2	; 0x02
     5da:	9b 81       	ldd	r25, Y+3	; 0x03
     5dc:	9c 01       	movw	r18, r24
     5de:	2e 5f       	subi	r18, 0xFE	; 254
     5e0:	3f 4f       	sbci	r19, 0xFF	; 255
     5e2:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <pxOverflowTimerList>
     5e6:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <pxOverflowTimerList+0x1>
     5ea:	b9 01       	movw	r22, r18
     5ec:	33 d2       	rcall	.+1126   	; 0xa54 <vListInsert>
     5ee:	1c c0       	rjmp	.+56     	; 0x628 <prvInsertTimerInActiveList+0xc2>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
     5f0:	2e 81       	ldd	r18, Y+6	; 0x06
     5f2:	3f 81       	ldd	r19, Y+7	; 0x07
     5f4:	88 85       	ldd	r24, Y+8	; 0x08
     5f6:	99 85       	ldd	r25, Y+9	; 0x09
     5f8:	28 17       	cp	r18, r24
     5fa:	39 07       	cpc	r19, r25
     5fc:	50 f4       	brcc	.+20     	; 0x612 <prvInsertTimerInActiveList+0xac>
     5fe:	2c 81       	ldd	r18, Y+4	; 0x04
     600:	3d 81       	ldd	r19, Y+5	; 0x05
     602:	88 85       	ldd	r24, Y+8	; 0x08
     604:	99 85       	ldd	r25, Y+9	; 0x09
     606:	28 17       	cp	r18, r24
     608:	39 07       	cpc	r19, r25
     60a:	18 f0       	brcs	.+6      	; 0x612 <prvInsertTimerInActiveList+0xac>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	89 83       	std	Y+1, r24	; 0x01
     610:	0b c0       	rjmp	.+22     	; 0x628 <prvInsertTimerInActiveList+0xc2>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
     612:	8a 81       	ldd	r24, Y+2	; 0x02
     614:	9b 81       	ldd	r25, Y+3	; 0x03
     616:	9c 01       	movw	r18, r24
     618:	2e 5f       	subi	r18, 0xFE	; 254
     61a:	3f 4f       	sbci	r19, 0xFF	; 255
     61c:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     620:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     624:	b9 01       	movw	r22, r18
     626:	16 d2       	rcall	.+1068   	; 0xa54 <vListInsert>
		}
	}

	return xProcessTimerNow;
     628:	89 81       	ldd	r24, Y+1	; 0x01
}
     62a:	29 96       	adiw	r28, 0x09	; 9
     62c:	0f b6       	in	r0, 0x3f	; 63
     62e:	f8 94       	cli
     630:	de bf       	out	0x3e, r29	; 62
     632:	0f be       	out	0x3f, r0	; 63
     634:	cd bf       	out	0x3d, r28	; 61
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	cf 93       	push	r28
     642:	df 93       	push	r29
     644:	cd b7       	in	r28, 0x3d	; 61
     646:	de b7       	in	r29, 0x3e	; 62
     648:	2b 97       	sbiw	r28, 0x0b	; 11
     64a:	0f b6       	in	r0, 0x3f	; 63
     64c:	f8 94       	cli
     64e:	de bf       	out	0x3e, r29	; 62
     650:	0f be       	out	0x3f, r0	; 63
     652:	cd bf       	out	0x3d, r28	; 61
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
     654:	8d c0       	rjmp	.+282    	; 0x770 <prvProcessReceivedCommands+0x134>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
     656:	8e 81       	ldd	r24, Y+6	; 0x06
     658:	88 23       	and	r24, r24
     65a:	0c f4       	brge	.+2      	; 0x65e <prvProcessReceivedCommands+0x22>
     65c:	89 c0       	rjmp	.+274    	; 0x770 <prvProcessReceivedCommands+0x134>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
     65e:	89 85       	ldd	r24, Y+9	; 0x09
     660:	9a 85       	ldd	r25, Y+10	; 0x0a
     662:	9a 83       	std	Y+2, r25	; 0x02
     664:	89 83       	std	Y+1, r24	; 0x01

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
     666:	89 81       	ldd	r24, Y+1	; 0x01
     668:	9a 81       	ldd	r25, Y+2	; 0x02
     66a:	dc 01       	movw	r26, r24
     66c:	1a 96       	adiw	r26, 0x0a	; 10
     66e:	8d 91       	ld	r24, X+
     670:	9c 91       	ld	r25, X
     672:	1b 97       	sbiw	r26, 0x0b	; 11
     674:	89 2b       	or	r24, r25
     676:	21 f0       	breq	.+8      	; 0x680 <prvProcessReceivedCommands+0x44>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
     678:	89 81       	ldd	r24, Y+1	; 0x01
     67a:	9a 81       	ldd	r25, Y+2	; 0x02
     67c:	02 96       	adiw	r24, 0x02	; 2
     67e:	61 d2       	rcall	.+1218   	; 0xb42 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
     680:	ce 01       	movw	r24, r28
     682:	0b 96       	adiw	r24, 0x0b	; 11
     684:	41 df       	rcall	.-382    	; 0x508 <prvSampleTimeNow>
     686:	9c 83       	std	Y+4, r25	; 0x04
     688:	8b 83       	std	Y+3, r24	; 0x03

			switch( xMessage.xMessageID )
     68a:	8e 81       	ldd	r24, Y+6	; 0x06
     68c:	08 2e       	mov	r0, r24
     68e:	00 0c       	add	r0, r0
     690:	99 0b       	sbc	r25, r25
     692:	09 2e       	mov	r0, r25
     694:	00 0c       	add	r0, r0
     696:	aa 0b       	sbc	r26, r26
     698:	bb 0b       	sbc	r27, r27
     69a:	40 e0       	ldi	r20, 0x00	; 0
     69c:	50 e0       	ldi	r21, 0x00	; 0
     69e:	29 e0       	ldi	r18, 0x09	; 9
     6a0:	30 e0       	ldi	r19, 0x00	; 0
     6a2:	84 1b       	sub	r24, r20
     6a4:	95 0b       	sbc	r25, r21
     6a6:	28 17       	cp	r18, r24
     6a8:	39 07       	cpc	r19, r25
     6aa:	08 f4       	brcc	.+2      	; 0x6ae <prvProcessReceivedCommands+0x72>
     6ac:	60 c0       	rjmp	.+192    	; 0x76e <prvProcessReceivedCommands+0x132>
     6ae:	fc 01       	movw	r30, r24
     6b0:	88 27       	eor	r24, r24
     6b2:	ee 58       	subi	r30, 0x8E	; 142
     6b4:	ff 4f       	sbci	r31, 0xFF	; 255
     6b6:	8f 4f       	sbci	r24, 0xFF	; 255
     6b8:	0c 94 d8 18 	jmp	0x31b0	; 0x31b0 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
     6bc:	ef 81       	ldd	r30, Y+7	; 0x07
     6be:	f8 85       	ldd	r31, Y+8	; 0x08
     6c0:	2f 81       	ldd	r18, Y+7	; 0x07
     6c2:	38 85       	ldd	r19, Y+8	; 0x08
     6c4:	89 81       	ldd	r24, Y+1	; 0x01
     6c6:	9a 81       	ldd	r25, Y+2	; 0x02
     6c8:	dc 01       	movw	r26, r24
     6ca:	1c 96       	adiw	r26, 0x0c	; 12
     6cc:	8d 91       	ld	r24, X+
     6ce:	9c 91       	ld	r25, X
     6d0:	1d 97       	sbiw	r26, 0x0d	; 13
     6d2:	b9 01       	movw	r22, r18
     6d4:	68 0f       	add	r22, r24
     6d6:	79 1f       	adc	r23, r25
     6d8:	4b 81       	ldd	r20, Y+3	; 0x03
     6da:	5c 81       	ldd	r21, Y+4	; 0x04
     6dc:	89 81       	ldd	r24, Y+1	; 0x01
     6de:	9a 81       	ldd	r25, Y+2	; 0x02
     6e0:	9f 01       	movw	r18, r30
     6e2:	41 df       	rcall	.-382    	; 0x566 <prvInsertTimerInActiveList>
     6e4:	81 30       	cpi	r24, 0x01	; 1
     6e6:	19 f5       	brne	.+70     	; 0x72e <prvProcessReceivedCommands+0xf2>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
     6e8:	89 81       	ldd	r24, Y+1	; 0x01
     6ea:	9a 81       	ldd	r25, Y+2	; 0x02
     6ec:	fc 01       	movw	r30, r24
     6ee:	21 89       	ldd	r18, Z+17	; 0x11
     6f0:	32 89       	ldd	r19, Z+18	; 0x12
     6f2:	89 81       	ldd	r24, Y+1	; 0x01
     6f4:	9a 81       	ldd	r25, Y+2	; 0x02
     6f6:	f9 01       	movw	r30, r18
     6f8:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
     6fa:	89 81       	ldd	r24, Y+1	; 0x01
     6fc:	9a 81       	ldd	r25, Y+2	; 0x02
     6fe:	dc 01       	movw	r26, r24
     700:	1e 96       	adiw	r26, 0x0e	; 14
     702:	8c 91       	ld	r24, X
     704:	81 30       	cpi	r24, 0x01	; 1
     706:	99 f4       	brne	.+38     	; 0x72e <prvProcessReceivedCommands+0xf2>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
     708:	2f 81       	ldd	r18, Y+7	; 0x07
     70a:	38 85       	ldd	r19, Y+8	; 0x08
     70c:	89 81       	ldd	r24, Y+1	; 0x01
     70e:	9a 81       	ldd	r25, Y+2	; 0x02
     710:	fc 01       	movw	r30, r24
     712:	84 85       	ldd	r24, Z+12	; 0x0c
     714:	95 85       	ldd	r25, Z+13	; 0x0d
     716:	a9 01       	movw	r20, r18
     718:	48 0f       	add	r20, r24
     71a:	59 1f       	adc	r21, r25
     71c:	89 81       	ldd	r24, Y+1	; 0x01
     71e:	9a 81       	ldd	r25, Y+2	; 0x02
     720:	00 e0       	ldi	r16, 0x00	; 0
     722:	10 e0       	ldi	r17, 0x00	; 0
     724:	20 e0       	ldi	r18, 0x00	; 0
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	60 e0       	ldi	r22, 0x00	; 0
     72a:	a6 dd       	rcall	.-1204   	; 0x278 <xTimerGenericCommand>
     72c:	8d 83       	std	Y+5, r24	; 0x05
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
     72e:	20 c0       	rjmp	.+64     	; 0x770 <prvProcessReceivedCommands+0x134>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
     730:	2f 81       	ldd	r18, Y+7	; 0x07
     732:	38 85       	ldd	r19, Y+8	; 0x08
     734:	89 81       	ldd	r24, Y+1	; 0x01
     736:	9a 81       	ldd	r25, Y+2	; 0x02
     738:	dc 01       	movw	r26, r24
     73a:	1d 96       	adiw	r26, 0x0d	; 13
     73c:	3c 93       	st	X, r19
     73e:	2e 93       	st	-X, r18
     740:	1c 97       	sbiw	r26, 0x0c	; 12
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
     742:	89 81       	ldd	r24, Y+1	; 0x01
     744:	9a 81       	ldd	r25, Y+2	; 0x02
     746:	fc 01       	movw	r30, r24
     748:	24 85       	ldd	r18, Z+12	; 0x0c
     74a:	35 85       	ldd	r19, Z+13	; 0x0d
     74c:	8b 81       	ldd	r24, Y+3	; 0x03
     74e:	9c 81       	ldd	r25, Y+4	; 0x04
     750:	b9 01       	movw	r22, r18
     752:	68 0f       	add	r22, r24
     754:	79 1f       	adc	r23, r25
     756:	2b 81       	ldd	r18, Y+3	; 0x03
     758:	3c 81       	ldd	r19, Y+4	; 0x04
     75a:	4b 81       	ldd	r20, Y+3	; 0x03
     75c:	5c 81       	ldd	r21, Y+4	; 0x04
     75e:	89 81       	ldd	r24, Y+1	; 0x01
     760:	9a 81       	ldd	r25, Y+2	; 0x02
     762:	01 df       	rcall	.-510    	; 0x566 <prvInsertTimerInActiveList>
					break;
     764:	05 c0       	rjmp	.+10     	; 0x770 <prvProcessReceivedCommands+0x134>

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
     766:	89 81       	ldd	r24, Y+1	; 0x01
     768:	9a 81       	ldd	r25, Y+2	; 0x02
     76a:	08 d6       	rcall	.+3088   	; 0x137c <vPortFree>
					break;
     76c:	01 c0       	rjmp	.+2      	; 0x770 <prvProcessReceivedCommands+0x134>

				default	:
					/* Don't expect to get here. */
					break;
     76e:	00 00       	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
     770:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     774:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     778:	be 01       	movw	r22, r28
     77a:	6a 5f       	subi	r22, 0xFA	; 250
     77c:	7f 4f       	sbci	r23, 0xFF	; 255
     77e:	20 e0       	ldi	r18, 0x00	; 0
     780:	40 e0       	ldi	r20, 0x00	; 0
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericReceive>
     788:	88 23       	and	r24, r24
     78a:	09 f0       	breq	.+2      	; 0x78e <prvProcessReceivedCommands+0x152>
     78c:	64 cf       	rjmp	.-312    	; 0x656 <prvProcessReceivedCommands+0x1a>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
     78e:	2b 96       	adiw	r28, 0x0b	; 11
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	f8 94       	cli
     794:	de bf       	out	0x3e, r29	; 62
     796:	0f be       	out	0x3f, r0	; 63
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
     7a4:	0f 93       	push	r16
     7a6:	1f 93       	push	r17
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	cd b7       	in	r28, 0x3d	; 61
     7ae:	de b7       	in	r29, 0x3e	; 62
     7b0:	29 97       	sbiw	r28, 0x09	; 9
     7b2:	0f b6       	in	r0, 0x3f	; 63
     7b4:	f8 94       	cli
     7b6:	de bf       	out	0x3e, r29	; 62
     7b8:	0f be       	out	0x3f, r0	; 63
     7ba:	cd bf       	out	0x3d, r28	; 61

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
     7bc:	62 c0       	rjmp	.+196    	; 0x882 <prvSwitchTimerLists+0xde>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
     7be:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     7c2:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     7c6:	fc 01       	movw	r30, r24
     7c8:	85 81       	ldd	r24, Z+5	; 0x05
     7ca:	96 81       	ldd	r25, Z+6	; 0x06
     7cc:	fc 01       	movw	r30, r24
     7ce:	80 81       	ld	r24, Z
     7d0:	91 81       	ldd	r25, Z+1	; 0x01
     7d2:	9a 83       	std	Y+2, r25	; 0x02
     7d4:	89 83       	std	Y+1, r24	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
     7d6:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     7da:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     7de:	fc 01       	movw	r30, r24
     7e0:	85 81       	ldd	r24, Z+5	; 0x05
     7e2:	96 81       	ldd	r25, Z+6	; 0x06
     7e4:	fc 01       	movw	r30, r24
     7e6:	86 81       	ldd	r24, Z+6	; 0x06
     7e8:	97 81       	ldd	r25, Z+7	; 0x07
     7ea:	9c 83       	std	Y+4, r25	; 0x04
     7ec:	8b 83       	std	Y+3, r24	; 0x03
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
     7ee:	8b 81       	ldd	r24, Y+3	; 0x03
     7f0:	9c 81       	ldd	r25, Y+4	; 0x04
     7f2:	02 96       	adiw	r24, 0x02	; 2
     7f4:	a6 d1       	rcall	.+844    	; 0xb42 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	9c 81       	ldd	r25, Y+4	; 0x04
     7fa:	fc 01       	movw	r30, r24
     7fc:	21 89       	ldd	r18, Z+17	; 0x11
     7fe:	32 89       	ldd	r19, Z+18	; 0x12
     800:	8b 81       	ldd	r24, Y+3	; 0x03
     802:	9c 81       	ldd	r25, Y+4	; 0x04
     804:	f9 01       	movw	r30, r18
     806:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
     808:	8b 81       	ldd	r24, Y+3	; 0x03
     80a:	9c 81       	ldd	r25, Y+4	; 0x04
     80c:	fc 01       	movw	r30, r24
     80e:	86 85       	ldd	r24, Z+14	; 0x0e
     810:	81 30       	cpi	r24, 0x01	; 1
     812:	b9 f5       	brne	.+110    	; 0x882 <prvSwitchTimerLists+0xde>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
     814:	8b 81       	ldd	r24, Y+3	; 0x03
     816:	9c 81       	ldd	r25, Y+4	; 0x04
     818:	fc 01       	movw	r30, r24
     81a:	24 85       	ldd	r18, Z+12	; 0x0c
     81c:	35 85       	ldd	r19, Z+13	; 0x0d
     81e:	89 81       	ldd	r24, Y+1	; 0x01
     820:	9a 81       	ldd	r25, Y+2	; 0x02
     822:	82 0f       	add	r24, r18
     824:	93 1f       	adc	r25, r19
     826:	9e 83       	std	Y+6, r25	; 0x06
     828:	8d 83       	std	Y+5, r24	; 0x05
			if( xReloadTime > xNextExpireTime )
     82a:	2d 81       	ldd	r18, Y+5	; 0x05
     82c:	3e 81       	ldd	r19, Y+6	; 0x06
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	82 17       	cp	r24, r18
     834:	93 07       	cpc	r25, r19
     836:	d0 f4       	brcc	.+52     	; 0x86c <prvSwitchTimerLists+0xc8>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
     838:	8b 81       	ldd	r24, Y+3	; 0x03
     83a:	9c 81       	ldd	r25, Y+4	; 0x04
     83c:	2d 81       	ldd	r18, Y+5	; 0x05
     83e:	3e 81       	ldd	r19, Y+6	; 0x06
     840:	fc 01       	movw	r30, r24
     842:	33 83       	std	Z+3, r19	; 0x03
     844:	22 83       	std	Z+2, r18	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
     846:	8b 81       	ldd	r24, Y+3	; 0x03
     848:	9c 81       	ldd	r25, Y+4	; 0x04
     84a:	2b 81       	ldd	r18, Y+3	; 0x03
     84c:	3c 81       	ldd	r19, Y+4	; 0x04
     84e:	fc 01       	movw	r30, r24
     850:	31 87       	std	Z+9, r19	; 0x09
     852:	20 87       	std	Z+8, r18	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
     854:	8b 81       	ldd	r24, Y+3	; 0x03
     856:	9c 81       	ldd	r25, Y+4	; 0x04
     858:	9c 01       	movw	r18, r24
     85a:	2e 5f       	subi	r18, 0xFE	; 254
     85c:	3f 4f       	sbci	r19, 0xFF	; 255
     85e:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     862:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     866:	b9 01       	movw	r22, r18
     868:	f5 d0       	rcall	.+490    	; 0xa54 <vListInsert>
     86a:	0b c0       	rjmp	.+22     	; 0x882 <prvSwitchTimerLists+0xde>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
     86c:	49 81       	ldd	r20, Y+1	; 0x01
     86e:	5a 81       	ldd	r21, Y+2	; 0x02
     870:	8b 81       	ldd	r24, Y+3	; 0x03
     872:	9c 81       	ldd	r25, Y+4	; 0x04
     874:	00 e0       	ldi	r16, 0x00	; 0
     876:	10 e0       	ldi	r17, 0x00	; 0
     878:	20 e0       	ldi	r18, 0x00	; 0
     87a:	30 e0       	ldi	r19, 0x00	; 0
     87c:	60 e0       	ldi	r22, 0x00	; 0
     87e:	fc dc       	rcall	.-1544   	; 0x278 <xTimerGenericCommand>
     880:	8f 83       	std	Y+7, r24	; 0x07

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
     882:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     886:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     88a:	fc 01       	movw	r30, r24
     88c:	80 81       	ld	r24, Z
     88e:	88 23       	and	r24, r24
     890:	09 f0       	breq	.+2      	; 0x894 <prvSwitchTimerLists+0xf0>
     892:	95 cf       	rjmp	.-214    	; 0x7be <prvSwitchTimerLists+0x1a>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
     894:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTimerList>
     898:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTimerList+0x1>
     89c:	99 87       	std	Y+9, r25	; 0x09
     89e:	88 87       	std	Y+8, r24	; 0x08
	pxCurrentTimerList = pxOverflowTimerList;
     8a0:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <pxOverflowTimerList>
     8a4:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <pxOverflowTimerList+0x1>
     8a8:	90 93 57 02 	sts	0x0257, r25	; 0x800257 <pxCurrentTimerList+0x1>
     8ac:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
     8b0:	88 85       	ldd	r24, Y+8	; 0x08
     8b2:	99 85       	ldd	r25, Y+9	; 0x09
     8b4:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <pxOverflowTimerList+0x1>
     8b8:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <pxOverflowTimerList>
}
     8bc:	29 96       	adiw	r28, 0x09	; 9
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	f8 94       	cli
     8c2:	de bf       	out	0x3e, r29	; 62
     8c4:	0f be       	out	0x3f, r0	; 63
     8c6:	cd bf       	out	0x3d, r28	; 61
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	1f 91       	pop	r17
     8ce:	0f 91       	pop	r16
     8d0:	08 95       	ret

000008d2 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
     8da:	0f b6       	in	r0, 0x3f	; 63
     8dc:	f8 94       	cli
     8de:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
     8e0:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <xTimerQueue>
     8e4:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <xTimerQueue+0x1>
     8e8:	89 2b       	or	r24, r25
     8ea:	d1 f4       	brne	.+52     	; 0x920 <prvCheckForValidListAndQueue+0x4e>
		{
			vListInitialise( &xActiveTimerList1 );
     8ec:	84 e4       	ldi	r24, 0x44	; 68
     8ee:	92 e0       	ldi	r25, 0x02	; 2
     8f0:	1c d0       	rcall	.+56     	; 0x92a <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
     8f2:	8d e4       	ldi	r24, 0x4D	; 77
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	19 d0       	rcall	.+50     	; 0x92a <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
     8f8:	84 e4       	ldi	r24, 0x44	; 68
     8fa:	92 e0       	ldi	r25, 0x02	; 2
     8fc:	90 93 57 02 	sts	0x0257, r25	; 0x800257 <pxCurrentTimerList+0x1>
     900:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
     904:	8d e4       	ldi	r24, 0x4D	; 77
     906:	92 e0       	ldi	r25, 0x02	; 2
     908:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <pxOverflowTimerList+0x1>
     90c:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <pxOverflowTimerList>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
     910:	40 e0       	ldi	r20, 0x00	; 0
     912:	65 e0       	ldi	r22, 0x05	; 5
     914:	8a e0       	ldi	r24, 0x0A	; 10
     916:	d0 d5       	rcall	.+2976   	; 0x14b8 <xQueueGenericCreate>
     918:	90 93 5b 02 	sts	0x025B, r25	; 0x80025b <xTimerQueue+0x1>
     91c:	80 93 5a 02 	sts	0x025A, r24	; 0x80025a <xTimerQueue>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     920:	0f 90       	pop	r0
     922:	0f be       	out	0x3f, r0	; 63
}
     924:	df 91       	pop	r29
     926:	cf 91       	pop	r28
     928:	08 95       	ret

0000092a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
     92e:	1f 92       	push	r1
     930:	1f 92       	push	r1
     932:	cd b7       	in	r28, 0x3d	; 61
     934:	de b7       	in	r29, 0x3e	; 62
     936:	9a 83       	std	Y+2, r25	; 0x02
     938:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     93a:	89 81       	ldd	r24, Y+1	; 0x01
     93c:	9a 81       	ldd	r25, Y+2	; 0x02
     93e:	9c 01       	movw	r18, r24
     940:	2d 5f       	subi	r18, 0xFD	; 253
     942:	3f 4f       	sbci	r19, 0xFF	; 255
     944:	89 81       	ldd	r24, Y+1	; 0x01
     946:	9a 81       	ldd	r25, Y+2	; 0x02
     948:	fc 01       	movw	r30, r24
     94a:	32 83       	std	Z+2, r19	; 0x02
     94c:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     94e:	89 81       	ldd	r24, Y+1	; 0x01
     950:	9a 81       	ldd	r25, Y+2	; 0x02
     952:	2f ef       	ldi	r18, 0xFF	; 255
     954:	3f ef       	ldi	r19, 0xFF	; 255
     956:	fc 01       	movw	r30, r24
     958:	34 83       	std	Z+4, r19	; 0x04
     95a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     95c:	89 81       	ldd	r24, Y+1	; 0x01
     95e:	9a 81       	ldd	r25, Y+2	; 0x02
     960:	9c 01       	movw	r18, r24
     962:	2d 5f       	subi	r18, 0xFD	; 253
     964:	3f 4f       	sbci	r19, 0xFF	; 255
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	9a 81       	ldd	r25, Y+2	; 0x02
     96a:	fc 01       	movw	r30, r24
     96c:	36 83       	std	Z+6, r19	; 0x06
     96e:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     970:	89 81       	ldd	r24, Y+1	; 0x01
     972:	9a 81       	ldd	r25, Y+2	; 0x02
     974:	9c 01       	movw	r18, r24
     976:	2d 5f       	subi	r18, 0xFD	; 253
     978:	3f 4f       	sbci	r19, 0xFF	; 255
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	30 87       	std	Z+8, r19	; 0x08
     982:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     984:	89 81       	ldd	r24, Y+1	; 0x01
     986:	9a 81       	ldd	r25, Y+2	; 0x02
     988:	fc 01       	movw	r30, r24
     98a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     98c:	0f 90       	pop	r0
     98e:	0f 90       	pop	r0
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	08 95       	ret

00000996 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     996:	cf 93       	push	r28
     998:	df 93       	push	r29
     99a:	1f 92       	push	r1
     99c:	1f 92       	push	r1
     99e:	cd b7       	in	r28, 0x3d	; 61
     9a0:	de b7       	in	r29, 0x3e	; 62
     9a2:	9a 83       	std	Y+2, r25	; 0x02
     9a4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9a6:	89 81       	ldd	r24, Y+1	; 0x01
     9a8:	9a 81       	ldd	r25, Y+2	; 0x02
     9aa:	fc 01       	movw	r30, r24
     9ac:	11 86       	std	Z+9, r1	; 0x09
     9ae:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     9b0:	0f 90       	pop	r0
     9b2:	0f 90       	pop	r0
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	00 d0       	rcall	.+0      	; 0x9c0 <vListInsertEnd+0x6>
     9c0:	00 d0       	rcall	.+0      	; 0x9c2 <vListInsertEnd+0x8>
     9c2:	cd b7       	in	r28, 0x3d	; 61
     9c4:	de b7       	in	r29, 0x3e	; 62
     9c6:	9c 83       	std	Y+4, r25	; 0x04
     9c8:	8b 83       	std	Y+3, r24	; 0x03
     9ca:	7e 83       	std	Y+6, r23	; 0x06
     9cc:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     9ce:	8b 81       	ldd	r24, Y+3	; 0x03
     9d0:	9c 81       	ldd	r25, Y+4	; 0x04
     9d2:	fc 01       	movw	r30, r24
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
     9d6:	92 81       	ldd	r25, Z+2	; 0x02
     9d8:	9a 83       	std	Y+2, r25	; 0x02
     9da:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9dc:	8d 81       	ldd	r24, Y+5	; 0x05
     9de:	9e 81       	ldd	r25, Y+6	; 0x06
     9e0:	29 81       	ldd	r18, Y+1	; 0x01
     9e2:	3a 81       	ldd	r19, Y+2	; 0x02
     9e4:	fc 01       	movw	r30, r24
     9e6:	33 83       	std	Z+3, r19	; 0x03
     9e8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	fc 01       	movw	r30, r24
     9f0:	24 81       	ldd	r18, Z+4	; 0x04
     9f2:	35 81       	ldd	r19, Z+5	; 0x05
     9f4:	8d 81       	ldd	r24, Y+5	; 0x05
     9f6:	9e 81       	ldd	r25, Y+6	; 0x06
     9f8:	fc 01       	movw	r30, r24
     9fa:	35 83       	std	Z+5, r19	; 0x05
     9fc:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9fe:	89 81       	ldd	r24, Y+1	; 0x01
     a00:	9a 81       	ldd	r25, Y+2	; 0x02
     a02:	fc 01       	movw	r30, r24
     a04:	84 81       	ldd	r24, Z+4	; 0x04
     a06:	95 81       	ldd	r25, Z+5	; 0x05
     a08:	2d 81       	ldd	r18, Y+5	; 0x05
     a0a:	3e 81       	ldd	r19, Y+6	; 0x06
     a0c:	fc 01       	movw	r30, r24
     a0e:	33 83       	std	Z+3, r19	; 0x03
     a10:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	9a 81       	ldd	r25, Y+2	; 0x02
     a16:	2d 81       	ldd	r18, Y+5	; 0x05
     a18:	3e 81       	ldd	r19, Y+6	; 0x06
     a1a:	fc 01       	movw	r30, r24
     a1c:	35 83       	std	Z+5, r19	; 0x05
     a1e:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a20:	8d 81       	ldd	r24, Y+5	; 0x05
     a22:	9e 81       	ldd	r25, Y+6	; 0x06
     a24:	2b 81       	ldd	r18, Y+3	; 0x03
     a26:	3c 81       	ldd	r19, Y+4	; 0x04
     a28:	fc 01       	movw	r30, r24
     a2a:	31 87       	std	Z+9, r19	; 0x09
     a2c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a2e:	8b 81       	ldd	r24, Y+3	; 0x03
     a30:	9c 81       	ldd	r25, Y+4	; 0x04
     a32:	fc 01       	movw	r30, r24
     a34:	80 81       	ld	r24, Z
     a36:	21 e0       	ldi	r18, 0x01	; 1
     a38:	28 0f       	add	r18, r24
     a3a:	8b 81       	ldd	r24, Y+3	; 0x03
     a3c:	9c 81       	ldd	r25, Y+4	; 0x04
     a3e:	fc 01       	movw	r30, r24
     a40:	20 83       	st	Z, r18
}
     a42:	26 96       	adiw	r28, 0x06	; 6
     a44:	0f b6       	in	r0, 0x3f	; 63
     a46:	f8 94       	cli
     a48:	de bf       	out	0x3e, r29	; 62
     a4a:	0f be       	out	0x3f, r0	; 63
     a4c:	cd bf       	out	0x3d, r28	; 61
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	08 95       	ret

00000a54 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	cd b7       	in	r28, 0x3d	; 61
     a5a:	de b7       	in	r29, 0x3e	; 62
     a5c:	28 97       	sbiw	r28, 0x08	; 8
     a5e:	0f b6       	in	r0, 0x3f	; 63
     a60:	f8 94       	cli
     a62:	de bf       	out	0x3e, r29	; 62
     a64:	0f be       	out	0x3f, r0	; 63
     a66:	cd bf       	out	0x3d, r28	; 61
     a68:	9e 83       	std	Y+6, r25	; 0x06
     a6a:	8d 83       	std	Y+5, r24	; 0x05
     a6c:	78 87       	std	Y+8, r23	; 0x08
     a6e:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a70:	8f 81       	ldd	r24, Y+7	; 0x07
     a72:	98 85       	ldd	r25, Y+8	; 0x08
     a74:	fc 01       	movw	r30, r24
     a76:	80 81       	ld	r24, Z
     a78:	91 81       	ldd	r25, Z+1	; 0x01
     a7a:	9c 83       	std	Y+4, r25	; 0x04
     a7c:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a7e:	8b 81       	ldd	r24, Y+3	; 0x03
     a80:	9c 81       	ldd	r25, Y+4	; 0x04
     a82:	01 96       	adiw	r24, 0x01	; 1
     a84:	41 f4       	brne	.+16     	; 0xa96 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a86:	8d 81       	ldd	r24, Y+5	; 0x05
     a88:	9e 81       	ldd	r25, Y+6	; 0x06
     a8a:	fc 01       	movw	r30, r24
     a8c:	87 81       	ldd	r24, Z+7	; 0x07
     a8e:	90 85       	ldd	r25, Z+8	; 0x08
     a90:	9a 83       	std	Y+2, r25	; 0x02
     a92:	89 83       	std	Y+1, r24	; 0x01
     a94:	1a c0       	rjmp	.+52     	; 0xaca <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a96:	8d 81       	ldd	r24, Y+5	; 0x05
     a98:	9e 81       	ldd	r25, Y+6	; 0x06
     a9a:	03 96       	adiw	r24, 0x03	; 3
     a9c:	9a 83       	std	Y+2, r25	; 0x02
     a9e:	89 83       	std	Y+1, r24	; 0x01
     aa0:	07 c0       	rjmp	.+14     	; 0xab0 <vListInsert+0x5c>
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	fc 01       	movw	r30, r24
     aa8:	82 81       	ldd	r24, Z+2	; 0x02
     aaa:	93 81       	ldd	r25, Z+3	; 0x03
     aac:	9a 83       	std	Y+2, r25	; 0x02
     aae:	89 83       	std	Y+1, r24	; 0x01
     ab0:	89 81       	ldd	r24, Y+1	; 0x01
     ab2:	9a 81       	ldd	r25, Y+2	; 0x02
     ab4:	fc 01       	movw	r30, r24
     ab6:	82 81       	ldd	r24, Z+2	; 0x02
     ab8:	93 81       	ldd	r25, Z+3	; 0x03
     aba:	fc 01       	movw	r30, r24
     abc:	20 81       	ld	r18, Z
     abe:	31 81       	ldd	r19, Z+1	; 0x01
     ac0:	8b 81       	ldd	r24, Y+3	; 0x03
     ac2:	9c 81       	ldd	r25, Y+4	; 0x04
     ac4:	82 17       	cp	r24, r18
     ac6:	93 07       	cpc	r25, r19
     ac8:	60 f7       	brcc	.-40     	; 0xaa2 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     aca:	89 81       	ldd	r24, Y+1	; 0x01
     acc:	9a 81       	ldd	r25, Y+2	; 0x02
     ace:	fc 01       	movw	r30, r24
     ad0:	22 81       	ldd	r18, Z+2	; 0x02
     ad2:	33 81       	ldd	r19, Z+3	; 0x03
     ad4:	8f 81       	ldd	r24, Y+7	; 0x07
     ad6:	98 85       	ldd	r25, Y+8	; 0x08
     ad8:	fc 01       	movw	r30, r24
     ada:	33 83       	std	Z+3, r19	; 0x03
     adc:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     ade:	8f 81       	ldd	r24, Y+7	; 0x07
     ae0:	98 85       	ldd	r25, Y+8	; 0x08
     ae2:	fc 01       	movw	r30, r24
     ae4:	82 81       	ldd	r24, Z+2	; 0x02
     ae6:	93 81       	ldd	r25, Z+3	; 0x03
     ae8:	2f 81       	ldd	r18, Y+7	; 0x07
     aea:	38 85       	ldd	r19, Y+8	; 0x08
     aec:	fc 01       	movw	r30, r24
     aee:	35 83       	std	Z+5, r19	; 0x05
     af0:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     af2:	8f 81       	ldd	r24, Y+7	; 0x07
     af4:	98 85       	ldd	r25, Y+8	; 0x08
     af6:	29 81       	ldd	r18, Y+1	; 0x01
     af8:	3a 81       	ldd	r19, Y+2	; 0x02
     afa:	fc 01       	movw	r30, r24
     afc:	35 83       	std	Z+5, r19	; 0x05
     afe:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	9a 81       	ldd	r25, Y+2	; 0x02
     b04:	2f 81       	ldd	r18, Y+7	; 0x07
     b06:	38 85       	ldd	r19, Y+8	; 0x08
     b08:	fc 01       	movw	r30, r24
     b0a:	33 83       	std	Z+3, r19	; 0x03
     b0c:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b0e:	8f 81       	ldd	r24, Y+7	; 0x07
     b10:	98 85       	ldd	r25, Y+8	; 0x08
     b12:	2d 81       	ldd	r18, Y+5	; 0x05
     b14:	3e 81       	ldd	r19, Y+6	; 0x06
     b16:	fc 01       	movw	r30, r24
     b18:	31 87       	std	Z+9, r19	; 0x09
     b1a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     b1c:	8d 81       	ldd	r24, Y+5	; 0x05
     b1e:	9e 81       	ldd	r25, Y+6	; 0x06
     b20:	fc 01       	movw	r30, r24
     b22:	80 81       	ld	r24, Z
     b24:	21 e0       	ldi	r18, 0x01	; 1
     b26:	28 0f       	add	r18, r24
     b28:	8d 81       	ldd	r24, Y+5	; 0x05
     b2a:	9e 81       	ldd	r25, Y+6	; 0x06
     b2c:	fc 01       	movw	r30, r24
     b2e:	20 83       	st	Z, r18
}
     b30:	28 96       	adiw	r28, 0x08	; 8
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	f8 94       	cli
     b36:	de bf       	out	0x3e, r29	; 62
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	cd bf       	out	0x3d, r28	; 61
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	08 95       	ret

00000b42 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b42:	cf 93       	push	r28
     b44:	df 93       	push	r29
     b46:	00 d0       	rcall	.+0      	; 0xb48 <uxListRemove+0x6>
     b48:	1f 92       	push	r1
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	9c 83       	std	Y+4, r25	; 0x04
     b50:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     b52:	8b 81       	ldd	r24, Y+3	; 0x03
     b54:	9c 81       	ldd	r25, Y+4	; 0x04
     b56:	fc 01       	movw	r30, r24
     b58:	80 85       	ldd	r24, Z+8	; 0x08
     b5a:	91 85       	ldd	r25, Z+9	; 0x09
     b5c:	9a 83       	std	Y+2, r25	; 0x02
     b5e:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b60:	8b 81       	ldd	r24, Y+3	; 0x03
     b62:	9c 81       	ldd	r25, Y+4	; 0x04
     b64:	fc 01       	movw	r30, r24
     b66:	82 81       	ldd	r24, Z+2	; 0x02
     b68:	93 81       	ldd	r25, Z+3	; 0x03
     b6a:	2b 81       	ldd	r18, Y+3	; 0x03
     b6c:	3c 81       	ldd	r19, Y+4	; 0x04
     b6e:	f9 01       	movw	r30, r18
     b70:	24 81       	ldd	r18, Z+4	; 0x04
     b72:	35 81       	ldd	r19, Z+5	; 0x05
     b74:	fc 01       	movw	r30, r24
     b76:	35 83       	std	Z+5, r19	; 0x05
     b78:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b7a:	8b 81       	ldd	r24, Y+3	; 0x03
     b7c:	9c 81       	ldd	r25, Y+4	; 0x04
     b7e:	fc 01       	movw	r30, r24
     b80:	84 81       	ldd	r24, Z+4	; 0x04
     b82:	95 81       	ldd	r25, Z+5	; 0x05
     b84:	2b 81       	ldd	r18, Y+3	; 0x03
     b86:	3c 81       	ldd	r19, Y+4	; 0x04
     b88:	f9 01       	movw	r30, r18
     b8a:	22 81       	ldd	r18, Z+2	; 0x02
     b8c:	33 81       	ldd	r19, Z+3	; 0x03
     b8e:	fc 01       	movw	r30, r24
     b90:	33 83       	std	Z+3, r19	; 0x03
     b92:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b94:	89 81       	ldd	r24, Y+1	; 0x01
     b96:	9a 81       	ldd	r25, Y+2	; 0x02
     b98:	fc 01       	movw	r30, r24
     b9a:	21 81       	ldd	r18, Z+1	; 0x01
     b9c:	32 81       	ldd	r19, Z+2	; 0x02
     b9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ba0:	9c 81       	ldd	r25, Y+4	; 0x04
     ba2:	28 17       	cp	r18, r24
     ba4:	39 07       	cpc	r19, r25
     ba6:	51 f4       	brne	.+20     	; 0xbbc <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ba8:	8b 81       	ldd	r24, Y+3	; 0x03
     baa:	9c 81       	ldd	r25, Y+4	; 0x04
     bac:	fc 01       	movw	r30, r24
     bae:	24 81       	ldd	r18, Z+4	; 0x04
     bb0:	35 81       	ldd	r19, Z+5	; 0x05
     bb2:	89 81       	ldd	r24, Y+1	; 0x01
     bb4:	9a 81       	ldd	r25, Y+2	; 0x02
     bb6:	fc 01       	movw	r30, r24
     bb8:	32 83       	std	Z+2, r19	; 0x02
     bba:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     bbc:	8b 81       	ldd	r24, Y+3	; 0x03
     bbe:	9c 81       	ldd	r25, Y+4	; 0x04
     bc0:	fc 01       	movw	r30, r24
     bc2:	11 86       	std	Z+9, r1	; 0x09
     bc4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	9a 81       	ldd	r25, Y+2	; 0x02
     bca:	fc 01       	movw	r30, r24
     bcc:	80 81       	ld	r24, Z
     bce:	2f ef       	ldi	r18, 0xFF	; 255
     bd0:	28 0f       	add	r18, r24
     bd2:	89 81       	ldd	r24, Y+1	; 0x01
     bd4:	9a 81       	ldd	r25, Y+2	; 0x02
     bd6:	fc 01       	movw	r30, r24
     bd8:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	9a 81       	ldd	r25, Y+2	; 0x02
     bde:	fc 01       	movw	r30, r24
     be0:	80 81       	ld	r24, Z
}
     be2:	0f 90       	pop	r0
     be4:	0f 90       	pop	r0
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
     bee:	08 95       	ret

00000bf0 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts

#endif
}
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
     bf4:	cd b7       	in	r28, 0x3d	; 61
     bf6:	de b7       	in	r29, 0x3e	; 62
     bf8:	28 97       	sbiw	r28, 0x08	; 8
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	de bf       	out	0x3e, r29	; 62
     c00:	0f be       	out	0x3f, r0	; 63
     c02:	cd bf       	out	0x3d, r28	; 61
     c04:	9c 83       	std	Y+4, r25	; 0x04
     c06:	8b 83       	std	Y+3, r24	; 0x03
     c08:	7e 83       	std	Y+6, r23	; 0x06
     c0a:	6d 83       	std	Y+5, r22	; 0x05
     c0c:	58 87       	std	Y+8, r21	; 0x08
     c0e:	4f 83       	std	Y+7, r20	; 0x07
     c10:	8b 81       	ldd	r24, Y+3	; 0x03
     c12:	9c 81       	ldd	r25, Y+4	; 0x04
     c14:	21 e1       	ldi	r18, 0x11	; 17
     c16:	fc 01       	movw	r30, r24
     c18:	20 83       	st	Z, r18
     c1a:	8b 81       	ldd	r24, Y+3	; 0x03
     c1c:	9c 81       	ldd	r25, Y+4	; 0x04
     c1e:	01 97       	sbiw	r24, 0x01	; 1
     c20:	9c 83       	std	Y+4, r25	; 0x04
     c22:	8b 83       	std	Y+3, r24	; 0x03
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	22 e2       	ldi	r18, 0x22	; 34
     c2a:	fc 01       	movw	r30, r24
     c2c:	20 83       	st	Z, r18
     c2e:	8b 81       	ldd	r24, Y+3	; 0x03
     c30:	9c 81       	ldd	r25, Y+4	; 0x04
     c32:	01 97       	sbiw	r24, 0x01	; 1
     c34:	9c 83       	std	Y+4, r25	; 0x04
     c36:	8b 83       	std	Y+3, r24	; 0x03
     c38:	8b 81       	ldd	r24, Y+3	; 0x03
     c3a:	9c 81       	ldd	r25, Y+4	; 0x04
     c3c:	23 e3       	ldi	r18, 0x33	; 51
     c3e:	fc 01       	movw	r30, r24
     c40:	20 83       	st	Z, r18
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	9c 83       	std	Y+4, r25	; 0x04
     c4a:	8b 83       	std	Y+3, r24	; 0x03
     c4c:	8d 81       	ldd	r24, Y+5	; 0x05
     c4e:	9e 81       	ldd	r25, Y+6	; 0x06
     c50:	9a 83       	std	Y+2, r25	; 0x02
     c52:	89 83       	std	Y+1, r24	; 0x01
     c54:	29 81       	ldd	r18, Y+1	; 0x01
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	fc 01       	movw	r30, r24
     c5c:	20 83       	st	Z, r18
     c5e:	8b 81       	ldd	r24, Y+3	; 0x03
     c60:	9c 81       	ldd	r25, Y+4	; 0x04
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	9c 83       	std	Y+4, r25	; 0x04
     c66:	8b 83       	std	Y+3, r24	; 0x03
     c68:	89 81       	ldd	r24, Y+1	; 0x01
     c6a:	9a 81       	ldd	r25, Y+2	; 0x02
     c6c:	89 2f       	mov	r24, r25
     c6e:	99 27       	eor	r25, r25
     c70:	9a 83       	std	Y+2, r25	; 0x02
     c72:	89 83       	std	Y+1, r24	; 0x01
     c74:	29 81       	ldd	r18, Y+1	; 0x01
     c76:	8b 81       	ldd	r24, Y+3	; 0x03
     c78:	9c 81       	ldd	r25, Y+4	; 0x04
     c7a:	fc 01       	movw	r30, r24
     c7c:	20 83       	st	Z, r18
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	01 97       	sbiw	r24, 0x01	; 1
     c84:	9c 83       	std	Y+4, r25	; 0x04
     c86:	8b 83       	std	Y+3, r24	; 0x03
     c88:	8b 81       	ldd	r24, Y+3	; 0x03
     c8a:	9c 81       	ldd	r25, Y+4	; 0x04
     c8c:	fc 01       	movw	r30, r24
     c8e:	10 82       	st	Z, r1
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	9c 83       	std	Y+4, r25	; 0x04
     c98:	8b 83       	std	Y+3, r24	; 0x03
     c9a:	8b 81       	ldd	r24, Y+3	; 0x03
     c9c:	9c 81       	ldd	r25, Y+4	; 0x04
     c9e:	fc 01       	movw	r30, r24
     ca0:	10 82       	st	Z, r1
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	9c 83       	std	Y+4, r25	; 0x04
     caa:	8b 83       	std	Y+3, r24	; 0x03
     cac:	8b 81       	ldd	r24, Y+3	; 0x03
     cae:	9c 81       	ldd	r25, Y+4	; 0x04
     cb0:	20 e8       	ldi	r18, 0x80	; 128
     cb2:	fc 01       	movw	r30, r24
     cb4:	20 83       	st	Z, r18
     cb6:	8b 81       	ldd	r24, Y+3	; 0x03
     cb8:	9c 81       	ldd	r25, Y+4	; 0x04
     cba:	01 97       	sbiw	r24, 0x01	; 1
     cbc:	9c 83       	std	Y+4, r25	; 0x04
     cbe:	8b 83       	std	Y+3, r24	; 0x03
     cc0:	8b 81       	ldd	r24, Y+3	; 0x03
     cc2:	9c 81       	ldd	r25, Y+4	; 0x04
     cc4:	fc 01       	movw	r30, r24
     cc6:	10 82       	st	Z, r1
     cc8:	8b 81       	ldd	r24, Y+3	; 0x03
     cca:	9c 81       	ldd	r25, Y+4	; 0x04
     ccc:	01 97       	sbiw	r24, 0x01	; 1
     cce:	9c 83       	std	Y+4, r25	; 0x04
     cd0:	8b 83       	std	Y+3, r24	; 0x03
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	fc 01       	movw	r30, r24
     cd8:	10 82       	st	Z, r1
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	9c 83       	std	Y+4, r25	; 0x04
     ce2:	8b 83       	std	Y+3, r24	; 0x03
     ce4:	8b 81       	ldd	r24, Y+3	; 0x03
     ce6:	9c 81       	ldd	r25, Y+4	; 0x04
     ce8:	fc 01       	movw	r30, r24
     cea:	10 82       	st	Z, r1
     cec:	8b 81       	ldd	r24, Y+3	; 0x03
     cee:	9c 81       	ldd	r25, Y+4	; 0x04
     cf0:	01 97       	sbiw	r24, 0x01	; 1
     cf2:	9c 83       	std	Y+4, r25	; 0x04
     cf4:	8b 83       	std	Y+3, r24	; 0x03
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	22 e0       	ldi	r18, 0x02	; 2
     cfc:	fc 01       	movw	r30, r24
     cfe:	20 83       	st	Z, r18
     d00:	8b 81       	ldd	r24, Y+3	; 0x03
     d02:	9c 81       	ldd	r25, Y+4	; 0x04
     d04:	01 97       	sbiw	r24, 0x01	; 1
     d06:	9c 83       	std	Y+4, r25	; 0x04
     d08:	8b 83       	std	Y+3, r24	; 0x03
     d0a:	8b 81       	ldd	r24, Y+3	; 0x03
     d0c:	9c 81       	ldd	r25, Y+4	; 0x04
     d0e:	23 e0       	ldi	r18, 0x03	; 3
     d10:	fc 01       	movw	r30, r24
     d12:	20 83       	st	Z, r18
     d14:	8b 81       	ldd	r24, Y+3	; 0x03
     d16:	9c 81       	ldd	r25, Y+4	; 0x04
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	9c 83       	std	Y+4, r25	; 0x04
     d1c:	8b 83       	std	Y+3, r24	; 0x03
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	24 e0       	ldi	r18, 0x04	; 4
     d24:	fc 01       	movw	r30, r24
     d26:	20 83       	st	Z, r18
     d28:	8b 81       	ldd	r24, Y+3	; 0x03
     d2a:	9c 81       	ldd	r25, Y+4	; 0x04
     d2c:	01 97       	sbiw	r24, 0x01	; 1
     d2e:	9c 83       	std	Y+4, r25	; 0x04
     d30:	8b 83       	std	Y+3, r24	; 0x03
     d32:	8b 81       	ldd	r24, Y+3	; 0x03
     d34:	9c 81       	ldd	r25, Y+4	; 0x04
     d36:	25 e0       	ldi	r18, 0x05	; 5
     d38:	fc 01       	movw	r30, r24
     d3a:	20 83       	st	Z, r18
     d3c:	8b 81       	ldd	r24, Y+3	; 0x03
     d3e:	9c 81       	ldd	r25, Y+4	; 0x04
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	9c 83       	std	Y+4, r25	; 0x04
     d44:	8b 83       	std	Y+3, r24	; 0x03
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	9c 81       	ldd	r25, Y+4	; 0x04
     d4a:	26 e0       	ldi	r18, 0x06	; 6
     d4c:	fc 01       	movw	r30, r24
     d4e:	20 83       	st	Z, r18
     d50:	8b 81       	ldd	r24, Y+3	; 0x03
     d52:	9c 81       	ldd	r25, Y+4	; 0x04
     d54:	01 97       	sbiw	r24, 0x01	; 1
     d56:	9c 83       	std	Y+4, r25	; 0x04
     d58:	8b 83       	std	Y+3, r24	; 0x03
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	27 e0       	ldi	r18, 0x07	; 7
     d60:	fc 01       	movw	r30, r24
     d62:	20 83       	st	Z, r18
     d64:	8b 81       	ldd	r24, Y+3	; 0x03
     d66:	9c 81       	ldd	r25, Y+4	; 0x04
     d68:	01 97       	sbiw	r24, 0x01	; 1
     d6a:	9c 83       	std	Y+4, r25	; 0x04
     d6c:	8b 83       	std	Y+3, r24	; 0x03
     d6e:	8b 81       	ldd	r24, Y+3	; 0x03
     d70:	9c 81       	ldd	r25, Y+4	; 0x04
     d72:	28 e0       	ldi	r18, 0x08	; 8
     d74:	fc 01       	movw	r30, r24
     d76:	20 83       	st	Z, r18
     d78:	8b 81       	ldd	r24, Y+3	; 0x03
     d7a:	9c 81       	ldd	r25, Y+4	; 0x04
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	9c 83       	std	Y+4, r25	; 0x04
     d80:	8b 83       	std	Y+3, r24	; 0x03
     d82:	8b 81       	ldd	r24, Y+3	; 0x03
     d84:	9c 81       	ldd	r25, Y+4	; 0x04
     d86:	29 e0       	ldi	r18, 0x09	; 9
     d88:	fc 01       	movw	r30, r24
     d8a:	20 83       	st	Z, r18
     d8c:	8b 81       	ldd	r24, Y+3	; 0x03
     d8e:	9c 81       	ldd	r25, Y+4	; 0x04
     d90:	01 97       	sbiw	r24, 0x01	; 1
     d92:	9c 83       	std	Y+4, r25	; 0x04
     d94:	8b 83       	std	Y+3, r24	; 0x03
     d96:	8b 81       	ldd	r24, Y+3	; 0x03
     d98:	9c 81       	ldd	r25, Y+4	; 0x04
     d9a:	20 e1       	ldi	r18, 0x10	; 16
     d9c:	fc 01       	movw	r30, r24
     d9e:	20 83       	st	Z, r18
     da0:	8b 81       	ldd	r24, Y+3	; 0x03
     da2:	9c 81       	ldd	r25, Y+4	; 0x04
     da4:	01 97       	sbiw	r24, 0x01	; 1
     da6:	9c 83       	std	Y+4, r25	; 0x04
     da8:	8b 83       	std	Y+3, r24	; 0x03
     daa:	8b 81       	ldd	r24, Y+3	; 0x03
     dac:	9c 81       	ldd	r25, Y+4	; 0x04
     dae:	21 e1       	ldi	r18, 0x11	; 17
     db0:	fc 01       	movw	r30, r24
     db2:	20 83       	st	Z, r18
     db4:	8b 81       	ldd	r24, Y+3	; 0x03
     db6:	9c 81       	ldd	r25, Y+4	; 0x04
     db8:	01 97       	sbiw	r24, 0x01	; 1
     dba:	9c 83       	std	Y+4, r25	; 0x04
     dbc:	8b 83       	std	Y+3, r24	; 0x03
     dbe:	8b 81       	ldd	r24, Y+3	; 0x03
     dc0:	9c 81       	ldd	r25, Y+4	; 0x04
     dc2:	22 e1       	ldi	r18, 0x12	; 18
     dc4:	fc 01       	movw	r30, r24
     dc6:	20 83       	st	Z, r18
     dc8:	8b 81       	ldd	r24, Y+3	; 0x03
     dca:	9c 81       	ldd	r25, Y+4	; 0x04
     dcc:	01 97       	sbiw	r24, 0x01	; 1
     dce:	9c 83       	std	Y+4, r25	; 0x04
     dd0:	8b 83       	std	Y+3, r24	; 0x03
     dd2:	8b 81       	ldd	r24, Y+3	; 0x03
     dd4:	9c 81       	ldd	r25, Y+4	; 0x04
     dd6:	23 e1       	ldi	r18, 0x13	; 19
     dd8:	fc 01       	movw	r30, r24
     dda:	20 83       	st	Z, r18
     ddc:	8b 81       	ldd	r24, Y+3	; 0x03
     dde:	9c 81       	ldd	r25, Y+4	; 0x04
     de0:	01 97       	sbiw	r24, 0x01	; 1
     de2:	9c 83       	std	Y+4, r25	; 0x04
     de4:	8b 83       	std	Y+3, r24	; 0x03
     de6:	8b 81       	ldd	r24, Y+3	; 0x03
     de8:	9c 81       	ldd	r25, Y+4	; 0x04
     dea:	24 e1       	ldi	r18, 0x14	; 20
     dec:	fc 01       	movw	r30, r24
     dee:	20 83       	st	Z, r18
     df0:	8b 81       	ldd	r24, Y+3	; 0x03
     df2:	9c 81       	ldd	r25, Y+4	; 0x04
     df4:	01 97       	sbiw	r24, 0x01	; 1
     df6:	9c 83       	std	Y+4, r25	; 0x04
     df8:	8b 83       	std	Y+3, r24	; 0x03
     dfa:	8b 81       	ldd	r24, Y+3	; 0x03
     dfc:	9c 81       	ldd	r25, Y+4	; 0x04
     dfe:	25 e1       	ldi	r18, 0x15	; 21
     e00:	fc 01       	movw	r30, r24
     e02:	20 83       	st	Z, r18
     e04:	8b 81       	ldd	r24, Y+3	; 0x03
     e06:	9c 81       	ldd	r25, Y+4	; 0x04
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	9c 83       	std	Y+4, r25	; 0x04
     e0c:	8b 83       	std	Y+3, r24	; 0x03
     e0e:	8b 81       	ldd	r24, Y+3	; 0x03
     e10:	9c 81       	ldd	r25, Y+4	; 0x04
     e12:	26 e1       	ldi	r18, 0x16	; 22
     e14:	fc 01       	movw	r30, r24
     e16:	20 83       	st	Z, r18
     e18:	8b 81       	ldd	r24, Y+3	; 0x03
     e1a:	9c 81       	ldd	r25, Y+4	; 0x04
     e1c:	01 97       	sbiw	r24, 0x01	; 1
     e1e:	9c 83       	std	Y+4, r25	; 0x04
     e20:	8b 83       	std	Y+3, r24	; 0x03
     e22:	8b 81       	ldd	r24, Y+3	; 0x03
     e24:	9c 81       	ldd	r25, Y+4	; 0x04
     e26:	27 e1       	ldi	r18, 0x17	; 23
     e28:	fc 01       	movw	r30, r24
     e2a:	20 83       	st	Z, r18
     e2c:	8b 81       	ldd	r24, Y+3	; 0x03
     e2e:	9c 81       	ldd	r25, Y+4	; 0x04
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	9c 83       	std	Y+4, r25	; 0x04
     e34:	8b 83       	std	Y+3, r24	; 0x03
     e36:	8b 81       	ldd	r24, Y+3	; 0x03
     e38:	9c 81       	ldd	r25, Y+4	; 0x04
     e3a:	28 e1       	ldi	r18, 0x18	; 24
     e3c:	fc 01       	movw	r30, r24
     e3e:	20 83       	st	Z, r18
     e40:	8b 81       	ldd	r24, Y+3	; 0x03
     e42:	9c 81       	ldd	r25, Y+4	; 0x04
     e44:	01 97       	sbiw	r24, 0x01	; 1
     e46:	9c 83       	std	Y+4, r25	; 0x04
     e48:	8b 83       	std	Y+3, r24	; 0x03
     e4a:	8b 81       	ldd	r24, Y+3	; 0x03
     e4c:	9c 81       	ldd	r25, Y+4	; 0x04
     e4e:	29 e1       	ldi	r18, 0x19	; 25
     e50:	fc 01       	movw	r30, r24
     e52:	20 83       	st	Z, r18
     e54:	8b 81       	ldd	r24, Y+3	; 0x03
     e56:	9c 81       	ldd	r25, Y+4	; 0x04
     e58:	01 97       	sbiw	r24, 0x01	; 1
     e5a:	9c 83       	std	Y+4, r25	; 0x04
     e5c:	8b 83       	std	Y+3, r24	; 0x03
     e5e:	8b 81       	ldd	r24, Y+3	; 0x03
     e60:	9c 81       	ldd	r25, Y+4	; 0x04
     e62:	20 e2       	ldi	r18, 0x20	; 32
     e64:	fc 01       	movw	r30, r24
     e66:	20 83       	st	Z, r18
     e68:	8b 81       	ldd	r24, Y+3	; 0x03
     e6a:	9c 81       	ldd	r25, Y+4	; 0x04
     e6c:	01 97       	sbiw	r24, 0x01	; 1
     e6e:	9c 83       	std	Y+4, r25	; 0x04
     e70:	8b 83       	std	Y+3, r24	; 0x03
     e72:	8b 81       	ldd	r24, Y+3	; 0x03
     e74:	9c 81       	ldd	r25, Y+4	; 0x04
     e76:	21 e2       	ldi	r18, 0x21	; 33
     e78:	fc 01       	movw	r30, r24
     e7a:	20 83       	st	Z, r18
     e7c:	8b 81       	ldd	r24, Y+3	; 0x03
     e7e:	9c 81       	ldd	r25, Y+4	; 0x04
     e80:	01 97       	sbiw	r24, 0x01	; 1
     e82:	9c 83       	std	Y+4, r25	; 0x04
     e84:	8b 83       	std	Y+3, r24	; 0x03
     e86:	8b 81       	ldd	r24, Y+3	; 0x03
     e88:	9c 81       	ldd	r25, Y+4	; 0x04
     e8a:	22 e2       	ldi	r18, 0x22	; 34
     e8c:	fc 01       	movw	r30, r24
     e8e:	20 83       	st	Z, r18
     e90:	8b 81       	ldd	r24, Y+3	; 0x03
     e92:	9c 81       	ldd	r25, Y+4	; 0x04
     e94:	01 97       	sbiw	r24, 0x01	; 1
     e96:	9c 83       	std	Y+4, r25	; 0x04
     e98:	8b 83       	std	Y+3, r24	; 0x03
     e9a:	8b 81       	ldd	r24, Y+3	; 0x03
     e9c:	9c 81       	ldd	r25, Y+4	; 0x04
     e9e:	23 e2       	ldi	r18, 0x23	; 35
     ea0:	fc 01       	movw	r30, r24
     ea2:	20 83       	st	Z, r18
     ea4:	8b 81       	ldd	r24, Y+3	; 0x03
     ea6:	9c 81       	ldd	r25, Y+4	; 0x04
     ea8:	01 97       	sbiw	r24, 0x01	; 1
     eaa:	9c 83       	std	Y+4, r25	; 0x04
     eac:	8b 83       	std	Y+3, r24	; 0x03
     eae:	8f 81       	ldd	r24, Y+7	; 0x07
     eb0:	98 85       	ldd	r25, Y+8	; 0x08
     eb2:	9a 83       	std	Y+2, r25	; 0x02
     eb4:	89 83       	std	Y+1, r24	; 0x01
     eb6:	29 81       	ldd	r18, Y+1	; 0x01
     eb8:	8b 81       	ldd	r24, Y+3	; 0x03
     eba:	9c 81       	ldd	r25, Y+4	; 0x04
     ebc:	fc 01       	movw	r30, r24
     ebe:	20 83       	st	Z, r18
     ec0:	8b 81       	ldd	r24, Y+3	; 0x03
     ec2:	9c 81       	ldd	r25, Y+4	; 0x04
     ec4:	01 97       	sbiw	r24, 0x01	; 1
     ec6:	9c 83       	std	Y+4, r25	; 0x04
     ec8:	8b 83       	std	Y+3, r24	; 0x03
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	9a 81       	ldd	r25, Y+2	; 0x02
     ece:	89 2f       	mov	r24, r25
     ed0:	99 27       	eor	r25, r25
     ed2:	9a 83       	std	Y+2, r25	; 0x02
     ed4:	89 83       	std	Y+1, r24	; 0x01
     ed6:	29 81       	ldd	r18, Y+1	; 0x01
     ed8:	8b 81       	ldd	r24, Y+3	; 0x03
     eda:	9c 81       	ldd	r25, Y+4	; 0x04
     edc:	fc 01       	movw	r30, r24
     ede:	20 83       	st	Z, r18
     ee0:	8b 81       	ldd	r24, Y+3	; 0x03
     ee2:	9c 81       	ldd	r25, Y+4	; 0x04
     ee4:	01 97       	sbiw	r24, 0x01	; 1
     ee6:	9c 83       	std	Y+4, r25	; 0x04
     ee8:	8b 83       	std	Y+3, r24	; 0x03
     eea:	8b 81       	ldd	r24, Y+3	; 0x03
     eec:	9c 81       	ldd	r25, Y+4	; 0x04
     eee:	26 e2       	ldi	r18, 0x26	; 38
     ef0:	fc 01       	movw	r30, r24
     ef2:	20 83       	st	Z, r18
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	9c 81       	ldd	r25, Y+4	; 0x04
     ef8:	01 97       	sbiw	r24, 0x01	; 1
     efa:	9c 83       	std	Y+4, r25	; 0x04
     efc:	8b 83       	std	Y+3, r24	; 0x03
     efe:	8b 81       	ldd	r24, Y+3	; 0x03
     f00:	9c 81       	ldd	r25, Y+4	; 0x04
     f02:	27 e2       	ldi	r18, 0x27	; 39
     f04:	fc 01       	movw	r30, r24
     f06:	20 83       	st	Z, r18
     f08:	8b 81       	ldd	r24, Y+3	; 0x03
     f0a:	9c 81       	ldd	r25, Y+4	; 0x04
     f0c:	01 97       	sbiw	r24, 0x01	; 1
     f0e:	9c 83       	std	Y+4, r25	; 0x04
     f10:	8b 83       	std	Y+3, r24	; 0x03
     f12:	8b 81       	ldd	r24, Y+3	; 0x03
     f14:	9c 81       	ldd	r25, Y+4	; 0x04
     f16:	28 e2       	ldi	r18, 0x28	; 40
     f18:	fc 01       	movw	r30, r24
     f1a:	20 83       	st	Z, r18
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	9c 81       	ldd	r25, Y+4	; 0x04
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	9c 83       	std	Y+4, r25	; 0x04
     f24:	8b 83       	std	Y+3, r24	; 0x03
     f26:	8b 81       	ldd	r24, Y+3	; 0x03
     f28:	9c 81       	ldd	r25, Y+4	; 0x04
     f2a:	29 e2       	ldi	r18, 0x29	; 41
     f2c:	fc 01       	movw	r30, r24
     f2e:	20 83       	st	Z, r18
     f30:	8b 81       	ldd	r24, Y+3	; 0x03
     f32:	9c 81       	ldd	r25, Y+4	; 0x04
     f34:	01 97       	sbiw	r24, 0x01	; 1
     f36:	9c 83       	std	Y+4, r25	; 0x04
     f38:	8b 83       	std	Y+3, r24	; 0x03
     f3a:	8b 81       	ldd	r24, Y+3	; 0x03
     f3c:	9c 81       	ldd	r25, Y+4	; 0x04
     f3e:	20 e3       	ldi	r18, 0x30	; 48
     f40:	fc 01       	movw	r30, r24
     f42:	20 83       	st	Z, r18
     f44:	8b 81       	ldd	r24, Y+3	; 0x03
     f46:	9c 81       	ldd	r25, Y+4	; 0x04
     f48:	01 97       	sbiw	r24, 0x01	; 1
     f4a:	9c 83       	std	Y+4, r25	; 0x04
     f4c:	8b 83       	std	Y+3, r24	; 0x03
     f4e:	8b 81       	ldd	r24, Y+3	; 0x03
     f50:	9c 81       	ldd	r25, Y+4	; 0x04
     f52:	21 e3       	ldi	r18, 0x31	; 49
     f54:	fc 01       	movw	r30, r24
     f56:	20 83       	st	Z, r18
     f58:	8b 81       	ldd	r24, Y+3	; 0x03
     f5a:	9c 81       	ldd	r25, Y+4	; 0x04
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	9c 83       	std	Y+4, r25	; 0x04
     f60:	8b 83       	std	Y+3, r24	; 0x03
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	28 96       	adiw	r28, 0x08	; 8
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	de bf       	out	0x3e, r29	; 62
     f6e:	0f be       	out	0x3f, r0	; 63
     f70:	cd bf       	out	0x3d, r28	; 61
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	08 95       	ret

00000f78 <xPortStartScheduler>:
     f78:	cf 93       	push	r28
     f7a:	df 93       	push	r29
     f7c:	cd b7       	in	r28, 0x3d	; 61
     f7e:	de b7       	in	r29, 0x3e	; 62
     f80:	10 d1       	rcall	.+544    	; 0x11a2 <prvSetupTimerInterrupt>
     f82:	a0 91 2a 0c 	lds	r26, 0x0C2A	; 0x800c2a <pxCurrentTCB>
     f86:	b0 91 2b 0c 	lds	r27, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
     f8a:	cd 91       	ld	r28, X+
     f8c:	cd bf       	out	0x3d, r28	; 61
     f8e:	dd 91       	ld	r29, X+
     f90:	de bf       	out	0x3e, r29	; 62
     f92:	ff 91       	pop	r31
     f94:	ef 91       	pop	r30
     f96:	df 91       	pop	r29
     f98:	cf 91       	pop	r28
     f9a:	bf 91       	pop	r27
     f9c:	af 91       	pop	r26
     f9e:	9f 91       	pop	r25
     fa0:	8f 91       	pop	r24
     fa2:	7f 91       	pop	r23
     fa4:	6f 91       	pop	r22
     fa6:	5f 91       	pop	r21
     fa8:	4f 91       	pop	r20
     faa:	3f 91       	pop	r19
     fac:	2f 91       	pop	r18
     fae:	1f 91       	pop	r17
     fb0:	0f 91       	pop	r16
     fb2:	ff 90       	pop	r15
     fb4:	ef 90       	pop	r14
     fb6:	df 90       	pop	r13
     fb8:	cf 90       	pop	r12
     fba:	bf 90       	pop	r11
     fbc:	af 90       	pop	r10
     fbe:	9f 90       	pop	r9
     fc0:	8f 90       	pop	r8
     fc2:	7f 90       	pop	r7
     fc4:	6f 90       	pop	r6
     fc6:	5f 90       	pop	r5
     fc8:	4f 90       	pop	r4
     fca:	3f 90       	pop	r3
     fcc:	2f 90       	pop	r2
     fce:	1f 90       	pop	r1
     fd0:	0f 90       	pop	r0
     fd2:	0c be       	out	0x3c, r0	; 60
     fd4:	0f 90       	pop	r0
     fd6:	0b be       	out	0x3b, r0	; 59
     fd8:	0f 90       	pop	r0
     fda:	0f be       	out	0x3f, r0	; 63
     fdc:	0f 90       	pop	r0
     fde:	08 95       	ret
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	08 95       	ret

00000fe8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fe8:	0f 92       	push	r0
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	f8 94       	cli
     fee:	0f 92       	push	r0
     ff0:	0b b6       	in	r0, 0x3b	; 59
     ff2:	0f 92       	push	r0
     ff4:	0c b6       	in	r0, 0x3c	; 60
     ff6:	0f 92       	push	r0
     ff8:	1f 92       	push	r1
     ffa:	11 24       	eor	r1, r1
     ffc:	2f 92       	push	r2
     ffe:	3f 92       	push	r3
    1000:	4f 92       	push	r4
    1002:	5f 92       	push	r5
    1004:	6f 92       	push	r6
    1006:	7f 92       	push	r7
    1008:	8f 92       	push	r8
    100a:	9f 92       	push	r9
    100c:	af 92       	push	r10
    100e:	bf 92       	push	r11
    1010:	cf 92       	push	r12
    1012:	df 92       	push	r13
    1014:	ef 92       	push	r14
    1016:	ff 92       	push	r15
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	2f 93       	push	r18
    101e:	3f 93       	push	r19
    1020:	4f 93       	push	r20
    1022:	5f 93       	push	r21
    1024:	6f 93       	push	r22
    1026:	7f 93       	push	r23
    1028:	8f 93       	push	r24
    102a:	9f 93       	push	r25
    102c:	af 93       	push	r26
    102e:	bf 93       	push	r27
    1030:	cf 93       	push	r28
    1032:	df 93       	push	r29
    1034:	ef 93       	push	r30
    1036:	ff 93       	push	r31
    1038:	a0 91 2a 0c 	lds	r26, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    103c:	b0 91 2b 0c 	lds	r27, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1040:	0d b6       	in	r0, 0x3d	; 61
    1042:	0d 92       	st	X+, r0
    1044:	0e b6       	in	r0, 0x3e	; 62
    1046:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1048:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    104c:	a0 91 2a 0c 	lds	r26, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1050:	b0 91 2b 0c 	lds	r27, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1054:	cd 91       	ld	r28, X+
    1056:	cd bf       	out	0x3d, r28	; 61
    1058:	dd 91       	ld	r29, X+
    105a:	de bf       	out	0x3e, r29	; 62
    105c:	ff 91       	pop	r31
    105e:	ef 91       	pop	r30
    1060:	df 91       	pop	r29
    1062:	cf 91       	pop	r28
    1064:	bf 91       	pop	r27
    1066:	af 91       	pop	r26
    1068:	9f 91       	pop	r25
    106a:	8f 91       	pop	r24
    106c:	7f 91       	pop	r23
    106e:	6f 91       	pop	r22
    1070:	5f 91       	pop	r21
    1072:	4f 91       	pop	r20
    1074:	3f 91       	pop	r19
    1076:	2f 91       	pop	r18
    1078:	1f 91       	pop	r17
    107a:	0f 91       	pop	r16
    107c:	ff 90       	pop	r15
    107e:	ef 90       	pop	r14
    1080:	df 90       	pop	r13
    1082:	cf 90       	pop	r12
    1084:	bf 90       	pop	r11
    1086:	af 90       	pop	r10
    1088:	9f 90       	pop	r9
    108a:	8f 90       	pop	r8
    108c:	7f 90       	pop	r7
    108e:	6f 90       	pop	r6
    1090:	5f 90       	pop	r5
    1092:	4f 90       	pop	r4
    1094:	3f 90       	pop	r3
    1096:	2f 90       	pop	r2
    1098:	1f 90       	pop	r1
    109a:	0f 90       	pop	r0
    109c:	0c be       	out	0x3c, r0	; 60
    109e:	0f 90       	pop	r0
    10a0:	0b be       	out	0x3b, r0	; 59
    10a2:	0f 90       	pop	r0
    10a4:	0f be       	out	0x3f, r0	; 63
    10a6:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    10a8:	08 95       	ret

000010aa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    10aa:	0f 92       	push	r0
    10ac:	0f b6       	in	r0, 0x3f	; 63
    10ae:	f8 94       	cli
    10b0:	0f 92       	push	r0
    10b2:	0b b6       	in	r0, 0x3b	; 59
    10b4:	0f 92       	push	r0
    10b6:	0c b6       	in	r0, 0x3c	; 60
    10b8:	0f 92       	push	r0
    10ba:	1f 92       	push	r1
    10bc:	11 24       	eor	r1, r1
    10be:	2f 92       	push	r2
    10c0:	3f 92       	push	r3
    10c2:	4f 92       	push	r4
    10c4:	5f 92       	push	r5
    10c6:	6f 92       	push	r6
    10c8:	7f 92       	push	r7
    10ca:	8f 92       	push	r8
    10cc:	9f 92       	push	r9
    10ce:	af 92       	push	r10
    10d0:	bf 92       	push	r11
    10d2:	cf 92       	push	r12
    10d4:	df 92       	push	r13
    10d6:	ef 92       	push	r14
    10d8:	ff 92       	push	r15
    10da:	0f 93       	push	r16
    10dc:	1f 93       	push	r17
    10de:	2f 93       	push	r18
    10e0:	3f 93       	push	r19
    10e2:	4f 93       	push	r20
    10e4:	5f 93       	push	r21
    10e6:	6f 93       	push	r22
    10e8:	7f 93       	push	r23
    10ea:	8f 93       	push	r24
    10ec:	9f 93       	push	r25
    10ee:	af 93       	push	r26
    10f0:	bf 93       	push	r27
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
    10f6:	ef 93       	push	r30
    10f8:	ff 93       	push	r31
    10fa:	a0 91 2a 0c 	lds	r26, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    10fe:	b0 91 2b 0c 	lds	r27, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1102:	0d b6       	in	r0, 0x3d	; 61
    1104:	0d 92       	st	X+, r0
    1106:	0e b6       	in	r0, 0x3e	; 62
    1108:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    110a:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <ticksRemainingInSec>
    110e:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <ticksRemainingInSec+0x1>
    1112:	01 97       	sbiw	r24, 0x01	; 1
    1114:	90 93 61 02 	sts	0x0261, r25	; 0x800261 <ticksRemainingInSec+0x1>
    1118:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <ticksRemainingInSec>
    111c:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <ticksRemainingInSec>
    1120:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <ticksRemainingInSec+0x1>
    1124:	89 2b       	or	r24, r25
    1126:	41 f4       	brne	.+16     	; 0x1138 <vPortYieldFromTick+0x8e>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    1128:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <portTickRateHz>
    112c:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <portTickRateHz+0x1>
    1130:	90 93 61 02 	sts	0x0261, r25	; 0x800261 <ticksRemainingInSec+0x1>
    1134:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <ticksRemainingInSec>
	}

	if( xTaskIncrementTick() != pdFALSE )
    1138:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskIncrementTick>
    113c:	88 23       	and	r24, r24
    113e:	11 f0       	breq	.+4      	; 0x1144 <vPortYieldFromTick+0x9a>
	{
		vTaskSwitchContext();
    1140:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    1144:	a0 91 2a 0c 	lds	r26, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1148:	b0 91 2b 0c 	lds	r27, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    114c:	cd 91       	ld	r28, X+
    114e:	cd bf       	out	0x3d, r28	; 61
    1150:	dd 91       	ld	r29, X+
    1152:	de bf       	out	0x3e, r29	; 62
    1154:	ff 91       	pop	r31
    1156:	ef 91       	pop	r30
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	bf 91       	pop	r27
    115e:	af 91       	pop	r26
    1160:	9f 91       	pop	r25
    1162:	8f 91       	pop	r24
    1164:	7f 91       	pop	r23
    1166:	6f 91       	pop	r22
    1168:	5f 91       	pop	r21
    116a:	4f 91       	pop	r20
    116c:	3f 91       	pop	r19
    116e:	2f 91       	pop	r18
    1170:	1f 91       	pop	r17
    1172:	0f 91       	pop	r16
    1174:	ff 90       	pop	r15
    1176:	ef 90       	pop	r14
    1178:	df 90       	pop	r13
    117a:	cf 90       	pop	r12
    117c:	bf 90       	pop	r11
    117e:	af 90       	pop	r10
    1180:	9f 90       	pop	r9
    1182:	8f 90       	pop	r8
    1184:	7f 90       	pop	r7
    1186:	6f 90       	pop	r6
    1188:	5f 90       	pop	r5
    118a:	4f 90       	pop	r4
    118c:	3f 90       	pop	r3
    118e:	2f 90       	pop	r2
    1190:	1f 90       	pop	r1
    1192:	0f 90       	pop	r0
    1194:	0c be       	out	0x3c, r0	; 60
    1196:	0f 90       	pop	r0
    1198:	0b be       	out	0x3b, r0	; 59
    119a:	0f 90       	pop	r0
    119c:	0f be       	out	0x3f, r0	; 63
    119e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    11a0:	08 95       	ret

000011a2 <prvSetupTimerInterrupt>:
#ifndef portUSE_TIMER2
/*
 * Setup timer 0 or 1 or 3 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	cd b7       	in	r28, 0x3d	; 61
    11a8:	de b7       	in	r29, 0x3e	; 62
    11aa:	2a 97       	sbiw	r28, 0x0a	; 10
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	de bf       	out	0x3e, r29	; 62
    11b2:	0f be       	out	0x3f, r0	; 63
    11b4:	cd bf       	out	0x3d, r28	; 61
    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock.*/

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    11b6:	80 e1       	ldi	r24, 0x10	; 16
    11b8:	97 e2       	ldi	r25, 0x27	; 39
    11ba:	a0 e0       	ldi	r26, 0x00	; 0
    11bc:	b0 e0       	ldi	r27, 0x00	; 0
    11be:	89 83       	std	Y+1, r24	; 0x01
    11c0:	9a 83       	std	Y+2, r25	; 0x02
    11c2:	ab 83       	std	Y+3, r26	; 0x03
    11c4:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    11c6:	89 81       	ldd	r24, Y+1	; 0x01
    11c8:	9a 81       	ldd	r25, Y+2	; 0x02
    11ca:	ab 81       	ldd	r26, Y+3	; 0x03
    11cc:	bc 81       	ldd	r27, Y+4	; 0x04
    11ce:	68 94       	set
    11d0:	15 f8       	bld	r1, 5
    11d2:	b6 95       	lsr	r27
    11d4:	a7 95       	ror	r26
    11d6:	97 95       	ror	r25
    11d8:	87 95       	ror	r24
    11da:	16 94       	lsr	r1
    11dc:	d1 f7       	brne	.-12     	; 0x11d2 <prvSetupTimerInterrupt+0x30>
    11de:	89 83       	std	Y+1, r24	; 0x01
    11e0:	9a 83       	std	Y+2, r25	; 0x02
    11e2:	ab 83       	std	Y+3, r26	; 0x03
    11e4:	bc 83       	std	Y+4, r27	; 0x04

 	/* actual port tick rate in Hz, calculated */
	portTickRateHz = (TickType_t) ((uint32_t) configCPU_CLOCK_HZ / ( portCLOCK_PRESCALER * ulCompareMatch ));
    11e6:	89 81       	ldd	r24, Y+1	; 0x01
    11e8:	9a 81       	ldd	r25, Y+2	; 0x02
    11ea:	ab 81       	ldd	r26, Y+3	; 0x03
    11ec:	bc 81       	ldd	r27, Y+4	; 0x04
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	aa 1f       	adc	r26, r26
    11f4:	bb 1f       	adc	r27, r27
    11f6:	88 0f       	add	r24, r24
    11f8:	99 1f       	adc	r25, r25
    11fa:	aa 1f       	adc	r26, r26
    11fc:	bb 1f       	adc	r27, r27
    11fe:	88 0f       	add	r24, r24
    1200:	99 1f       	adc	r25, r25
    1202:	aa 1f       	adc	r26, r26
    1204:	bb 1f       	adc	r27, r27
    1206:	88 0f       	add	r24, r24
    1208:	99 1f       	adc	r25, r25
    120a:	aa 1f       	adc	r26, r26
    120c:	bb 1f       	adc	r27, r27
    120e:	88 0f       	add	r24, r24
    1210:	99 1f       	adc	r25, r25
    1212:	aa 1f       	adc	r26, r26
    1214:	bb 1f       	adc	r27, r27
    1216:	88 0f       	add	r24, r24
    1218:	99 1f       	adc	r25, r25
    121a:	aa 1f       	adc	r26, r26
    121c:	bb 1f       	adc	r27, r27
    121e:	9c 01       	movw	r18, r24
    1220:	ad 01       	movw	r20, r26
    1222:	80 e8       	ldi	r24, 0x80	; 128
    1224:	96 e9       	ldi	r25, 0x96	; 150
    1226:	a8 e9       	ldi	r26, 0x98	; 152
    1228:	b0 e0       	ldi	r27, 0x00	; 0
    122a:	bc 01       	movw	r22, r24
    122c:	cd 01       	movw	r24, r26
    122e:	0e 94 b6 18 	call	0x316c	; 0x316c <__udivmodsi4>
    1232:	da 01       	movw	r26, r20
    1234:	c9 01       	movw	r24, r18
    1236:	90 93 5f 02 	sts	0x025F, r25	; 0x80025f <portTickRateHz+0x1>
    123a:	80 93 5e 02 	sts	0x025E, r24	; 0x80025e <portTickRateHz>
	/* initialise first second of ticks */
	ticksRemainingInSec = portTickRateHz;
    123e:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <portTickRateHz>
    1242:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <portTickRateHz+0x1>
    1246:	90 93 61 02 	sts	0x0261, r25	; 0x800261 <ticksRemainingInSec+0x1>
    124a:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <ticksRemainingInSec>

    /* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    124e:	89 81       	ldd	r24, Y+1	; 0x01
    1250:	9a 81       	ldd	r25, Y+2	; 0x02
    1252:	ab 81       	ldd	r26, Y+3	; 0x03
    1254:	bc 81       	ldd	r27, Y+4	; 0x04
    1256:	01 97       	sbiw	r24, 0x01	; 1
    1258:	a1 09       	sbc	r26, r1
    125a:	b1 09       	sbc	r27, r1
    125c:	89 83       	std	Y+1, r24	; 0x01
    125e:	9a 83       	std	Y+2, r25	; 0x02
    1260:	ab 83       	std	Y+3, r26	; 0x03
    1262:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1264:	89 81       	ldd	r24, Y+1	; 0x01
    1266:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AH = ucHighByte;
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH
    ulCompareMatch >>= 8;
    1268:	89 81       	ldd	r24, Y+1	; 0x01
    126a:	9a 81       	ldd	r25, Y+2	; 0x02
    126c:	ab 81       	ldd	r26, Y+3	; 0x03
    126e:	bc 81       	ldd	r27, Y+4	; 0x04
    1270:	89 2f       	mov	r24, r25
    1272:	9a 2f       	mov	r25, r26
    1274:	ab 2f       	mov	r26, r27
    1276:	bb 27       	eor	r27, r27
    1278:	89 83       	std	Y+1, r24	; 0x01
    127a:	9a 83       	std	Y+2, r25	; 0x02
    127c:	ab 83       	std	Y+3, r26	; 0x03
    127e:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t) 0xff );
    1280:	89 81       	ldd	r24, Y+1	; 0x01
    1282:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    1284:	89 e9       	ldi	r24, 0x99	; 153
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	2e 81       	ldd	r18, Y+6	; 0x06
    128a:	fc 01       	movw	r30, r24
    128c:	20 83       	st	Z, r18
#endif

    portOCRL = ucLowByte;
    128e:	88 e9       	ldi	r24, 0x98	; 152
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	2d 81       	ldd	r18, Y+5	; 0x05
    1294:	fc 01       	movw	r30, r24
    1296:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1298:	8b e0       	ldi	r24, 0x0B	; 11
    129a:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    129c:	81 e9       	ldi	r24, 0x91	; 145
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	2d 81       	ldd	r18, Y+5	; 0x05
    12a2:	fc 01       	movw	r30, r24
    12a4:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    12a6:	81 e7       	ldi	r24, 0x71	; 113
    12a8:	90 e0       	ldi	r25, 0x00	; 0
    12aa:	fc 01       	movw	r30, r24
    12ac:	80 81       	ld	r24, Z
    12ae:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    12b0:	8d 81       	ldd	r24, Y+5	; 0x05
    12b2:	82 60       	ori	r24, 0x02	; 2
    12b4:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    12b6:	81 e7       	ldi	r24, 0x71	; 113
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	2d 81       	ldd	r18, Y+5	; 0x05
    12bc:	fc 01       	movw	r30, r24
    12be:	20 83       	st	Z, r18

}
    12c0:	2a 96       	adiw	r28, 0x0a	; 10
    12c2:	0f b6       	in	r0, 0x3f	; 63
    12c4:	f8 94       	cli
    12c6:	de bf       	out	0x3e, r29	; 62
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	cd bf       	out	0x3d, r28	; 61
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	08 95       	ret

000012d2 <__vector_32>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    12d2:	eb de       	rcall	.-554    	; 0x10aa <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    12d4:	18 95       	reti

000012d6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12d6:	cf 93       	push	r28
    12d8:	df 93       	push	r29
    12da:	00 d0       	rcall	.+0      	; 0x12dc <pvPortMalloc+0x6>
    12dc:	1f 92       	push	r1
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    12e2:	9c 83       	std	Y+4, r25	; 0x04
    12e4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    12e6:	1a 82       	std	Y+2, r1	; 0x02
    12e8:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    12ea:	09 d7       	rcall	.+3602   	; 0x20fe <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    12ec:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <pucAlignedHeap.1892>
    12f0:	90 91 29 0c 	lds	r25, 0x0C29	; 0x800c29 <pucAlignedHeap.1892+0x1>
    12f4:	89 2b       	or	r24, r25
    12f6:	31 f4       	brne	.+12     	; 0x1304 <pvPortMalloc+0x2e>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    12f8:	83 e6       	ldi	r24, 0x63	; 99
    12fa:	92 e0       	ldi	r25, 0x02	; 2
    12fc:	90 93 29 0c 	sts	0x0C29, r25	; 0x800c29 <pucAlignedHeap.1892+0x1>
    1300:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <pucAlignedHeap.1892>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1304:	20 91 26 0c 	lds	r18, 0x0C26	; 0x800c26 <xNextFreeByte>
    1308:	30 91 27 0c 	lds	r19, 0x0C27	; 0x800c27 <xNextFreeByte+0x1>
    130c:	8b 81       	ldd	r24, Y+3	; 0x03
    130e:	9c 81       	ldd	r25, Y+4	; 0x04
    1310:	82 0f       	add	r24, r18
    1312:	93 1f       	adc	r25, r19
    1314:	83 3c       	cpi	r24, 0xC3	; 195
    1316:	99 40       	sbci	r25, 0x09	; 9
    1318:	38 f5       	brcc	.+78     	; 0x1368 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    131a:	20 91 26 0c 	lds	r18, 0x0C26	; 0x800c26 <xNextFreeByte>
    131e:	30 91 27 0c 	lds	r19, 0x0C27	; 0x800c27 <xNextFreeByte+0x1>
    1322:	8b 81       	ldd	r24, Y+3	; 0x03
    1324:	9c 81       	ldd	r25, Y+4	; 0x04
    1326:	28 0f       	add	r18, r24
    1328:	39 1f       	adc	r19, r25
    132a:	80 91 26 0c 	lds	r24, 0x0C26	; 0x800c26 <xNextFreeByte>
    132e:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1332:	82 17       	cp	r24, r18
    1334:	93 07       	cpc	r25, r19
    1336:	c0 f4       	brcc	.+48     	; 0x1368 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1338:	20 91 28 0c 	lds	r18, 0x0C28	; 0x800c28 <pucAlignedHeap.1892>
    133c:	30 91 29 0c 	lds	r19, 0x0C29	; 0x800c29 <pucAlignedHeap.1892+0x1>
    1340:	80 91 26 0c 	lds	r24, 0x0C26	; 0x800c26 <xNextFreeByte>
    1344:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <xNextFreeByte+0x1>
    1348:	82 0f       	add	r24, r18
    134a:	93 1f       	adc	r25, r19
    134c:	9a 83       	std	Y+2, r25	; 0x02
    134e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1350:	20 91 26 0c 	lds	r18, 0x0C26	; 0x800c26 <xNextFreeByte>
    1354:	30 91 27 0c 	lds	r19, 0x0C27	; 0x800c27 <xNextFreeByte+0x1>
    1358:	8b 81       	ldd	r24, Y+3	; 0x03
    135a:	9c 81       	ldd	r25, Y+4	; 0x04
    135c:	82 0f       	add	r24, r18
    135e:	93 1f       	adc	r25, r19
    1360:	90 93 27 0c 	sts	0x0C27, r25	; 0x800c27 <xNextFreeByte+0x1>
    1364:	80 93 26 0c 	sts	0x0C26, r24	; 0x800c26 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1368:	d6 d6       	rcall	.+3500   	; 0x2116 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    136a:	89 81       	ldd	r24, Y+1	; 0x01
    136c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    136e:	0f 90       	pop	r0
    1370:	0f 90       	pop	r0
    1372:	0f 90       	pop	r0
    1374:	0f 90       	pop	r0
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
    1380:	1f 92       	push	r1
    1382:	1f 92       	push	r1
    1384:	cd b7       	in	r28, 0x3d	; 61
    1386:	de b7       	in	r29, 0x3e	; 62
    1388:	9a 83       	std	Y+2, r25	; 0x02
    138a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    138c:	0f 90       	pop	r0
    138e:	0f 90       	pop	r0
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	08 95       	ret

00001396 <xQueueGenericReset>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	00 d0       	rcall	.+0      	; 0x139c <xQueueGenericReset+0x6>
    139c:	1f 92       	push	r1
    139e:	1f 92       	push	r1
    13a0:	cd b7       	in	r28, 0x3d	; 61
    13a2:	de b7       	in	r29, 0x3e	; 62
    13a4:	9c 83       	std	Y+4, r25	; 0x04
    13a6:	8b 83       	std	Y+3, r24	; 0x03
    13a8:	6d 83       	std	Y+5, r22	; 0x05
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	9c 81       	ldd	r25, Y+4	; 0x04
    13ae:	9a 83       	std	Y+2, r25	; 0x02
    13b0:	89 83       	std	Y+1, r24	; 0x01
    13b2:	0f b6       	in	r0, 0x3f	; 63
    13b4:	f8 94       	cli
    13b6:	0f 92       	push	r0
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	9a 81       	ldd	r25, Y+2	; 0x02
    13bc:	fc 01       	movw	r30, r24
    13be:	80 81       	ld	r24, Z
    13c0:	91 81       	ldd	r25, Z+1	; 0x01
    13c2:	29 81       	ldd	r18, Y+1	; 0x01
    13c4:	3a 81       	ldd	r19, Y+2	; 0x02
    13c6:	f9 01       	movw	r30, r18
    13c8:	23 8d       	ldd	r18, Z+27	; 0x1b
    13ca:	42 2f       	mov	r20, r18
    13cc:	50 e0       	ldi	r21, 0x00	; 0
    13ce:	29 81       	ldd	r18, Y+1	; 0x01
    13d0:	3a 81       	ldd	r19, Y+2	; 0x02
    13d2:	f9 01       	movw	r30, r18
    13d4:	24 8d       	ldd	r18, Z+28	; 0x1c
    13d6:	22 2f       	mov	r18, r18
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	42 9f       	mul	r20, r18
    13dc:	b0 01       	movw	r22, r0
    13de:	43 9f       	mul	r20, r19
    13e0:	70 0d       	add	r23, r0
    13e2:	52 9f       	mul	r21, r18
    13e4:	70 0d       	add	r23, r0
    13e6:	11 24       	eor	r1, r1
    13e8:	9b 01       	movw	r18, r22
    13ea:	28 0f       	add	r18, r24
    13ec:	39 1f       	adc	r19, r25
    13ee:	89 81       	ldd	r24, Y+1	; 0x01
    13f0:	9a 81       	ldd	r25, Y+2	; 0x02
    13f2:	fc 01       	movw	r30, r24
    13f4:	33 83       	std	Z+3, r19	; 0x03
    13f6:	22 83       	std	Z+2, r18	; 0x02
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
    13fa:	9a 81       	ldd	r25, Y+2	; 0x02
    13fc:	fc 01       	movw	r30, r24
    13fe:	12 8e       	std	Z+26, r1	; 0x1a
    1400:	89 81       	ldd	r24, Y+1	; 0x01
    1402:	9a 81       	ldd	r25, Y+2	; 0x02
    1404:	fc 01       	movw	r30, r24
    1406:	20 81       	ld	r18, Z
    1408:	31 81       	ldd	r19, Z+1	; 0x01
    140a:	89 81       	ldd	r24, Y+1	; 0x01
    140c:	9a 81       	ldd	r25, Y+2	; 0x02
    140e:	fc 01       	movw	r30, r24
    1410:	35 83       	std	Z+5, r19	; 0x05
    1412:	24 83       	std	Z+4, r18	; 0x04
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	9a 81       	ldd	r25, Y+2	; 0x02
    1418:	fc 01       	movw	r30, r24
    141a:	80 81       	ld	r24, Z
    141c:	91 81       	ldd	r25, Z+1	; 0x01
    141e:	29 81       	ldd	r18, Y+1	; 0x01
    1420:	3a 81       	ldd	r19, Y+2	; 0x02
    1422:	f9 01       	movw	r30, r18
    1424:	23 8d       	ldd	r18, Z+27	; 0x1b
    1426:	22 2f       	mov	r18, r18
    1428:	30 e0       	ldi	r19, 0x00	; 0
    142a:	a9 01       	movw	r20, r18
    142c:	41 50       	subi	r20, 0x01	; 1
    142e:	51 09       	sbc	r21, r1
    1430:	29 81       	ldd	r18, Y+1	; 0x01
    1432:	3a 81       	ldd	r19, Y+2	; 0x02
    1434:	f9 01       	movw	r30, r18
    1436:	24 8d       	ldd	r18, Z+28	; 0x1c
    1438:	22 2f       	mov	r18, r18
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	42 9f       	mul	r20, r18
    143e:	b0 01       	movw	r22, r0
    1440:	43 9f       	mul	r20, r19
    1442:	70 0d       	add	r23, r0
    1444:	52 9f       	mul	r21, r18
    1446:	70 0d       	add	r23, r0
    1448:	11 24       	eor	r1, r1
    144a:	9b 01       	movw	r18, r22
    144c:	28 0f       	add	r18, r24
    144e:	39 1f       	adc	r19, r25
    1450:	89 81       	ldd	r24, Y+1	; 0x01
    1452:	9a 81       	ldd	r25, Y+2	; 0x02
    1454:	fc 01       	movw	r30, r24
    1456:	37 83       	std	Z+7, r19	; 0x07
    1458:	26 83       	std	Z+6, r18	; 0x06
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	9a 81       	ldd	r25, Y+2	; 0x02
    145e:	2f ef       	ldi	r18, 0xFF	; 255
    1460:	fc 01       	movw	r30, r24
    1462:	25 8f       	std	Z+29, r18	; 0x1d
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	9a 81       	ldd	r25, Y+2	; 0x02
    1468:	2f ef       	ldi	r18, 0xFF	; 255
    146a:	fc 01       	movw	r30, r24
    146c:	26 8f       	std	Z+30, r18	; 0x1e
    146e:	8d 81       	ldd	r24, Y+5	; 0x05
    1470:	88 23       	and	r24, r24
    1472:	79 f4       	brne	.+30     	; 0x1492 <xQueueGenericReset+0xfc>
    1474:	89 81       	ldd	r24, Y+1	; 0x01
    1476:	9a 81       	ldd	r25, Y+2	; 0x02
    1478:	fc 01       	movw	r30, r24
    147a:	80 85       	ldd	r24, Z+8	; 0x08
    147c:	88 23       	and	r24, r24
    147e:	89 f0       	breq	.+34     	; 0x14a2 <xQueueGenericReset+0x10c>
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	9a 81       	ldd	r25, Y+2	; 0x02
    1484:	08 96       	adiw	r24, 0x08	; 8
    1486:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    148a:	81 30       	cpi	r24, 0x01	; 1
    148c:	51 f4       	brne	.+20     	; 0x14a2 <xQueueGenericReset+0x10c>
    148e:	ac dd       	rcall	.-1192   	; 0xfe8 <vPortYield>
    1490:	08 c0       	rjmp	.+16     	; 0x14a2 <xQueueGenericReset+0x10c>
    1492:	89 81       	ldd	r24, Y+1	; 0x01
    1494:	9a 81       	ldd	r25, Y+2	; 0x02
    1496:	08 96       	adiw	r24, 0x08	; 8
    1498:	48 da       	rcall	.-2928   	; 0x92a <vListInitialise>
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	9a 81       	ldd	r25, Y+2	; 0x02
    149e:	41 96       	adiw	r24, 0x11	; 17
    14a0:	44 da       	rcall	.-2936   	; 0x92a <vListInitialise>
    14a2:	0f 90       	pop	r0
    14a4:	0f be       	out	0x3f, r0	; 63
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	0f 90       	pop	r0
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	08 95       	ret

000014b8 <xQueueGenericCreate>:
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	cd b7       	in	r28, 0x3d	; 61
    14be:	de b7       	in	r29, 0x3e	; 62
    14c0:	2b 97       	sbiw	r28, 0x0b	; 11
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	de bf       	out	0x3e, r29	; 62
    14c8:	0f be       	out	0x3f, r0	; 63
    14ca:	cd bf       	out	0x3d, r28	; 61
    14cc:	89 87       	std	Y+9, r24	; 0x09
    14ce:	6a 87       	std	Y+10, r22	; 0x0a
    14d0:	4b 87       	std	Y+11, r20	; 0x0b
    14d2:	1c 82       	std	Y+4, r1	; 0x04
    14d4:	1b 82       	std	Y+3, r1	; 0x03
    14d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    14d8:	88 23       	and	r24, r24
    14da:	19 f4       	brne	.+6      	; 0x14e2 <xQueueGenericCreate+0x2a>
    14dc:	1a 82       	std	Y+2, r1	; 0x02
    14de:	19 82       	std	Y+1, r1	; 0x01
    14e0:	11 c0       	rjmp	.+34     	; 0x1504 <xQueueGenericCreate+0x4c>
    14e2:	89 85       	ldd	r24, Y+9	; 0x09
    14e4:	28 2f       	mov	r18, r24
    14e6:	30 e0       	ldi	r19, 0x00	; 0
    14e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    14ea:	88 2f       	mov	r24, r24
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	28 9f       	mul	r18, r24
    14f0:	a0 01       	movw	r20, r0
    14f2:	29 9f       	mul	r18, r25
    14f4:	50 0d       	add	r21, r0
    14f6:	38 9f       	mul	r19, r24
    14f8:	50 0d       	add	r21, r0
    14fa:	11 24       	eor	r1, r1
    14fc:	ca 01       	movw	r24, r20
    14fe:	01 96       	adiw	r24, 0x01	; 1
    1500:	9a 83       	std	Y+2, r25	; 0x02
    1502:	89 83       	std	Y+1, r24	; 0x01
    1504:	89 81       	ldd	r24, Y+1	; 0x01
    1506:	9a 81       	ldd	r25, Y+2	; 0x02
    1508:	4f 96       	adiw	r24, 0x1f	; 31
    150a:	e5 de       	rcall	.-566    	; 0x12d6 <pvPortMalloc>
    150c:	9e 83       	std	Y+6, r25	; 0x06
    150e:	8d 83       	std	Y+5, r24	; 0x05
    1510:	8d 81       	ldd	r24, Y+5	; 0x05
    1512:	9e 81       	ldd	r25, Y+6	; 0x06
    1514:	89 2b       	or	r24, r25
    1516:	59 f1       	breq	.+86     	; 0x156e <xQueueGenericCreate+0xb6>
    1518:	8d 81       	ldd	r24, Y+5	; 0x05
    151a:	9e 81       	ldd	r25, Y+6	; 0x06
    151c:	98 87       	std	Y+8, r25	; 0x08
    151e:	8f 83       	std	Y+7, r24	; 0x07
    1520:	8a 85       	ldd	r24, Y+10	; 0x0a
    1522:	88 23       	and	r24, r24
    1524:	41 f4       	brne	.+16     	; 0x1536 <xQueueGenericCreate+0x7e>
    1526:	8f 81       	ldd	r24, Y+7	; 0x07
    1528:	98 85       	ldd	r25, Y+8	; 0x08
    152a:	2f 81       	ldd	r18, Y+7	; 0x07
    152c:	38 85       	ldd	r19, Y+8	; 0x08
    152e:	fc 01       	movw	r30, r24
    1530:	31 83       	std	Z+1, r19	; 0x01
    1532:	20 83       	st	Z, r18
    1534:	0a c0       	rjmp	.+20     	; 0x154a <xQueueGenericCreate+0x92>
    1536:	8d 81       	ldd	r24, Y+5	; 0x05
    1538:	9e 81       	ldd	r25, Y+6	; 0x06
    153a:	9c 01       	movw	r18, r24
    153c:	21 5e       	subi	r18, 0xE1	; 225
    153e:	3f 4f       	sbci	r19, 0xFF	; 255
    1540:	8f 81       	ldd	r24, Y+7	; 0x07
    1542:	98 85       	ldd	r25, Y+8	; 0x08
    1544:	fc 01       	movw	r30, r24
    1546:	31 83       	std	Z+1, r19	; 0x01
    1548:	20 83       	st	Z, r18
    154a:	8f 81       	ldd	r24, Y+7	; 0x07
    154c:	98 85       	ldd	r25, Y+8	; 0x08
    154e:	29 85       	ldd	r18, Y+9	; 0x09
    1550:	fc 01       	movw	r30, r24
    1552:	23 8f       	std	Z+27, r18	; 0x1b
    1554:	8f 81       	ldd	r24, Y+7	; 0x07
    1556:	98 85       	ldd	r25, Y+8	; 0x08
    1558:	2a 85       	ldd	r18, Y+10	; 0x0a
    155a:	fc 01       	movw	r30, r24
    155c:	24 8f       	std	Z+28, r18	; 0x1c
    155e:	8f 81       	ldd	r24, Y+7	; 0x07
    1560:	98 85       	ldd	r25, Y+8	; 0x08
    1562:	61 e0       	ldi	r22, 0x01	; 1
    1564:	18 df       	rcall	.-464    	; 0x1396 <xQueueGenericReset>
    1566:	8f 81       	ldd	r24, Y+7	; 0x07
    1568:	98 85       	ldd	r25, Y+8	; 0x08
    156a:	9c 83       	std	Y+4, r25	; 0x04
    156c:	8b 83       	std	Y+3, r24	; 0x03
    156e:	8b 81       	ldd	r24, Y+3	; 0x03
    1570:	9c 81       	ldd	r25, Y+4	; 0x04
    1572:	2b 96       	adiw	r28, 0x0b	; 11
    1574:	0f b6       	in	r0, 0x3f	; 63
    1576:	f8 94       	cli
    1578:	de bf       	out	0x3e, r29	; 62
    157a:	0f be       	out	0x3f, r0	; 63
    157c:	cd bf       	out	0x3d, r28	; 61
    157e:	df 91       	pop	r29
    1580:	cf 91       	pop	r28
    1582:	08 95       	ret

00001584 <xQueueGenericSend>:
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	cd b7       	in	r28, 0x3d	; 61
    158a:	de b7       	in	r29, 0x3e	; 62
    158c:	2e 97       	sbiw	r28, 0x0e	; 14
    158e:	0f b6       	in	r0, 0x3f	; 63
    1590:	f8 94       	cli
    1592:	de bf       	out	0x3e, r29	; 62
    1594:	0f be       	out	0x3f, r0	; 63
    1596:	cd bf       	out	0x3d, r28	; 61
    1598:	99 87       	std	Y+9, r25	; 0x09
    159a:	88 87       	std	Y+8, r24	; 0x08
    159c:	7b 87       	std	Y+11, r23	; 0x0b
    159e:	6a 87       	std	Y+10, r22	; 0x0a
    15a0:	5d 87       	std	Y+13, r21	; 0x0d
    15a2:	4c 87       	std	Y+12, r20	; 0x0c
    15a4:	2e 87       	std	Y+14, r18	; 0x0e
    15a6:	19 82       	std	Y+1, r1	; 0x01
    15a8:	88 85       	ldd	r24, Y+8	; 0x08
    15aa:	99 85       	ldd	r25, Y+9	; 0x09
    15ac:	9b 83       	std	Y+3, r25	; 0x03
    15ae:	8a 83       	std	Y+2, r24	; 0x02
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	0f 92       	push	r0
    15b6:	8a 81       	ldd	r24, Y+2	; 0x02
    15b8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ba:	fc 01       	movw	r30, r24
    15bc:	22 8d       	ldd	r18, Z+26	; 0x1a
    15be:	8a 81       	ldd	r24, Y+2	; 0x02
    15c0:	9b 81       	ldd	r25, Y+3	; 0x03
    15c2:	fc 01       	movw	r30, r24
    15c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    15c6:	28 17       	cp	r18, r24
    15c8:	18 f0       	brcs	.+6      	; 0x15d0 <xQueueGenericSend+0x4c>
    15ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    15cc:	82 30       	cpi	r24, 0x02	; 2
    15ce:	f9 f4       	brne	.+62     	; 0x160e <xQueueGenericSend+0x8a>
    15d0:	2a 85       	ldd	r18, Y+10	; 0x0a
    15d2:	3b 85       	ldd	r19, Y+11	; 0x0b
    15d4:	8a 81       	ldd	r24, Y+2	; 0x02
    15d6:	9b 81       	ldd	r25, Y+3	; 0x03
    15d8:	4e 85       	ldd	r20, Y+14	; 0x0e
    15da:	b9 01       	movw	r22, r18
    15dc:	f3 d1       	rcall	.+998    	; 0x19c4 <prvCopyDataToQueue>
    15de:	8c 83       	std	Y+4, r24	; 0x04
    15e0:	8a 81       	ldd	r24, Y+2	; 0x02
    15e2:	9b 81       	ldd	r25, Y+3	; 0x03
    15e4:	fc 01       	movw	r30, r24
    15e6:	81 89       	ldd	r24, Z+17	; 0x11
    15e8:	88 23       	and	r24, r24
    15ea:	49 f0       	breq	.+18     	; 0x15fe <xQueueGenericSend+0x7a>
    15ec:	8a 81       	ldd	r24, Y+2	; 0x02
    15ee:	9b 81       	ldd	r25, Y+3	; 0x03
    15f0:	41 96       	adiw	r24, 0x11	; 17
    15f2:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    15f6:	81 30       	cpi	r24, 0x01	; 1
    15f8:	31 f4       	brne	.+12     	; 0x1606 <xQueueGenericSend+0x82>
    15fa:	f6 dc       	rcall	.-1556   	; 0xfe8 <vPortYield>
    15fc:	04 c0       	rjmp	.+8      	; 0x1606 <xQueueGenericSend+0x82>
    15fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1600:	88 23       	and	r24, r24
    1602:	09 f0       	breq	.+2      	; 0x1606 <xQueueGenericSend+0x82>
    1604:	f1 dc       	rcall	.-1566   	; 0xfe8 <vPortYield>
    1606:	0f 90       	pop	r0
    1608:	0f be       	out	0x3f, r0	; 63
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	57 c0       	rjmp	.+174    	; 0x16bc <xQueueGenericSend+0x138>
    160e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1610:	9d 85       	ldd	r25, Y+13	; 0x0d
    1612:	89 2b       	or	r24, r25
    1614:	21 f4       	brne	.+8      	; 0x161e <xQueueGenericSend+0x9a>
    1616:	0f 90       	pop	r0
    1618:	0f be       	out	0x3f, r0	; 63
    161a:	80 e0       	ldi	r24, 0x00	; 0
    161c:	4f c0       	rjmp	.+158    	; 0x16bc <xQueueGenericSend+0x138>
    161e:	89 81       	ldd	r24, Y+1	; 0x01
    1620:	88 23       	and	r24, r24
    1622:	31 f4       	brne	.+12     	; 0x1630 <xQueueGenericSend+0xac>
    1624:	ce 01       	movw	r24, r28
    1626:	05 96       	adiw	r24, 0x05	; 5
    1628:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSetTimeOutState>
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	89 83       	std	Y+1, r24	; 0x01
    1630:	0f 90       	pop	r0
    1632:	0f be       	out	0x3f, r0	; 63
    1634:	64 d5       	rcall	.+2760   	; 0x20fe <vTaskSuspendAll>
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	0f 92       	push	r0
    163c:	8a 81       	ldd	r24, Y+2	; 0x02
    163e:	9b 81       	ldd	r25, Y+3	; 0x03
    1640:	fc 01       	movw	r30, r24
    1642:	85 8d       	ldd	r24, Z+29	; 0x1d
    1644:	8f 3f       	cpi	r24, 0xFF	; 255
    1646:	21 f4       	brne	.+8      	; 0x1650 <xQueueGenericSend+0xcc>
    1648:	8a 81       	ldd	r24, Y+2	; 0x02
    164a:	9b 81       	ldd	r25, Y+3	; 0x03
    164c:	fc 01       	movw	r30, r24
    164e:	15 8e       	std	Z+29, r1	; 0x1d
    1650:	8a 81       	ldd	r24, Y+2	; 0x02
    1652:	9b 81       	ldd	r25, Y+3	; 0x03
    1654:	fc 01       	movw	r30, r24
    1656:	86 8d       	ldd	r24, Z+30	; 0x1e
    1658:	8f 3f       	cpi	r24, 0xFF	; 255
    165a:	21 f4       	brne	.+8      	; 0x1664 <xQueueGenericSend+0xe0>
    165c:	8a 81       	ldd	r24, Y+2	; 0x02
    165e:	9b 81       	ldd	r25, Y+3	; 0x03
    1660:	fc 01       	movw	r30, r24
    1662:	16 8e       	std	Z+30, r1	; 0x1e
    1664:	0f 90       	pop	r0
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	9e 01       	movw	r18, r28
    166a:	24 5f       	subi	r18, 0xF4	; 244
    166c:	3f 4f       	sbci	r19, 0xFF	; 255
    166e:	ce 01       	movw	r24, r28
    1670:	05 96       	adiw	r24, 0x05	; 5
    1672:	b9 01       	movw	r22, r18
    1674:	0e 94 a8 13 	call	0x2750	; 0x2750 <xTaskCheckForTimeOut>
    1678:	88 23       	and	r24, r24
    167a:	c9 f4       	brne	.+50     	; 0x16ae <xQueueGenericSend+0x12a>
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	9b 81       	ldd	r25, Y+3	; 0x03
    1680:	2e d3       	rcall	.+1628   	; 0x1cde <prvIsQueueFull>
    1682:	88 23       	and	r24, r24
    1684:	79 f0       	breq	.+30     	; 0x16a4 <xQueueGenericSend+0x120>
    1686:	2c 85       	ldd	r18, Y+12	; 0x0c
    1688:	3d 85       	ldd	r19, Y+13	; 0x0d
    168a:	8a 81       	ldd	r24, Y+2	; 0x02
    168c:	9b 81       	ldd	r25, Y+3	; 0x03
    168e:	08 96       	adiw	r24, 0x08	; 8
    1690:	b9 01       	movw	r22, r18
    1692:	60 d7       	rcall	.+3776   	; 0x2554 <vTaskPlaceOnEventList>
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	9b 81       	ldd	r25, Y+3	; 0x03
    1698:	a4 d2       	rcall	.+1352   	; 0x1be2 <prvUnlockQueue>
    169a:	3d d5       	rcall	.+2682   	; 0x2116 <xTaskResumeAll>
    169c:	88 23       	and	r24, r24
    169e:	69 f4       	brne	.+26     	; 0x16ba <xQueueGenericSend+0x136>
    16a0:	a3 dc       	rcall	.-1722   	; 0xfe8 <vPortYield>
    16a2:	0b c0       	rjmp	.+22     	; 0x16ba <xQueueGenericSend+0x136>
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	9b 81       	ldd	r25, Y+3	; 0x03
    16a8:	9c d2       	rcall	.+1336   	; 0x1be2 <prvUnlockQueue>
    16aa:	35 d5       	rcall	.+2666   	; 0x2116 <xTaskResumeAll>
    16ac:	81 cf       	rjmp	.-254    	; 0x15b0 <xQueueGenericSend+0x2c>
    16ae:	8a 81       	ldd	r24, Y+2	; 0x02
    16b0:	9b 81       	ldd	r25, Y+3	; 0x03
    16b2:	97 d2       	rcall	.+1326   	; 0x1be2 <prvUnlockQueue>
    16b4:	30 d5       	rcall	.+2656   	; 0x2116 <xTaskResumeAll>
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	01 c0       	rjmp	.+2      	; 0x16bc <xQueueGenericSend+0x138>
    16ba:	7a cf       	rjmp	.-268    	; 0x15b0 <xQueueGenericSend+0x2c>
    16bc:	2e 96       	adiw	r28, 0x0e	; 14
    16be:	0f b6       	in	r0, 0x3f	; 63
    16c0:	f8 94       	cli
    16c2:	de bf       	out	0x3e, r29	; 62
    16c4:	0f be       	out	0x3f, r0	; 63
    16c6:	cd bf       	out	0x3d, r28	; 61
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	08 95       	ret

000016ce <xQueueGenericSendFromISR>:
    16ce:	cf 93       	push	r28
    16d0:	df 93       	push	r29
    16d2:	cd b7       	in	r28, 0x3d	; 61
    16d4:	de b7       	in	r29, 0x3e	; 62
    16d6:	2b 97       	sbiw	r28, 0x0b	; 11
    16d8:	0f b6       	in	r0, 0x3f	; 63
    16da:	f8 94       	cli
    16dc:	de bf       	out	0x3e, r29	; 62
    16de:	0f be       	out	0x3f, r0	; 63
    16e0:	cd bf       	out	0x3d, r28	; 61
    16e2:	9e 83       	std	Y+6, r25	; 0x06
    16e4:	8d 83       	std	Y+5, r24	; 0x05
    16e6:	78 87       	std	Y+8, r23	; 0x08
    16e8:	6f 83       	std	Y+7, r22	; 0x07
    16ea:	5a 87       	std	Y+10, r21	; 0x0a
    16ec:	49 87       	std	Y+9, r20	; 0x09
    16ee:	2b 87       	std	Y+11, r18	; 0x0b
    16f0:	8d 81       	ldd	r24, Y+5	; 0x05
    16f2:	9e 81       	ldd	r25, Y+6	; 0x06
    16f4:	9b 83       	std	Y+3, r25	; 0x03
    16f6:	8a 83       	std	Y+2, r24	; 0x02
    16f8:	1c 82       	std	Y+4, r1	; 0x04
    16fa:	8a 81       	ldd	r24, Y+2	; 0x02
    16fc:	9b 81       	ldd	r25, Y+3	; 0x03
    16fe:	fc 01       	movw	r30, r24
    1700:	22 8d       	ldd	r18, Z+26	; 0x1a
    1702:	8a 81       	ldd	r24, Y+2	; 0x02
    1704:	9b 81       	ldd	r25, Y+3	; 0x03
    1706:	fc 01       	movw	r30, r24
    1708:	83 8d       	ldd	r24, Z+27	; 0x1b
    170a:	28 17       	cp	r18, r24
    170c:	18 f0       	brcs	.+6      	; 0x1714 <xQueueGenericSendFromISR+0x46>
    170e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1710:	82 30       	cpi	r24, 0x02	; 2
    1712:	81 f5       	brne	.+96     	; 0x1774 <xQueueGenericSendFromISR+0xa6>
    1714:	2f 81       	ldd	r18, Y+7	; 0x07
    1716:	38 85       	ldd	r19, Y+8	; 0x08
    1718:	8a 81       	ldd	r24, Y+2	; 0x02
    171a:	9b 81       	ldd	r25, Y+3	; 0x03
    171c:	4b 85       	ldd	r20, Y+11	; 0x0b
    171e:	b9 01       	movw	r22, r18
    1720:	51 d1       	rcall	.+674    	; 0x19c4 <prvCopyDataToQueue>
    1722:	8a 81       	ldd	r24, Y+2	; 0x02
    1724:	9b 81       	ldd	r25, Y+3	; 0x03
    1726:	fc 01       	movw	r30, r24
    1728:	86 8d       	ldd	r24, Z+30	; 0x1e
    172a:	8f 3f       	cpi	r24, 0xFF	; 255
    172c:	b1 f4       	brne	.+44     	; 0x175a <xQueueGenericSendFromISR+0x8c>
    172e:	8a 81       	ldd	r24, Y+2	; 0x02
    1730:	9b 81       	ldd	r25, Y+3	; 0x03
    1732:	fc 01       	movw	r30, r24
    1734:	81 89       	ldd	r24, Z+17	; 0x11
    1736:	88 23       	and	r24, r24
    1738:	d1 f0       	breq	.+52     	; 0x176e <xQueueGenericSendFromISR+0xa0>
    173a:	8a 81       	ldd	r24, Y+2	; 0x02
    173c:	9b 81       	ldd	r25, Y+3	; 0x03
    173e:	41 96       	adiw	r24, 0x11	; 17
    1740:	7e d7       	rcall	.+3836   	; 0x263e <xTaskRemoveFromEventList>
    1742:	88 23       	and	r24, r24
    1744:	a1 f0       	breq	.+40     	; 0x176e <xQueueGenericSendFromISR+0xa0>
    1746:	89 85       	ldd	r24, Y+9	; 0x09
    1748:	9a 85       	ldd	r25, Y+10	; 0x0a
    174a:	89 2b       	or	r24, r25
    174c:	81 f0       	breq	.+32     	; 0x176e <xQueueGenericSendFromISR+0xa0>
    174e:	89 85       	ldd	r24, Y+9	; 0x09
    1750:	9a 85       	ldd	r25, Y+10	; 0x0a
    1752:	21 e0       	ldi	r18, 0x01	; 1
    1754:	fc 01       	movw	r30, r24
    1756:	20 83       	st	Z, r18
    1758:	0a c0       	rjmp	.+20     	; 0x176e <xQueueGenericSendFromISR+0xa0>
    175a:	8a 81       	ldd	r24, Y+2	; 0x02
    175c:	9b 81       	ldd	r25, Y+3	; 0x03
    175e:	fc 01       	movw	r30, r24
    1760:	86 8d       	ldd	r24, Z+30	; 0x1e
    1762:	8f 5f       	subi	r24, 0xFF	; 255
    1764:	28 2f       	mov	r18, r24
    1766:	8a 81       	ldd	r24, Y+2	; 0x02
    1768:	9b 81       	ldd	r25, Y+3	; 0x03
    176a:	fc 01       	movw	r30, r24
    176c:	26 8f       	std	Z+30, r18	; 0x1e
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	89 83       	std	Y+1, r24	; 0x01
    1772:	01 c0       	rjmp	.+2      	; 0x1776 <xQueueGenericSendFromISR+0xa8>
    1774:	19 82       	std	Y+1, r1	; 0x01
    1776:	89 81       	ldd	r24, Y+1	; 0x01
    1778:	2b 96       	adiw	r28, 0x0b	; 11
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	f8 94       	cli
    177e:	de bf       	out	0x3e, r29	; 62
    1780:	0f be       	out	0x3f, r0	; 63
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	08 95       	ret

0000178a <xQueueGenericReceive>:
    178a:	cf 93       	push	r28
    178c:	df 93       	push	r29
    178e:	cd b7       	in	r28, 0x3d	; 61
    1790:	de b7       	in	r29, 0x3e	; 62
    1792:	2f 97       	sbiw	r28, 0x0f	; 15
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	de bf       	out	0x3e, r29	; 62
    179a:	0f be       	out	0x3f, r0	; 63
    179c:	cd bf       	out	0x3d, r28	; 61
    179e:	9a 87       	std	Y+10, r25	; 0x0a
    17a0:	89 87       	std	Y+9, r24	; 0x09
    17a2:	7c 87       	std	Y+12, r23	; 0x0c
    17a4:	6b 87       	std	Y+11, r22	; 0x0b
    17a6:	5e 87       	std	Y+14, r21	; 0x0e
    17a8:	4d 87       	std	Y+13, r20	; 0x0d
    17aa:	2f 87       	std	Y+15, r18	; 0x0f
    17ac:	19 82       	std	Y+1, r1	; 0x01
    17ae:	89 85       	ldd	r24, Y+9	; 0x09
    17b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    17b2:	9b 83       	std	Y+3, r25	; 0x03
    17b4:	8a 83       	std	Y+2, r24	; 0x02
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	f8 94       	cli
    17ba:	0f 92       	push	r0
    17bc:	8a 81       	ldd	r24, Y+2	; 0x02
    17be:	9b 81       	ldd	r25, Y+3	; 0x03
    17c0:	fc 01       	movw	r30, r24
    17c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    17c4:	88 23       	and	r24, r24
    17c6:	09 f4       	brne	.+2      	; 0x17ca <xQueueGenericReceive+0x40>
    17c8:	40 c0       	rjmp	.+128    	; 0x184a <xQueueGenericReceive+0xc0>
    17ca:	8a 81       	ldd	r24, Y+2	; 0x02
    17cc:	9b 81       	ldd	r25, Y+3	; 0x03
    17ce:	fc 01       	movw	r30, r24
    17d0:	86 81       	ldd	r24, Z+6	; 0x06
    17d2:	97 81       	ldd	r25, Z+7	; 0x07
    17d4:	9d 83       	std	Y+5, r25	; 0x05
    17d6:	8c 83       	std	Y+4, r24	; 0x04
    17d8:	2b 85       	ldd	r18, Y+11	; 0x0b
    17da:	3c 85       	ldd	r19, Y+12	; 0x0c
    17dc:	8a 81       	ldd	r24, Y+2	; 0x02
    17de:	9b 81       	ldd	r25, Y+3	; 0x03
    17e0:	b9 01       	movw	r22, r18
    17e2:	af d1       	rcall	.+862    	; 0x1b42 <prvCopyDataFromQueue>
    17e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    17e6:	88 23       	and	r24, r24
    17e8:	c1 f4       	brne	.+48     	; 0x181a <xQueueGenericReceive+0x90>
    17ea:	8a 81       	ldd	r24, Y+2	; 0x02
    17ec:	9b 81       	ldd	r25, Y+3	; 0x03
    17ee:	fc 01       	movw	r30, r24
    17f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    17f2:	2f ef       	ldi	r18, 0xFF	; 255
    17f4:	28 0f       	add	r18, r24
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	9b 81       	ldd	r25, Y+3	; 0x03
    17fa:	fc 01       	movw	r30, r24
    17fc:	22 8f       	std	Z+26, r18	; 0x1a
    17fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1800:	9b 81       	ldd	r25, Y+3	; 0x03
    1802:	fc 01       	movw	r30, r24
    1804:	80 85       	ldd	r24, Z+8	; 0x08
    1806:	88 23       	and	r24, r24
    1808:	e1 f0       	breq	.+56     	; 0x1842 <xQueueGenericReceive+0xb8>
    180a:	8a 81       	ldd	r24, Y+2	; 0x02
    180c:	9b 81       	ldd	r25, Y+3	; 0x03
    180e:	08 96       	adiw	r24, 0x08	; 8
    1810:	16 d7       	rcall	.+3628   	; 0x263e <xTaskRemoveFromEventList>
    1812:	81 30       	cpi	r24, 0x01	; 1
    1814:	b1 f4       	brne	.+44     	; 0x1842 <xQueueGenericReceive+0xb8>
    1816:	e8 db       	rcall	.-2096   	; 0xfe8 <vPortYield>
    1818:	14 c0       	rjmp	.+40     	; 0x1842 <xQueueGenericReceive+0xb8>
    181a:	8a 81       	ldd	r24, Y+2	; 0x02
    181c:	9b 81       	ldd	r25, Y+3	; 0x03
    181e:	2c 81       	ldd	r18, Y+4	; 0x04
    1820:	3d 81       	ldd	r19, Y+5	; 0x05
    1822:	fc 01       	movw	r30, r24
    1824:	37 83       	std	Z+7, r19	; 0x07
    1826:	26 83       	std	Z+6, r18	; 0x06
    1828:	8a 81       	ldd	r24, Y+2	; 0x02
    182a:	9b 81       	ldd	r25, Y+3	; 0x03
    182c:	fc 01       	movw	r30, r24
    182e:	81 89       	ldd	r24, Z+17	; 0x11
    1830:	88 23       	and	r24, r24
    1832:	39 f0       	breq	.+14     	; 0x1842 <xQueueGenericReceive+0xb8>
    1834:	8a 81       	ldd	r24, Y+2	; 0x02
    1836:	9b 81       	ldd	r25, Y+3	; 0x03
    1838:	41 96       	adiw	r24, 0x11	; 17
    183a:	01 d7       	rcall	.+3586   	; 0x263e <xTaskRemoveFromEventList>
    183c:	88 23       	and	r24, r24
    183e:	09 f0       	breq	.+2      	; 0x1842 <xQueueGenericReceive+0xb8>
    1840:	d3 db       	rcall	.-2138   	; 0xfe8 <vPortYield>
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	55 c0       	rjmp	.+170    	; 0x18f4 <xQueueGenericReceive+0x16a>
    184a:	8d 85       	ldd	r24, Y+13	; 0x0d
    184c:	9e 85       	ldd	r25, Y+14	; 0x0e
    184e:	89 2b       	or	r24, r25
    1850:	21 f4       	brne	.+8      	; 0x185a <xQueueGenericReceive+0xd0>
    1852:	0f 90       	pop	r0
    1854:	0f be       	out	0x3f, r0	; 63
    1856:	80 e0       	ldi	r24, 0x00	; 0
    1858:	4d c0       	rjmp	.+154    	; 0x18f4 <xQueueGenericReceive+0x16a>
    185a:	89 81       	ldd	r24, Y+1	; 0x01
    185c:	88 23       	and	r24, r24
    185e:	29 f4       	brne	.+10     	; 0x186a <xQueueGenericReceive+0xe0>
    1860:	ce 01       	movw	r24, r28
    1862:	06 96       	adiw	r24, 0x06	; 6
    1864:	59 d7       	rcall	.+3762   	; 0x2718 <vTaskSetTimeOutState>
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	89 83       	std	Y+1, r24	; 0x01
    186a:	0f 90       	pop	r0
    186c:	0f be       	out	0x3f, r0	; 63
    186e:	47 d4       	rcall	.+2190   	; 0x20fe <vTaskSuspendAll>
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	f8 94       	cli
    1874:	0f 92       	push	r0
    1876:	8a 81       	ldd	r24, Y+2	; 0x02
    1878:	9b 81       	ldd	r25, Y+3	; 0x03
    187a:	fc 01       	movw	r30, r24
    187c:	85 8d       	ldd	r24, Z+29	; 0x1d
    187e:	8f 3f       	cpi	r24, 0xFF	; 255
    1880:	21 f4       	brne	.+8      	; 0x188a <xQueueGenericReceive+0x100>
    1882:	8a 81       	ldd	r24, Y+2	; 0x02
    1884:	9b 81       	ldd	r25, Y+3	; 0x03
    1886:	fc 01       	movw	r30, r24
    1888:	15 8e       	std	Z+29, r1	; 0x1d
    188a:	8a 81       	ldd	r24, Y+2	; 0x02
    188c:	9b 81       	ldd	r25, Y+3	; 0x03
    188e:	fc 01       	movw	r30, r24
    1890:	86 8d       	ldd	r24, Z+30	; 0x1e
    1892:	8f 3f       	cpi	r24, 0xFF	; 255
    1894:	21 f4       	brne	.+8      	; 0x189e <xQueueGenericReceive+0x114>
    1896:	8a 81       	ldd	r24, Y+2	; 0x02
    1898:	9b 81       	ldd	r25, Y+3	; 0x03
    189a:	fc 01       	movw	r30, r24
    189c:	16 8e       	std	Z+30, r1	; 0x1e
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	9e 01       	movw	r18, r28
    18a4:	23 5f       	subi	r18, 0xF3	; 243
    18a6:	3f 4f       	sbci	r19, 0xFF	; 255
    18a8:	ce 01       	movw	r24, r28
    18aa:	06 96       	adiw	r24, 0x06	; 6
    18ac:	b9 01       	movw	r22, r18
    18ae:	50 d7       	rcall	.+3744   	; 0x2750 <xTaskCheckForTimeOut>
    18b0:	88 23       	and	r24, r24
    18b2:	c9 f4       	brne	.+50     	; 0x18e6 <xQueueGenericReceive+0x15c>
    18b4:	8a 81       	ldd	r24, Y+2	; 0x02
    18b6:	9b 81       	ldd	r25, Y+3	; 0x03
    18b8:	f5 d1       	rcall	.+1002   	; 0x1ca4 <prvIsQueueEmpty>
    18ba:	88 23       	and	r24, r24
    18bc:	79 f0       	breq	.+30     	; 0x18dc <xQueueGenericReceive+0x152>
    18be:	2d 85       	ldd	r18, Y+13	; 0x0d
    18c0:	3e 85       	ldd	r19, Y+14	; 0x0e
    18c2:	8a 81       	ldd	r24, Y+2	; 0x02
    18c4:	9b 81       	ldd	r25, Y+3	; 0x03
    18c6:	41 96       	adiw	r24, 0x11	; 17
    18c8:	b9 01       	movw	r22, r18
    18ca:	44 d6       	rcall	.+3208   	; 0x2554 <vTaskPlaceOnEventList>
    18cc:	8a 81       	ldd	r24, Y+2	; 0x02
    18ce:	9b 81       	ldd	r25, Y+3	; 0x03
    18d0:	88 d1       	rcall	.+784    	; 0x1be2 <prvUnlockQueue>
    18d2:	21 d4       	rcall	.+2114   	; 0x2116 <xTaskResumeAll>
    18d4:	88 23       	and	r24, r24
    18d6:	69 f4       	brne	.+26     	; 0x18f2 <xQueueGenericReceive+0x168>
    18d8:	87 db       	rcall	.-2290   	; 0xfe8 <vPortYield>
    18da:	0b c0       	rjmp	.+22     	; 0x18f2 <xQueueGenericReceive+0x168>
    18dc:	8a 81       	ldd	r24, Y+2	; 0x02
    18de:	9b 81       	ldd	r25, Y+3	; 0x03
    18e0:	80 d1       	rcall	.+768    	; 0x1be2 <prvUnlockQueue>
    18e2:	19 d4       	rcall	.+2098   	; 0x2116 <xTaskResumeAll>
    18e4:	68 cf       	rjmp	.-304    	; 0x17b6 <xQueueGenericReceive+0x2c>
    18e6:	8a 81       	ldd	r24, Y+2	; 0x02
    18e8:	9b 81       	ldd	r25, Y+3	; 0x03
    18ea:	7b d1       	rcall	.+758    	; 0x1be2 <prvUnlockQueue>
    18ec:	14 d4       	rcall	.+2088   	; 0x2116 <xTaskResumeAll>
    18ee:	80 e0       	ldi	r24, 0x00	; 0
    18f0:	01 c0       	rjmp	.+2      	; 0x18f4 <xQueueGenericReceive+0x16a>
    18f2:	61 cf       	rjmp	.-318    	; 0x17b6 <xQueueGenericReceive+0x2c>
    18f4:	2f 96       	adiw	r28, 0x0f	; 15
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	f8 94       	cli
    18fa:	de bf       	out	0x3e, r29	; 62
    18fc:	0f be       	out	0x3f, r0	; 63
    18fe:	cd bf       	out	0x3d, r28	; 61
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	08 95       	ret

00001906 <xQueueReceiveFromISR>:
    1906:	cf 93       	push	r28
    1908:	df 93       	push	r29
    190a:	cd b7       	in	r28, 0x3d	; 61
    190c:	de b7       	in	r29, 0x3e	; 62
    190e:	2a 97       	sbiw	r28, 0x0a	; 10
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	de bf       	out	0x3e, r29	; 62
    1916:	0f be       	out	0x3f, r0	; 63
    1918:	cd bf       	out	0x3d, r28	; 61
    191a:	9e 83       	std	Y+6, r25	; 0x06
    191c:	8d 83       	std	Y+5, r24	; 0x05
    191e:	78 87       	std	Y+8, r23	; 0x08
    1920:	6f 83       	std	Y+7, r22	; 0x07
    1922:	5a 87       	std	Y+10, r21	; 0x0a
    1924:	49 87       	std	Y+9, r20	; 0x09
    1926:	8d 81       	ldd	r24, Y+5	; 0x05
    1928:	9e 81       	ldd	r25, Y+6	; 0x06
    192a:	9b 83       	std	Y+3, r25	; 0x03
    192c:	8a 83       	std	Y+2, r24	; 0x02
    192e:	1c 82       	std	Y+4, r1	; 0x04
    1930:	8a 81       	ldd	r24, Y+2	; 0x02
    1932:	9b 81       	ldd	r25, Y+3	; 0x03
    1934:	fc 01       	movw	r30, r24
    1936:	82 8d       	ldd	r24, Z+26	; 0x1a
    1938:	88 23       	and	r24, r24
    193a:	c9 f1       	breq	.+114    	; 0x19ae <xQueueReceiveFromISR+0xa8>
    193c:	2f 81       	ldd	r18, Y+7	; 0x07
    193e:	38 85       	ldd	r19, Y+8	; 0x08
    1940:	8a 81       	ldd	r24, Y+2	; 0x02
    1942:	9b 81       	ldd	r25, Y+3	; 0x03
    1944:	b9 01       	movw	r22, r18
    1946:	fd d0       	rcall	.+506    	; 0x1b42 <prvCopyDataFromQueue>
    1948:	8a 81       	ldd	r24, Y+2	; 0x02
    194a:	9b 81       	ldd	r25, Y+3	; 0x03
    194c:	fc 01       	movw	r30, r24
    194e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1950:	2f ef       	ldi	r18, 0xFF	; 255
    1952:	28 0f       	add	r18, r24
    1954:	8a 81       	ldd	r24, Y+2	; 0x02
    1956:	9b 81       	ldd	r25, Y+3	; 0x03
    1958:	fc 01       	movw	r30, r24
    195a:	22 8f       	std	Z+26, r18	; 0x1a
    195c:	8a 81       	ldd	r24, Y+2	; 0x02
    195e:	9b 81       	ldd	r25, Y+3	; 0x03
    1960:	fc 01       	movw	r30, r24
    1962:	85 8d       	ldd	r24, Z+29	; 0x1d
    1964:	8f 3f       	cpi	r24, 0xFF	; 255
    1966:	b1 f4       	brne	.+44     	; 0x1994 <xQueueReceiveFromISR+0x8e>
    1968:	8a 81       	ldd	r24, Y+2	; 0x02
    196a:	9b 81       	ldd	r25, Y+3	; 0x03
    196c:	fc 01       	movw	r30, r24
    196e:	80 85       	ldd	r24, Z+8	; 0x08
    1970:	88 23       	and	r24, r24
    1972:	d1 f0       	breq	.+52     	; 0x19a8 <xQueueReceiveFromISR+0xa2>
    1974:	8a 81       	ldd	r24, Y+2	; 0x02
    1976:	9b 81       	ldd	r25, Y+3	; 0x03
    1978:	08 96       	adiw	r24, 0x08	; 8
    197a:	61 d6       	rcall	.+3266   	; 0x263e <xTaskRemoveFromEventList>
    197c:	88 23       	and	r24, r24
    197e:	a1 f0       	breq	.+40     	; 0x19a8 <xQueueReceiveFromISR+0xa2>
    1980:	89 85       	ldd	r24, Y+9	; 0x09
    1982:	9a 85       	ldd	r25, Y+10	; 0x0a
    1984:	89 2b       	or	r24, r25
    1986:	81 f0       	breq	.+32     	; 0x19a8 <xQueueReceiveFromISR+0xa2>
    1988:	89 85       	ldd	r24, Y+9	; 0x09
    198a:	9a 85       	ldd	r25, Y+10	; 0x0a
    198c:	21 e0       	ldi	r18, 0x01	; 1
    198e:	fc 01       	movw	r30, r24
    1990:	20 83       	st	Z, r18
    1992:	0a c0       	rjmp	.+20     	; 0x19a8 <xQueueReceiveFromISR+0xa2>
    1994:	8a 81       	ldd	r24, Y+2	; 0x02
    1996:	9b 81       	ldd	r25, Y+3	; 0x03
    1998:	fc 01       	movw	r30, r24
    199a:	85 8d       	ldd	r24, Z+29	; 0x1d
    199c:	8f 5f       	subi	r24, 0xFF	; 255
    199e:	28 2f       	mov	r18, r24
    19a0:	8a 81       	ldd	r24, Y+2	; 0x02
    19a2:	9b 81       	ldd	r25, Y+3	; 0x03
    19a4:	fc 01       	movw	r30, r24
    19a6:	25 8f       	std	Z+29, r18	; 0x1d
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	89 83       	std	Y+1, r24	; 0x01
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <xQueueReceiveFromISR+0xaa>
    19ae:	19 82       	std	Y+1, r1	; 0x01
    19b0:	89 81       	ldd	r24, Y+1	; 0x01
    19b2:	2a 96       	adiw	r28, 0x0a	; 10
    19b4:	0f b6       	in	r0, 0x3f	; 63
    19b6:	f8 94       	cli
    19b8:	de bf       	out	0x3e, r29	; 62
    19ba:	0f be       	out	0x3f, r0	; 63
    19bc:	cd bf       	out	0x3d, r28	; 61
    19be:	df 91       	pop	r29
    19c0:	cf 91       	pop	r28
    19c2:	08 95       	ret

000019c4 <prvCopyDataToQueue>:
    19c4:	cf 93       	push	r28
    19c6:	df 93       	push	r29
    19c8:	00 d0       	rcall	.+0      	; 0x19ca <prvCopyDataToQueue+0x6>
    19ca:	00 d0       	rcall	.+0      	; 0x19cc <prvCopyDataToQueue+0x8>
    19cc:	cd b7       	in	r28, 0x3d	; 61
    19ce:	de b7       	in	r29, 0x3e	; 62
    19d0:	9b 83       	std	Y+3, r25	; 0x03
    19d2:	8a 83       	std	Y+2, r24	; 0x02
    19d4:	7d 83       	std	Y+5, r23	; 0x05
    19d6:	6c 83       	std	Y+4, r22	; 0x04
    19d8:	4e 83       	std	Y+6, r20	; 0x06
    19da:	19 82       	std	Y+1, r1	; 0x01
    19dc:	8a 81       	ldd	r24, Y+2	; 0x02
    19de:	9b 81       	ldd	r25, Y+3	; 0x03
    19e0:	fc 01       	movw	r30, r24
    19e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19e4:	88 23       	and	r24, r24
    19e6:	09 f4       	brne	.+2      	; 0x19ea <prvCopyDataToQueue+0x26>
    19e8:	98 c0       	rjmp	.+304    	; 0x1b1a <prvCopyDataToQueue+0x156>
    19ea:	8e 81       	ldd	r24, Y+6	; 0x06
    19ec:	88 23       	and	r24, r24
    19ee:	d9 f5       	brne	.+118    	; 0x1a66 <prvCopyDataToQueue+0xa2>
    19f0:	8a 81       	ldd	r24, Y+2	; 0x02
    19f2:	9b 81       	ldd	r25, Y+3	; 0x03
    19f4:	fc 01       	movw	r30, r24
    19f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    19f8:	48 2f       	mov	r20, r24
    19fa:	50 e0       	ldi	r21, 0x00	; 0
    19fc:	8a 81       	ldd	r24, Y+2	; 0x02
    19fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1a00:	fc 01       	movw	r30, r24
    1a02:	84 81       	ldd	r24, Z+4	; 0x04
    1a04:	95 81       	ldd	r25, Z+5	; 0x05
    1a06:	2c 81       	ldd	r18, Y+4	; 0x04
    1a08:	3d 81       	ldd	r19, Y+5	; 0x05
    1a0a:	b9 01       	movw	r22, r18
    1a0c:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <memcpy>
    1a10:	8a 81       	ldd	r24, Y+2	; 0x02
    1a12:	9b 81       	ldd	r25, Y+3	; 0x03
    1a14:	fc 01       	movw	r30, r24
    1a16:	24 81       	ldd	r18, Z+4	; 0x04
    1a18:	35 81       	ldd	r19, Z+5	; 0x05
    1a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a1e:	fc 01       	movw	r30, r24
    1a20:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a22:	88 2f       	mov	r24, r24
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	28 0f       	add	r18, r24
    1a28:	39 1f       	adc	r19, r25
    1a2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a2c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a2e:	fc 01       	movw	r30, r24
    1a30:	35 83       	std	Z+5, r19	; 0x05
    1a32:	24 83       	std	Z+4, r18	; 0x04
    1a34:	8a 81       	ldd	r24, Y+2	; 0x02
    1a36:	9b 81       	ldd	r25, Y+3	; 0x03
    1a38:	fc 01       	movw	r30, r24
    1a3a:	24 81       	ldd	r18, Z+4	; 0x04
    1a3c:	35 81       	ldd	r19, Z+5	; 0x05
    1a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a40:	9b 81       	ldd	r25, Y+3	; 0x03
    1a42:	fc 01       	movw	r30, r24
    1a44:	82 81       	ldd	r24, Z+2	; 0x02
    1a46:	93 81       	ldd	r25, Z+3	; 0x03
    1a48:	28 17       	cp	r18, r24
    1a4a:	39 07       	cpc	r19, r25
    1a4c:	08 f4       	brcc	.+2      	; 0x1a50 <prvCopyDataToQueue+0x8c>
    1a4e:	65 c0       	rjmp	.+202    	; 0x1b1a <prvCopyDataToQueue+0x156>
    1a50:	8a 81       	ldd	r24, Y+2	; 0x02
    1a52:	9b 81       	ldd	r25, Y+3	; 0x03
    1a54:	fc 01       	movw	r30, r24
    1a56:	20 81       	ld	r18, Z
    1a58:	31 81       	ldd	r19, Z+1	; 0x01
    1a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a5e:	fc 01       	movw	r30, r24
    1a60:	35 83       	std	Z+5, r19	; 0x05
    1a62:	24 83       	std	Z+4, r18	; 0x04
    1a64:	5a c0       	rjmp	.+180    	; 0x1b1a <prvCopyDataToQueue+0x156>
    1a66:	8a 81       	ldd	r24, Y+2	; 0x02
    1a68:	9b 81       	ldd	r25, Y+3	; 0x03
    1a6a:	fc 01       	movw	r30, r24
    1a6c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a6e:	48 2f       	mov	r20, r24
    1a70:	50 e0       	ldi	r21, 0x00	; 0
    1a72:	8a 81       	ldd	r24, Y+2	; 0x02
    1a74:	9b 81       	ldd	r25, Y+3	; 0x03
    1a76:	fc 01       	movw	r30, r24
    1a78:	86 81       	ldd	r24, Z+6	; 0x06
    1a7a:	97 81       	ldd	r25, Z+7	; 0x07
    1a7c:	2c 81       	ldd	r18, Y+4	; 0x04
    1a7e:	3d 81       	ldd	r19, Y+5	; 0x05
    1a80:	b9 01       	movw	r22, r18
    1a82:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <memcpy>
    1a86:	8a 81       	ldd	r24, Y+2	; 0x02
    1a88:	9b 81       	ldd	r25, Y+3	; 0x03
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	26 81       	ldd	r18, Z+6	; 0x06
    1a8e:	37 81       	ldd	r19, Z+7	; 0x07
    1a90:	8a 81       	ldd	r24, Y+2	; 0x02
    1a92:	9b 81       	ldd	r25, Y+3	; 0x03
    1a94:	fc 01       	movw	r30, r24
    1a96:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a98:	88 2f       	mov	r24, r24
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	91 95       	neg	r25
    1a9e:	81 95       	neg	r24
    1aa0:	91 09       	sbc	r25, r1
    1aa2:	28 0f       	add	r18, r24
    1aa4:	39 1f       	adc	r19, r25
    1aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aaa:	fc 01       	movw	r30, r24
    1aac:	37 83       	std	Z+7, r19	; 0x07
    1aae:	26 83       	std	Z+6, r18	; 0x06
    1ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab4:	fc 01       	movw	r30, r24
    1ab6:	26 81       	ldd	r18, Z+6	; 0x06
    1ab8:	37 81       	ldd	r19, Z+7	; 0x07
    1aba:	8a 81       	ldd	r24, Y+2	; 0x02
    1abc:	9b 81       	ldd	r25, Y+3	; 0x03
    1abe:	fc 01       	movw	r30, r24
    1ac0:	80 81       	ld	r24, Z
    1ac2:	91 81       	ldd	r25, Z+1	; 0x01
    1ac4:	28 17       	cp	r18, r24
    1ac6:	39 07       	cpc	r19, r25
    1ac8:	a8 f4       	brcc	.+42     	; 0x1af4 <prvCopyDataToQueue+0x130>
    1aca:	8a 81       	ldd	r24, Y+2	; 0x02
    1acc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ace:	fc 01       	movw	r30, r24
    1ad0:	22 81       	ldd	r18, Z+2	; 0x02
    1ad2:	33 81       	ldd	r19, Z+3	; 0x03
    1ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad8:	fc 01       	movw	r30, r24
    1ada:	84 8d       	ldd	r24, Z+28	; 0x1c
    1adc:	88 2f       	mov	r24, r24
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	91 95       	neg	r25
    1ae2:	81 95       	neg	r24
    1ae4:	91 09       	sbc	r25, r1
    1ae6:	28 0f       	add	r18, r24
    1ae8:	39 1f       	adc	r19, r25
    1aea:	8a 81       	ldd	r24, Y+2	; 0x02
    1aec:	9b 81       	ldd	r25, Y+3	; 0x03
    1aee:	fc 01       	movw	r30, r24
    1af0:	37 83       	std	Z+7, r19	; 0x07
    1af2:	26 83       	std	Z+6, r18	; 0x06
    1af4:	8e 81       	ldd	r24, Y+6	; 0x06
    1af6:	82 30       	cpi	r24, 0x02	; 2
    1af8:	81 f4       	brne	.+32     	; 0x1b1a <prvCopyDataToQueue+0x156>
    1afa:	8a 81       	ldd	r24, Y+2	; 0x02
    1afc:	9b 81       	ldd	r25, Y+3	; 0x03
    1afe:	fc 01       	movw	r30, r24
    1b00:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b02:	88 23       	and	r24, r24
    1b04:	51 f0       	breq	.+20     	; 0x1b1a <prvCopyDataToQueue+0x156>
    1b06:	8a 81       	ldd	r24, Y+2	; 0x02
    1b08:	9b 81       	ldd	r25, Y+3	; 0x03
    1b0a:	fc 01       	movw	r30, r24
    1b0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b0e:	2f ef       	ldi	r18, 0xFF	; 255
    1b10:	28 0f       	add	r18, r24
    1b12:	8a 81       	ldd	r24, Y+2	; 0x02
    1b14:	9b 81       	ldd	r25, Y+3	; 0x03
    1b16:	fc 01       	movw	r30, r24
    1b18:	22 8f       	std	Z+26, r18	; 0x1a
    1b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b1c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b1e:	fc 01       	movw	r30, r24
    1b20:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b22:	21 e0       	ldi	r18, 0x01	; 1
    1b24:	28 0f       	add	r18, r24
    1b26:	8a 81       	ldd	r24, Y+2	; 0x02
    1b28:	9b 81       	ldd	r25, Y+3	; 0x03
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	22 8f       	std	Z+26, r18	; 0x1a
    1b2e:	89 81       	ldd	r24, Y+1	; 0x01
    1b30:	26 96       	adiw	r28, 0x06	; 6
    1b32:	0f b6       	in	r0, 0x3f	; 63
    1b34:	f8 94       	cli
    1b36:	de bf       	out	0x3e, r29	; 62
    1b38:	0f be       	out	0x3f, r0	; 63
    1b3a:	cd bf       	out	0x3d, r28	; 61
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	08 95       	ret

00001b42 <prvCopyDataFromQueue>:
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	00 d0       	rcall	.+0      	; 0x1b48 <prvCopyDataFromQueue+0x6>
    1b48:	1f 92       	push	r1
    1b4a:	cd b7       	in	r28, 0x3d	; 61
    1b4c:	de b7       	in	r29, 0x3e	; 62
    1b4e:	9a 83       	std	Y+2, r25	; 0x02
    1b50:	89 83       	std	Y+1, r24	; 0x01
    1b52:	7c 83       	std	Y+4, r23	; 0x04
    1b54:	6b 83       	std	Y+3, r22	; 0x03
    1b56:	89 81       	ldd	r24, Y+1	; 0x01
    1b58:	9a 81       	ldd	r25, Y+2	; 0x02
    1b5a:	fc 01       	movw	r30, r24
    1b5c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b5e:	88 23       	and	r24, r24
    1b60:	c9 f1       	breq	.+114    	; 0x1bd4 <prvCopyDataFromQueue+0x92>
    1b62:	89 81       	ldd	r24, Y+1	; 0x01
    1b64:	9a 81       	ldd	r25, Y+2	; 0x02
    1b66:	fc 01       	movw	r30, r24
    1b68:	26 81       	ldd	r18, Z+6	; 0x06
    1b6a:	37 81       	ldd	r19, Z+7	; 0x07
    1b6c:	89 81       	ldd	r24, Y+1	; 0x01
    1b6e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b70:	fc 01       	movw	r30, r24
    1b72:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b74:	88 2f       	mov	r24, r24
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	28 0f       	add	r18, r24
    1b7a:	39 1f       	adc	r19, r25
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	fc 01       	movw	r30, r24
    1b82:	37 83       	std	Z+7, r19	; 0x07
    1b84:	26 83       	std	Z+6, r18	; 0x06
    1b86:	89 81       	ldd	r24, Y+1	; 0x01
    1b88:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	26 81       	ldd	r18, Z+6	; 0x06
    1b8e:	37 81       	ldd	r19, Z+7	; 0x07
    1b90:	89 81       	ldd	r24, Y+1	; 0x01
    1b92:	9a 81       	ldd	r25, Y+2	; 0x02
    1b94:	fc 01       	movw	r30, r24
    1b96:	82 81       	ldd	r24, Z+2	; 0x02
    1b98:	93 81       	ldd	r25, Z+3	; 0x03
    1b9a:	28 17       	cp	r18, r24
    1b9c:	39 07       	cpc	r19, r25
    1b9e:	50 f0       	brcs	.+20     	; 0x1bb4 <prvCopyDataFromQueue+0x72>
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
    1ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	20 81       	ld	r18, Z
    1ba8:	31 81       	ldd	r19, Z+1	; 0x01
    1baa:	89 81       	ldd	r24, Y+1	; 0x01
    1bac:	9a 81       	ldd	r25, Y+2	; 0x02
    1bae:	fc 01       	movw	r30, r24
    1bb0:	37 83       	std	Z+7, r19	; 0x07
    1bb2:	26 83       	std	Z+6, r18	; 0x06
    1bb4:	89 81       	ldd	r24, Y+1	; 0x01
    1bb6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb8:	fc 01       	movw	r30, r24
    1bba:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bbc:	48 2f       	mov	r20, r24
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	89 81       	ldd	r24, Y+1	; 0x01
    1bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	26 81       	ldd	r18, Z+6	; 0x06
    1bc8:	37 81       	ldd	r19, Z+7	; 0x07
    1bca:	8b 81       	ldd	r24, Y+3	; 0x03
    1bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bce:	b9 01       	movw	r22, r18
    1bd0:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <memcpy>
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	0f 90       	pop	r0
    1bda:	0f 90       	pop	r0
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	08 95       	ret

00001be2 <prvUnlockQueue>:
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	1f 92       	push	r1
    1be8:	1f 92       	push	r1
    1bea:	cd b7       	in	r28, 0x3d	; 61
    1bec:	de b7       	in	r29, 0x3e	; 62
    1bee:	9a 83       	std	Y+2, r25	; 0x02
    1bf0:	89 83       	std	Y+1, r24	; 0x01
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	0f 92       	push	r0
    1bf8:	19 c0       	rjmp	.+50     	; 0x1c2c <prvUnlockQueue+0x4a>
    1bfa:	89 81       	ldd	r24, Y+1	; 0x01
    1bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfe:	fc 01       	movw	r30, r24
    1c00:	81 89       	ldd	r24, Z+17	; 0x11
    1c02:	88 23       	and	r24, r24
    1c04:	41 f0       	breq	.+16     	; 0x1c16 <prvUnlockQueue+0x34>
    1c06:	89 81       	ldd	r24, Y+1	; 0x01
    1c08:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0a:	41 96       	adiw	r24, 0x11	; 17
    1c0c:	18 d5       	rcall	.+2608   	; 0x263e <xTaskRemoveFromEventList>
    1c0e:	88 23       	and	r24, r24
    1c10:	19 f0       	breq	.+6      	; 0x1c18 <prvUnlockQueue+0x36>
    1c12:	0e d6       	rcall	.+3100   	; 0x2830 <vTaskMissedYield>
    1c14:	01 c0       	rjmp	.+2      	; 0x1c18 <prvUnlockQueue+0x36>
    1c16:	10 c0       	rjmp	.+32     	; 0x1c38 <prvUnlockQueue+0x56>
    1c18:	89 81       	ldd	r24, Y+1	; 0x01
    1c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1c:	fc 01       	movw	r30, r24
    1c1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c20:	81 50       	subi	r24, 0x01	; 1
    1c22:	28 2f       	mov	r18, r24
    1c24:	89 81       	ldd	r24, Y+1	; 0x01
    1c26:	9a 81       	ldd	r25, Y+2	; 0x02
    1c28:	fc 01       	movw	r30, r24
    1c2a:	26 8f       	std	Z+30, r18	; 0x1e
    1c2c:	89 81       	ldd	r24, Y+1	; 0x01
    1c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c30:	fc 01       	movw	r30, r24
    1c32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c34:	18 16       	cp	r1, r24
    1c36:	0c f3       	brlt	.-62     	; 0x1bfa <prvUnlockQueue+0x18>
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3c:	2f ef       	ldi	r18, 0xFF	; 255
    1c3e:	fc 01       	movw	r30, r24
    1c40:	26 8f       	std	Z+30, r18	; 0x1e
    1c42:	0f 90       	pop	r0
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	0f b6       	in	r0, 0x3f	; 63
    1c48:	f8 94       	cli
    1c4a:	0f 92       	push	r0
    1c4c:	19 c0       	rjmp	.+50     	; 0x1c80 <prvUnlockQueue+0x9e>
    1c4e:	89 81       	ldd	r24, Y+1	; 0x01
    1c50:	9a 81       	ldd	r25, Y+2	; 0x02
    1c52:	fc 01       	movw	r30, r24
    1c54:	80 85       	ldd	r24, Z+8	; 0x08
    1c56:	88 23       	and	r24, r24
    1c58:	91 f0       	breq	.+36     	; 0x1c7e <prvUnlockQueue+0x9c>
    1c5a:	89 81       	ldd	r24, Y+1	; 0x01
    1c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5e:	08 96       	adiw	r24, 0x08	; 8
    1c60:	ee d4       	rcall	.+2524   	; 0x263e <xTaskRemoveFromEventList>
    1c62:	88 23       	and	r24, r24
    1c64:	09 f0       	breq	.+2      	; 0x1c68 <prvUnlockQueue+0x86>
    1c66:	e4 d5       	rcall	.+3016   	; 0x2830 <vTaskMissedYield>
    1c68:	89 81       	ldd	r24, Y+1	; 0x01
    1c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c70:	81 50       	subi	r24, 0x01	; 1
    1c72:	28 2f       	mov	r18, r24
    1c74:	89 81       	ldd	r24, Y+1	; 0x01
    1c76:	9a 81       	ldd	r25, Y+2	; 0x02
    1c78:	fc 01       	movw	r30, r24
    1c7a:	25 8f       	std	Z+29, r18	; 0x1d
    1c7c:	01 c0       	rjmp	.+2      	; 0x1c80 <prvUnlockQueue+0x9e>
    1c7e:	06 c0       	rjmp	.+12     	; 0x1c8c <prvUnlockQueue+0xaa>
    1c80:	89 81       	ldd	r24, Y+1	; 0x01
    1c82:	9a 81       	ldd	r25, Y+2	; 0x02
    1c84:	fc 01       	movw	r30, r24
    1c86:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c88:	18 16       	cp	r1, r24
    1c8a:	0c f3       	brlt	.-62     	; 0x1c4e <prvUnlockQueue+0x6c>
    1c8c:	89 81       	ldd	r24, Y+1	; 0x01
    1c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c90:	2f ef       	ldi	r18, 0xFF	; 255
    1c92:	fc 01       	movw	r30, r24
    1c94:	25 8f       	std	Z+29, r18	; 0x1d
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	0f 90       	pop	r0
    1c9c:	0f 90       	pop	r0
    1c9e:	df 91       	pop	r29
    1ca0:	cf 91       	pop	r28
    1ca2:	08 95       	ret

00001ca4 <prvIsQueueEmpty>:
    1ca4:	cf 93       	push	r28
    1ca6:	df 93       	push	r29
    1ca8:	00 d0       	rcall	.+0      	; 0x1caa <prvIsQueueEmpty+0x6>
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	9b 83       	std	Y+3, r25	; 0x03
    1cb0:	8a 83       	std	Y+2, r24	; 0x02
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
    1cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cba:	9b 81       	ldd	r25, Y+3	; 0x03
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc0:	88 23       	and	r24, r24
    1cc2:	19 f4       	brne	.+6      	; 0x1cca <prvIsQueueEmpty+0x26>
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	89 83       	std	Y+1, r24	; 0x01
    1cc8:	01 c0       	rjmp	.+2      	; 0x1ccc <prvIsQueueEmpty+0x28>
    1cca:	19 82       	std	Y+1, r1	; 0x01
    1ccc:	0f 90       	pop	r0
    1cce:	0f be       	out	0x3f, r0	; 63
    1cd0:	89 81       	ldd	r24, Y+1	; 0x01
    1cd2:	0f 90       	pop	r0
    1cd4:	0f 90       	pop	r0
    1cd6:	0f 90       	pop	r0
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	08 95       	ret

00001cde <prvIsQueueFull>:
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <prvIsQueueFull+0x6>
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	9b 83       	std	Y+3, r25	; 0x03
    1cea:	8a 83       	std	Y+2, r24	; 0x02
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	0f 92       	push	r0
    1cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf4:	9b 81       	ldd	r25, Y+3	; 0x03
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    1cfe:	fc 01       	movw	r30, r24
    1d00:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d02:	28 17       	cp	r18, r24
    1d04:	19 f4       	brne	.+6      	; 0x1d0c <prvIsQueueFull+0x2e>
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	89 83       	std	Y+1, r24	; 0x01
    1d0a:	01 c0       	rjmp	.+2      	; 0x1d0e <prvIsQueueFull+0x30>
    1d0c:	19 82       	std	Y+1, r1	; 0x01
    1d0e:	0f 90       	pop	r0
    1d10:	0f be       	out	0x3f, r0	; 63
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	0f 90       	pop	r0
    1d16:	0f 90       	pop	r0
    1d18:	0f 90       	pop	r0
    1d1a:	df 91       	pop	r29
    1d1c:	cf 91       	pop	r28
    1d1e:	08 95       	ret

00001d20 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	00 d0       	rcall	.+0      	; 0x1d26 <vQueueWaitForMessageRestricted+0x6>
    1d26:	00 d0       	rcall	.+0      	; 0x1d28 <vQueueWaitForMessageRestricted+0x8>
    1d28:	cd b7       	in	r28, 0x3d	; 61
    1d2a:	de b7       	in	r29, 0x3e	; 62
    1d2c:	9c 83       	std	Y+4, r25	; 0x04
    1d2e:	8b 83       	std	Y+3, r24	; 0x03
    1d30:	7e 83       	std	Y+6, r23	; 0x06
    1d32:	6d 83       	std	Y+5, r22	; 0x05
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d34:	8b 81       	ldd	r24, Y+3	; 0x03
    1d36:	9c 81       	ldd	r25, Y+4	; 0x04
    1d38:	9a 83       	std	Y+2, r25	; 0x02
    1d3a:	89 83       	std	Y+1, r24	; 0x01
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1d3c:	0f b6       	in	r0, 0x3f	; 63
    1d3e:	f8 94       	cli
    1d40:	0f 92       	push	r0
    1d42:	89 81       	ldd	r24, Y+1	; 0x01
    1d44:	9a 81       	ldd	r25, Y+2	; 0x02
    1d46:	fc 01       	movw	r30, r24
    1d48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4c:	21 f4       	brne	.+8      	; 0x1d56 <vQueueWaitForMessageRestricted+0x36>
    1d4e:	89 81       	ldd	r24, Y+1	; 0x01
    1d50:	9a 81       	ldd	r25, Y+2	; 0x02
    1d52:	fc 01       	movw	r30, r24
    1d54:	15 8e       	std	Z+29, r1	; 0x1d
    1d56:	89 81       	ldd	r24, Y+1	; 0x01
    1d58:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5a:	fc 01       	movw	r30, r24
    1d5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d60:	21 f4       	brne	.+8      	; 0x1d6a <vQueueWaitForMessageRestricted+0x4a>
    1d62:	89 81       	ldd	r24, Y+1	; 0x01
    1d64:	9a 81       	ldd	r25, Y+2	; 0x02
    1d66:	fc 01       	movw	r30, r24
    1d68:	16 8e       	std	Z+30, r1	; 0x1e
    1d6a:	0f 90       	pop	r0
    1d6c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1d6e:	89 81       	ldd	r24, Y+1	; 0x01
    1d70:	9a 81       	ldd	r25, Y+2	; 0x02
    1d72:	fc 01       	movw	r30, r24
    1d74:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d76:	88 23       	and	r24, r24
    1d78:	39 f4       	brne	.+14     	; 0x1d88 <vQueueWaitForMessageRestricted+0x68>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d7a:	89 81       	ldd	r24, Y+1	; 0x01
    1d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d7e:	41 96       	adiw	r24, 0x11	; 17
    1d80:	2d 81       	ldd	r18, Y+5	; 0x05
    1d82:	3e 81       	ldd	r19, Y+6	; 0x06
    1d84:	b9 01       	movw	r22, r18
    1d86:	28 d4       	rcall	.+2128   	; 0x25d8 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1d88:	89 81       	ldd	r24, Y+1	; 0x01
    1d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8c:	2a df       	rcall	.-428    	; 0x1be2 <prvUnlockQueue>
	}
    1d8e:	26 96       	adiw	r28, 0x06	; 6
    1d90:	0f b6       	in	r0, 0x3f	; 63
    1d92:	f8 94       	cli
    1d94:	de bf       	out	0x3e, r29	; 62
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	cd bf       	out	0x3d, r28	; 61
    1d9a:	df 91       	pop	r29
    1d9c:	cf 91       	pop	r28
    1d9e:	08 95       	ret

00001da0 <xTaskGenericCreate>:
    1da0:	af 92       	push	r10
    1da2:	bf 92       	push	r11
    1da4:	cf 92       	push	r12
    1da6:	df 92       	push	r13
    1da8:	ef 92       	push	r14
    1daa:	ff 92       	push	r15
    1dac:	0f 93       	push	r16
    1dae:	1f 93       	push	r17
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	cd b7       	in	r28, 0x3d	; 61
    1db6:	de b7       	in	r29, 0x3e	; 62
    1db8:	64 97       	sbiw	r28, 0x14	; 20
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	f8 94       	cli
    1dbe:	de bf       	out	0x3e, r29	; 62
    1dc0:	0f be       	out	0x3f, r0	; 63
    1dc2:	cd bf       	out	0x3d, r28	; 61
    1dc4:	9f 83       	std	Y+7, r25	; 0x07
    1dc6:	8e 83       	std	Y+6, r24	; 0x06
    1dc8:	79 87       	std	Y+9, r23	; 0x09
    1dca:	68 87       	std	Y+8, r22	; 0x08
    1dcc:	5b 87       	std	Y+11, r21	; 0x0b
    1dce:	4a 87       	std	Y+10, r20	; 0x0a
    1dd0:	3d 87       	std	Y+13, r19	; 0x0d
    1dd2:	2c 87       	std	Y+12, r18	; 0x0c
    1dd4:	0e 87       	std	Y+14, r16	; 0x0e
    1dd6:	f8 8a       	std	Y+16, r15	; 0x10
    1dd8:	ef 86       	std	Y+15, r14	; 0x0f
    1dda:	da 8a       	std	Y+18, r13	; 0x12
    1ddc:	c9 8a       	std	Y+17, r12	; 0x11
    1dde:	bc 8a       	std	Y+20, r11	; 0x14
    1de0:	ab 8a       	std	Y+19, r10	; 0x13
    1de2:	29 89       	ldd	r18, Y+17	; 0x11
    1de4:	3a 89       	ldd	r19, Y+18	; 0x12
    1de6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1de8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dea:	b9 01       	movw	r22, r18
    1dec:	77 d6       	rcall	.+3310   	; 0x2adc <prvAllocateTCBAndStack>
    1dee:	9b 83       	std	Y+3, r25	; 0x03
    1df0:	8a 83       	std	Y+2, r24	; 0x02
    1df2:	8a 81       	ldd	r24, Y+2	; 0x02
    1df4:	9b 81       	ldd	r25, Y+3	; 0x03
    1df6:	89 2b       	or	r24, r25
    1df8:	09 f4       	brne	.+2      	; 0x1dfc <xTaskGenericCreate+0x5c>
    1dfa:	8f c0       	rjmp	.+286    	; 0x1f1a <xTaskGenericCreate+0x17a>
    1dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dfe:	9b 81       	ldd	r25, Y+3	; 0x03
    1e00:	fc 01       	movw	r30, r24
    1e02:	27 89       	ldd	r18, Z+23	; 0x17
    1e04:	30 8d       	ldd	r19, Z+24	; 0x18
    1e06:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e08:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e0a:	01 97       	sbiw	r24, 0x01	; 1
    1e0c:	82 0f       	add	r24, r18
    1e0e:	93 1f       	adc	r25, r19
    1e10:	9d 83       	std	Y+5, r25	; 0x05
    1e12:	8c 83       	std	Y+4, r24	; 0x04
    1e14:	4a 85       	ldd	r20, Y+10	; 0x0a
    1e16:	5b 85       	ldd	r21, Y+11	; 0x0b
    1e18:	2b 89       	ldd	r18, Y+19	; 0x13
    1e1a:	3c 89       	ldd	r19, Y+20	; 0x14
    1e1c:	68 85       	ldd	r22, Y+8	; 0x08
    1e1e:	79 85       	ldd	r23, Y+9	; 0x09
    1e20:	8a 81       	ldd	r24, Y+2	; 0x02
    1e22:	9b 81       	ldd	r25, Y+3	; 0x03
    1e24:	8a 01       	movw	r16, r20
    1e26:	4e 85       	ldd	r20, Y+14	; 0x0e
    1e28:	0d d5       	rcall	.+2586   	; 0x2844 <prvInitialiseTCBVariables>
    1e2a:	4c 85       	ldd	r20, Y+12	; 0x0c
    1e2c:	5d 85       	ldd	r21, Y+13	; 0x0d
    1e2e:	2e 81       	ldd	r18, Y+6	; 0x06
    1e30:	3f 81       	ldd	r19, Y+7	; 0x07
    1e32:	8c 81       	ldd	r24, Y+4	; 0x04
    1e34:	9d 81       	ldd	r25, Y+5	; 0x05
    1e36:	b9 01       	movw	r22, r18
    1e38:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <pxPortInitialiseStack>
    1e3c:	9c 01       	movw	r18, r24
    1e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e40:	9b 81       	ldd	r25, Y+3	; 0x03
    1e42:	fc 01       	movw	r30, r24
    1e44:	31 83       	std	Z+1, r19	; 0x01
    1e46:	20 83       	st	Z, r18
    1e48:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e4a:	98 89       	ldd	r25, Y+16	; 0x10
    1e4c:	89 2b       	or	r24, r25
    1e4e:	39 f0       	breq	.+14     	; 0x1e5e <xTaskGenericCreate+0xbe>
    1e50:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e52:	98 89       	ldd	r25, Y+16	; 0x10
    1e54:	2a 81       	ldd	r18, Y+2	; 0x02
    1e56:	3b 81       	ldd	r19, Y+3	; 0x03
    1e58:	fc 01       	movw	r30, r24
    1e5a:	31 83       	std	Z+1, r19	; 0x01
    1e5c:	20 83       	st	Z, r18
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	f8 94       	cli
    1e62:	0f 92       	push	r0
    1e64:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <uxCurrentNumberOfTasks>
    1e68:	8f 5f       	subi	r24, 0xFF	; 255
    1e6a:	80 93 82 0c 	sts	0x0C82, r24	; 0x800c82 <uxCurrentNumberOfTasks>
    1e6e:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1e72:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1e76:	89 2b       	or	r24, r25
    1e78:	61 f4       	brne	.+24     	; 0x1e92 <xTaskGenericCreate+0xf2>
    1e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e7c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e7e:	90 93 2b 0c 	sts	0x0C2B, r25	; 0x800c2b <pxCurrentTCB+0x1>
    1e82:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <pxCurrentTCB>
    1e86:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <uxCurrentNumberOfTasks>
    1e8a:	81 30       	cpi	r24, 0x01	; 1
    1e8c:	a9 f4       	brne	.+42     	; 0x1eb8 <xTaskGenericCreate+0x118>
    1e8e:	5e d5       	rcall	.+2748   	; 0x294c <prvInitialiseTaskLists>
    1e90:	13 c0       	rjmp	.+38     	; 0x1eb8 <xTaskGenericCreate+0x118>
    1e92:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <xSchedulerRunning>
    1e96:	88 23       	and	r24, r24
    1e98:	79 f4       	brne	.+30     	; 0x1eb8 <xTaskGenericCreate+0x118>
    1e9a:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1e9e:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	96 89       	ldd	r25, Z+22	; 0x16
    1ea6:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ea8:	89 17       	cp	r24, r25
    1eaa:	30 f0       	brcs	.+12     	; 0x1eb8 <xTaskGenericCreate+0x118>
    1eac:	8a 81       	ldd	r24, Y+2	; 0x02
    1eae:	9b 81       	ldd	r25, Y+3	; 0x03
    1eb0:	90 93 2b 0c 	sts	0x0C2B, r25	; 0x800c2b <pxCurrentTCB+0x1>
    1eb4:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <pxCurrentTCB>
    1eb8:	80 91 8a 0c 	lds	r24, 0x0C8A	; 0x800c8a <uxTaskNumber>
    1ebc:	8f 5f       	subi	r24, 0xFF	; 255
    1ebe:	80 93 8a 0c 	sts	0x0C8A, r24	; 0x800c8a <uxTaskNumber>
    1ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec6:	fc 01       	movw	r30, r24
    1ec8:	96 89       	ldd	r25, Z+22	; 0x16
    1eca:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    1ece:	89 17       	cp	r24, r25
    1ed0:	30 f4       	brcc	.+12     	; 0x1ede <xTaskGenericCreate+0x13e>
    1ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ed6:	fc 01       	movw	r30, r24
    1ed8:	86 89       	ldd	r24, Z+22	; 0x16
    1eda:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <uxTopReadyPriority>
    1ede:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee2:	ac 01       	movw	r20, r24
    1ee4:	4e 5f       	subi	r20, 0xFE	; 254
    1ee6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eea:	9b 81       	ldd	r25, Y+3	; 0x03
    1eec:	fc 01       	movw	r30, r24
    1eee:	86 89       	ldd	r24, Z+22	; 0x16
    1ef0:	28 2f       	mov	r18, r24
    1ef2:	30 e0       	ldi	r19, 0x00	; 0
    1ef4:	c9 01       	movw	r24, r18
    1ef6:	88 0f       	add	r24, r24
    1ef8:	99 1f       	adc	r25, r25
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	88 0f       	add	r24, r24
    1f00:	99 1f       	adc	r25, r25
    1f02:	82 0f       	add	r24, r18
    1f04:	93 1f       	adc	r25, r19
    1f06:	84 5d       	subi	r24, 0xD4	; 212
    1f08:	93 4f       	sbci	r25, 0xF3	; 243
    1f0a:	ba 01       	movw	r22, r20
    1f0c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	89 83       	std	Y+1, r24	; 0x01
    1f14:	0f 90       	pop	r0
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	02 c0       	rjmp	.+4      	; 0x1f1e <xTaskGenericCreate+0x17e>
    1f1a:	8f ef       	ldi	r24, 0xFF	; 255
    1f1c:	89 83       	std	Y+1, r24	; 0x01
    1f1e:	89 81       	ldd	r24, Y+1	; 0x01
    1f20:	81 30       	cpi	r24, 0x01	; 1
    1f22:	71 f4       	brne	.+28     	; 0x1f40 <xTaskGenericCreate+0x1a0>
    1f24:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <xSchedulerRunning>
    1f28:	88 23       	and	r24, r24
    1f2a:	51 f0       	breq	.+20     	; 0x1f40 <xTaskGenericCreate+0x1a0>
    1f2c:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1f30:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1f34:	fc 01       	movw	r30, r24
    1f36:	96 89       	ldd	r25, Z+22	; 0x16
    1f38:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f3a:	98 17       	cp	r25, r24
    1f3c:	08 f4       	brcc	.+2      	; 0x1f40 <xTaskGenericCreate+0x1a0>
    1f3e:	54 d8       	rcall	.-3928   	; 0xfe8 <vPortYield>
    1f40:	89 81       	ldd	r24, Y+1	; 0x01
    1f42:	64 96       	adiw	r28, 0x14	; 20
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	f8 94       	cli
    1f48:	de bf       	out	0x3e, r29	; 62
    1f4a:	0f be       	out	0x3f, r0	; 63
    1f4c:	cd bf       	out	0x3d, r28	; 61
    1f4e:	df 91       	pop	r29
    1f50:	cf 91       	pop	r28
    1f52:	1f 91       	pop	r17
    1f54:	0f 91       	pop	r16
    1f56:	ff 90       	pop	r15
    1f58:	ef 90       	pop	r14
    1f5a:	df 90       	pop	r13
    1f5c:	cf 90       	pop	r12
    1f5e:	bf 90       	pop	r11
    1f60:	af 90       	pop	r10
    1f62:	08 95       	ret

00001f64 <vTaskDelay>:
    1f64:	cf 93       	push	r28
    1f66:	df 93       	push	r29
    1f68:	00 d0       	rcall	.+0      	; 0x1f6a <vTaskDelay+0x6>
    1f6a:	1f 92       	push	r1
    1f6c:	1f 92       	push	r1
    1f6e:	cd b7       	in	r28, 0x3d	; 61
    1f70:	de b7       	in	r29, 0x3e	; 62
    1f72:	9d 83       	std	Y+5, r25	; 0x05
    1f74:	8c 83       	std	Y+4, r24	; 0x04
    1f76:	19 82       	std	Y+1, r1	; 0x01
    1f78:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7c:	89 2b       	or	r24, r25
    1f7e:	b9 f0       	breq	.+46     	; 0x1fae <vTaskDelay+0x4a>
    1f80:	be d0       	rcall	.+380    	; 0x20fe <vTaskSuspendAll>
    1f82:	20 91 83 0c 	lds	r18, 0x0C83	; 0x800c83 <xTickCount>
    1f86:	30 91 84 0c 	lds	r19, 0x0C84	; 0x800c84 <xTickCount+0x1>
    1f8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8e:	82 0f       	add	r24, r18
    1f90:	93 1f       	adc	r25, r19
    1f92:	9b 83       	std	Y+3, r25	; 0x03
    1f94:	8a 83       	std	Y+2, r24	; 0x02
    1f96:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1f9a:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1f9e:	02 96       	adiw	r24, 0x02	; 2
    1fa0:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    1fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa8:	4e d5       	rcall	.+2716   	; 0x2a46 <prvAddCurrentTaskToDelayedList>
    1faa:	b5 d0       	rcall	.+362    	; 0x2116 <xTaskResumeAll>
    1fac:	89 83       	std	Y+1, r24	; 0x01
    1fae:	89 81       	ldd	r24, Y+1	; 0x01
    1fb0:	88 23       	and	r24, r24
    1fb2:	09 f4       	brne	.+2      	; 0x1fb6 <vTaskDelay+0x52>
    1fb4:	19 d8       	rcall	.-4046   	; 0xfe8 <vPortYield>
    1fb6:	0f 90       	pop	r0
    1fb8:	0f 90       	pop	r0
    1fba:	0f 90       	pop	r0
    1fbc:	0f 90       	pop	r0
    1fbe:	0f 90       	pop	r0
    1fc0:	df 91       	pop	r29
    1fc2:	cf 91       	pop	r28
    1fc4:	08 95       	ret

00001fc6 <vTaskSuspend>:
    1fc6:	cf 93       	push	r28
    1fc8:	df 93       	push	r29
    1fca:	00 d0       	rcall	.+0      	; 0x1fcc <vTaskSuspend+0x6>
    1fcc:	1f 92       	push	r1
    1fce:	cd b7       	in	r28, 0x3d	; 61
    1fd0:	de b7       	in	r29, 0x3e	; 62
    1fd2:	9c 83       	std	Y+4, r25	; 0x04
    1fd4:	8b 83       	std	Y+3, r24	; 0x03
    1fd6:	0f b6       	in	r0, 0x3f	; 63
    1fd8:	f8 94       	cli
    1fda:	0f 92       	push	r0
    1fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fde:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe0:	89 2b       	or	r24, r25
    1fe2:	29 f4       	brne	.+10     	; 0x1fee <vTaskSuspend+0x28>
    1fe4:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    1fe8:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    1fec:	02 c0       	rjmp	.+4      	; 0x1ff2 <vTaskSuspend+0x2c>
    1fee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff2:	9a 83       	std	Y+2, r25	; 0x02
    1ff4:	89 83       	std	Y+1, r24	; 0x01
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
    1ff8:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffa:	02 96       	adiw	r24, 0x02	; 2
    1ffc:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	9a 81       	ldd	r25, Y+2	; 0x02
    2004:	fc 01       	movw	r30, r24
    2006:	84 89       	ldd	r24, Z+20	; 0x14
    2008:	95 89       	ldd	r25, Z+21	; 0x15
    200a:	89 2b       	or	r24, r25
    200c:	29 f0       	breq	.+10     	; 0x2018 <vTaskSuspend+0x52>
    200e:	89 81       	ldd	r24, Y+1	; 0x01
    2010:	9a 81       	ldd	r25, Y+2	; 0x02
    2012:	0c 96       	adiw	r24, 0x0c	; 12
    2014:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	9a 81       	ldd	r25, Y+2	; 0x02
    201c:	02 96       	adiw	r24, 0x02	; 2
    201e:	bc 01       	movw	r22, r24
    2020:	89 e7       	ldi	r24, 0x79	; 121
    2022:	9c e0       	ldi	r25, 0x0C	; 12
    2024:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    2028:	0f 90       	pop	r0
    202a:	0f be       	out	0x3f, r0	; 63
    202c:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2030:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2034:	29 81       	ldd	r18, Y+1	; 0x01
    2036:	3a 81       	ldd	r19, Y+2	; 0x02
    2038:	28 17       	cp	r18, r24
    203a:	39 07       	cpc	r19, r25
    203c:	a1 f4       	brne	.+40     	; 0x2066 <vTaskSuspend+0xa0>
    203e:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <xSchedulerRunning>
    2042:	88 23       	and	r24, r24
    2044:	19 f0       	breq	.+6      	; 0x204c <vTaskSuspend+0x86>
    2046:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vPortYield>
    204a:	17 c0       	rjmp	.+46     	; 0x207a <vTaskSuspend+0xb4>
    204c:	90 91 79 0c 	lds	r25, 0x0C79	; 0x800c79 <xSuspendedTaskList>
    2050:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <uxCurrentNumberOfTasks>
    2054:	98 17       	cp	r25, r24
    2056:	29 f4       	brne	.+10     	; 0x2062 <vTaskSuspend+0x9c>
    2058:	10 92 2b 0c 	sts	0x0C2B, r1	; 0x800c2b <pxCurrentTCB+0x1>
    205c:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <pxCurrentTCB>
    2060:	0c c0       	rjmp	.+24     	; 0x207a <vTaskSuspend+0xb4>
    2062:	ea d1       	rcall	.+980    	; 0x2438 <vTaskSwitchContext>
    2064:	0a c0       	rjmp	.+20     	; 0x207a <vTaskSuspend+0xb4>
    2066:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <xSchedulerRunning>
    206a:	88 23       	and	r24, r24
    206c:	31 f0       	breq	.+12     	; 0x207a <vTaskSuspend+0xb4>
    206e:	0f b6       	in	r0, 0x3f	; 63
    2070:	f8 94       	cli
    2072:	0f 92       	push	r0
    2074:	8e d5       	rcall	.+2844   	; 0x2b92 <prvResetNextTaskUnblockTime>
    2076:	0f 90       	pop	r0
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	0f 90       	pop	r0
    207c:	0f 90       	pop	r0
    207e:	0f 90       	pop	r0
    2080:	0f 90       	pop	r0
    2082:	df 91       	pop	r29
    2084:	cf 91       	pop	r28
    2086:	08 95       	ret

00002088 <vTaskStartScheduler>:
    2088:	af 92       	push	r10
    208a:	bf 92       	push	r11
    208c:	cf 92       	push	r12
    208e:	df 92       	push	r13
    2090:	ef 92       	push	r14
    2092:	ff 92       	push	r15
    2094:	0f 93       	push	r16
    2096:	cf 93       	push	r28
    2098:	df 93       	push	r29
    209a:	1f 92       	push	r1
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	a1 2c       	mov	r10, r1
    20a2:	b1 2c       	mov	r11, r1
    20a4:	c1 2c       	mov	r12, r1
    20a6:	d1 2c       	mov	r13, r1
    20a8:	e1 2c       	mov	r14, r1
    20aa:	f1 2c       	mov	r15, r1
    20ac:	00 e0       	ldi	r16, 0x00	; 0
    20ae:	20 e0       	ldi	r18, 0x00	; 0
    20b0:	30 e0       	ldi	r19, 0x00	; 0
    20b2:	49 eb       	ldi	r20, 0xB9	; 185
    20b4:	50 e0       	ldi	r21, 0x00	; 0
    20b6:	6a e0       	ldi	r22, 0x0A	; 10
    20b8:	72 e0       	ldi	r23, 0x02	; 2
    20ba:	8c e7       	ldi	r24, 0x7C	; 124
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	70 de       	rcall	.-800    	; 0x1da0 <xTaskGenericCreate>
    20c0:	89 83       	std	Y+1, r24	; 0x01
    20c2:	89 81       	ldd	r24, Y+1	; 0x01
    20c4:	81 30       	cpi	r24, 0x01	; 1
    20c6:	19 f4       	brne	.+6      	; 0x20ce <vTaskStartScheduler+0x46>
    20c8:	0e 94 b1 00 	call	0x162	; 0x162 <xTimerCreateTimerTask>
    20cc:	89 83       	std	Y+1, r24	; 0x01
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
    20d0:	81 30       	cpi	r24, 0x01	; 1
    20d2:	51 f4       	brne	.+20     	; 0x20e8 <vTaskStartScheduler+0x60>
    20d4:	f8 94       	cli
    20d6:	81 e0       	ldi	r24, 0x01	; 1
    20d8:	80 93 86 0c 	sts	0x0C86, r24	; 0x800c86 <xSchedulerRunning>
    20dc:	10 92 84 0c 	sts	0x0C84, r1	; 0x800c84 <xTickCount+0x1>
    20e0:	10 92 83 0c 	sts	0x0C83, r1	; 0x800c83 <xTickCount>
    20e4:	0e 94 bc 07 	call	0xf78	; 0xf78 <xPortStartScheduler>
    20e8:	0f 90       	pop	r0
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	0f 91       	pop	r16
    20f0:	ff 90       	pop	r15
    20f2:	ef 90       	pop	r14
    20f4:	df 90       	pop	r13
    20f6:	cf 90       	pop	r12
    20f8:	bf 90       	pop	r11
    20fa:	af 90       	pop	r10
    20fc:	08 95       	ret

000020fe <vTaskSuspendAll>:
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
    2102:	cd b7       	in	r28, 0x3d	; 61
    2104:	de b7       	in	r29, 0x3e	; 62
    2106:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    210a:	8f 5f       	subi	r24, 0xFF	; 255
    210c:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <uxSchedulerSuspended>
    2110:	df 91       	pop	r29
    2112:	cf 91       	pop	r28
    2114:	08 95       	ret

00002116 <xTaskResumeAll>:
    2116:	cf 93       	push	r28
    2118:	df 93       	push	r29
    211a:	00 d0       	rcall	.+0      	; 0x211c <xTaskResumeAll+0x6>
    211c:	cd b7       	in	r28, 0x3d	; 61
    211e:	de b7       	in	r29, 0x3e	; 62
    2120:	19 82       	std	Y+1, r1	; 0x01
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	0f 92       	push	r0
    2128:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    212c:	81 50       	subi	r24, 0x01	; 1
    212e:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <uxSchedulerSuspended>
    2132:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    2136:	88 23       	and	r24, r24
    2138:	09 f0       	breq	.+2      	; 0x213c <xTaskResumeAll+0x26>
    213a:	70 c0       	rjmp	.+224    	; 0x221c <__stack+0x1d>
    213c:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <uxCurrentNumberOfTasks>
    2140:	88 23       	and	r24, r24
    2142:	09 f4       	brne	.+2      	; 0x2146 <xTaskResumeAll+0x30>
    2144:	6b c0       	rjmp	.+214    	; 0x221c <__stack+0x1d>
    2146:	49 c0       	rjmp	.+146    	; 0x21da <xTaskResumeAll+0xc4>
    2148:	80 91 6b 0c 	lds	r24, 0x0C6B	; 0x800c6b <xPendingReadyList+0x5>
    214c:	90 91 6c 0c 	lds	r25, 0x0C6C	; 0x800c6c <xPendingReadyList+0x6>
    2150:	fc 01       	movw	r30, r24
    2152:	86 81       	ldd	r24, Z+6	; 0x06
    2154:	97 81       	ldd	r25, Z+7	; 0x07
    2156:	9b 83       	std	Y+3, r25	; 0x03
    2158:	8a 83       	std	Y+2, r24	; 0x02
    215a:	8a 81       	ldd	r24, Y+2	; 0x02
    215c:	9b 81       	ldd	r25, Y+3	; 0x03
    215e:	0c 96       	adiw	r24, 0x0c	; 12
    2160:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2164:	8a 81       	ldd	r24, Y+2	; 0x02
    2166:	9b 81       	ldd	r25, Y+3	; 0x03
    2168:	02 96       	adiw	r24, 0x02	; 2
    216a:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    216e:	8a 81       	ldd	r24, Y+2	; 0x02
    2170:	9b 81       	ldd	r25, Y+3	; 0x03
    2172:	fc 01       	movw	r30, r24
    2174:	96 89       	ldd	r25, Z+22	; 0x16
    2176:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    217a:	89 17       	cp	r24, r25
    217c:	30 f4       	brcc	.+12     	; 0x218a <xTaskResumeAll+0x74>
    217e:	8a 81       	ldd	r24, Y+2	; 0x02
    2180:	9b 81       	ldd	r25, Y+3	; 0x03
    2182:	fc 01       	movw	r30, r24
    2184:	86 89       	ldd	r24, Z+22	; 0x16
    2186:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <uxTopReadyPriority>
    218a:	8a 81       	ldd	r24, Y+2	; 0x02
    218c:	9b 81       	ldd	r25, Y+3	; 0x03
    218e:	ac 01       	movw	r20, r24
    2190:	4e 5f       	subi	r20, 0xFE	; 254
    2192:	5f 4f       	sbci	r21, 0xFF	; 255
    2194:	8a 81       	ldd	r24, Y+2	; 0x02
    2196:	9b 81       	ldd	r25, Y+3	; 0x03
    2198:	fc 01       	movw	r30, r24
    219a:	86 89       	ldd	r24, Z+22	; 0x16
    219c:	28 2f       	mov	r18, r24
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	c9 01       	movw	r24, r18
    21a2:	88 0f       	add	r24, r24
    21a4:	99 1f       	adc	r25, r25
    21a6:	88 0f       	add	r24, r24
    21a8:	99 1f       	adc	r25, r25
    21aa:	88 0f       	add	r24, r24
    21ac:	99 1f       	adc	r25, r25
    21ae:	82 0f       	add	r24, r18
    21b0:	93 1f       	adc	r25, r19
    21b2:	84 5d       	subi	r24, 0xD4	; 212
    21b4:	93 4f       	sbci	r25, 0xF3	; 243
    21b6:	ba 01       	movw	r22, r20
    21b8:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    21bc:	8a 81       	ldd	r24, Y+2	; 0x02
    21be:	9b 81       	ldd	r25, Y+3	; 0x03
    21c0:	fc 01       	movw	r30, r24
    21c2:	26 89       	ldd	r18, Z+22	; 0x16
    21c4:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    21c8:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    21cc:	fc 01       	movw	r30, r24
    21ce:	86 89       	ldd	r24, Z+22	; 0x16
    21d0:	28 17       	cp	r18, r24
    21d2:	18 f0       	brcs	.+6      	; 0x21da <xTaskResumeAll+0xc4>
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <xYieldPending>
    21da:	80 91 66 0c 	lds	r24, 0x0C66	; 0x800c66 <xPendingReadyList>
    21de:	88 23       	and	r24, r24
    21e0:	09 f0       	breq	.+2      	; 0x21e4 <xTaskResumeAll+0xce>
    21e2:	b2 cf       	rjmp	.-156    	; 0x2148 <xTaskResumeAll+0x32>
    21e4:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <uxPendedTicks>
    21e8:	88 23       	and	r24, r24
    21ea:	81 f0       	breq	.+32     	; 0x220c <__stack+0xd>
    21ec:	0b c0       	rjmp	.+22     	; 0x2204 <__stack+0x5>
    21ee:	37 d0       	rcall	.+110    	; 0x225e <xTaskIncrementTick>
    21f0:	88 23       	and	r24, r24
    21f2:	19 f0       	breq	.+6      	; 0x21fa <xTaskResumeAll+0xe4>
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <xYieldPending>
    21fa:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <uxPendedTicks>
    21fe:	81 50       	subi	r24, 0x01	; 1
    2200:	80 93 87 0c 	sts	0x0C87, r24	; 0x800c87 <uxPendedTicks>
    2204:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <uxPendedTicks>
    2208:	88 23       	and	r24, r24
    220a:	89 f7       	brne	.-30     	; 0x21ee <xTaskResumeAll+0xd8>
    220c:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <xYieldPending>
    2210:	81 30       	cpi	r24, 0x01	; 1
    2212:	21 f4       	brne	.+8      	; 0x221c <__stack+0x1d>
    2214:	81 e0       	ldi	r24, 0x01	; 1
    2216:	89 83       	std	Y+1, r24	; 0x01
    2218:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vPortYield>
    221c:	0f 90       	pop	r0
    221e:	0f be       	out	0x3f, r0	; 63
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	08 95       	ret

0000222e <xTaskGetTickCount>:
    222e:	cf 93       	push	r28
    2230:	df 93       	push	r29
    2232:	1f 92       	push	r1
    2234:	1f 92       	push	r1
    2236:	cd b7       	in	r28, 0x3d	; 61
    2238:	de b7       	in	r29, 0x3e	; 62
    223a:	0f b6       	in	r0, 0x3f	; 63
    223c:	f8 94       	cli
    223e:	0f 92       	push	r0
    2240:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <xTickCount>
    2244:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <xTickCount+0x1>
    2248:	9a 83       	std	Y+2, r25	; 0x02
    224a:	89 83       	std	Y+1, r24	; 0x01
    224c:	0f 90       	pop	r0
    224e:	0f be       	out	0x3f, r0	; 63
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	9a 81       	ldd	r25, Y+2	; 0x02
    2254:	0f 90       	pop	r0
    2256:	0f 90       	pop	r0
    2258:	df 91       	pop	r29
    225a:	cf 91       	pop	r28
    225c:	08 95       	ret

0000225e <xTaskIncrementTick>:
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	cd b7       	in	r28, 0x3d	; 61
    2264:	de b7       	in	r29, 0x3e	; 62
    2266:	29 97       	sbiw	r28, 0x09	; 9
    2268:	0f b6       	in	r0, 0x3f	; 63
    226a:	f8 94       	cli
    226c:	de bf       	out	0x3e, r29	; 62
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	cd bf       	out	0x3d, r28	; 61
    2272:	19 82       	std	Y+1, r1	; 0x01
    2274:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    2278:	88 23       	and	r24, r24
    227a:	09 f0       	breq	.+2      	; 0x227e <xTaskIncrementTick+0x20>
    227c:	c8 c0       	rjmp	.+400    	; 0x240e <xTaskIncrementTick+0x1b0>
    227e:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <xTickCount>
    2282:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <xTickCount+0x1>
    2286:	01 96       	adiw	r24, 0x01	; 1
    2288:	90 93 84 0c 	sts	0x0C84, r25	; 0x800c84 <xTickCount+0x1>
    228c:	80 93 83 0c 	sts	0x0C83, r24	; 0x800c83 <xTickCount>
    2290:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <xTickCount>
    2294:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <xTickCount+0x1>
    2298:	9b 83       	std	Y+3, r25	; 0x03
    229a:	8a 83       	std	Y+2, r24	; 0x02
    229c:	8a 81       	ldd	r24, Y+2	; 0x02
    229e:	9b 81       	ldd	r25, Y+3	; 0x03
    22a0:	89 2b       	or	r24, r25
    22a2:	d1 f4       	brne	.+52     	; 0x22d8 <xTaskIncrementTick+0x7a>
    22a4:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    22a8:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    22ac:	9d 83       	std	Y+5, r25	; 0x05
    22ae:	8c 83       	std	Y+4, r24	; 0x04
    22b0:	80 91 64 0c 	lds	r24, 0x0C64	; 0x800c64 <pxOverflowDelayedTaskList>
    22b4:	90 91 65 0c 	lds	r25, 0x0C65	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    22b8:	90 93 63 0c 	sts	0x0C63, r25	; 0x800c63 <pxDelayedTaskList+0x1>
    22bc:	80 93 62 0c 	sts	0x0C62, r24	; 0x800c62 <pxDelayedTaskList>
    22c0:	8c 81       	ldd	r24, Y+4	; 0x04
    22c2:	9d 81       	ldd	r25, Y+5	; 0x05
    22c4:	90 93 65 0c 	sts	0x0C65, r25	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    22c8:	80 93 64 0c 	sts	0x0C64, r24	; 0x800c64 <pxOverflowDelayedTaskList>
    22cc:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <xNumOfOverflows>
    22d0:	8f 5f       	subi	r24, 0xFF	; 255
    22d2:	80 93 89 0c 	sts	0x0C89, r24	; 0x800c89 <xNumOfOverflows>
    22d6:	5d d4       	rcall	.+2234   	; 0x2b92 <prvResetNextTaskUnblockTime>
    22d8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    22dc:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    22e0:	2a 81       	ldd	r18, Y+2	; 0x02
    22e2:	3b 81       	ldd	r19, Y+3	; 0x03
    22e4:	28 17       	cp	r18, r24
    22e6:	39 07       	cpc	r19, r25
    22e8:	08 f4       	brcc	.+2      	; 0x22ec <xTaskIncrementTick+0x8e>
    22ea:	77 c0       	rjmp	.+238    	; 0x23da <xTaskIncrementTick+0x17c>
    22ec:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    22f0:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    22f4:	fc 01       	movw	r30, r24
    22f6:	80 81       	ld	r24, Z
    22f8:	88 23       	and	r24, r24
    22fa:	39 f4       	brne	.+14     	; 0x230a <xTaskIncrementTick+0xac>
    22fc:	8f ef       	ldi	r24, 0xFF	; 255
    22fe:	9f ef       	ldi	r25, 0xFF	; 255
    2300:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    2304:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    2308:	68 c0       	rjmp	.+208    	; 0x23da <xTaskIncrementTick+0x17c>
    230a:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    230e:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    2312:	fc 01       	movw	r30, r24
    2314:	85 81       	ldd	r24, Z+5	; 0x05
    2316:	96 81       	ldd	r25, Z+6	; 0x06
    2318:	fc 01       	movw	r30, r24
    231a:	86 81       	ldd	r24, Z+6	; 0x06
    231c:	97 81       	ldd	r25, Z+7	; 0x07
    231e:	9f 83       	std	Y+7, r25	; 0x07
    2320:	8e 83       	std	Y+6, r24	; 0x06
    2322:	8e 81       	ldd	r24, Y+6	; 0x06
    2324:	9f 81       	ldd	r25, Y+7	; 0x07
    2326:	fc 01       	movw	r30, r24
    2328:	82 81       	ldd	r24, Z+2	; 0x02
    232a:	93 81       	ldd	r25, Z+3	; 0x03
    232c:	99 87       	std	Y+9, r25	; 0x09
    232e:	88 87       	std	Y+8, r24	; 0x08
    2330:	2a 81       	ldd	r18, Y+2	; 0x02
    2332:	3b 81       	ldd	r19, Y+3	; 0x03
    2334:	88 85       	ldd	r24, Y+8	; 0x08
    2336:	99 85       	ldd	r25, Y+9	; 0x09
    2338:	28 17       	cp	r18, r24
    233a:	39 07       	cpc	r19, r25
    233c:	38 f4       	brcc	.+14     	; 0x234c <xTaskIncrementTick+0xee>
    233e:	88 85       	ldd	r24, Y+8	; 0x08
    2340:	99 85       	ldd	r25, Y+9	; 0x09
    2342:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    2346:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    234a:	47 c0       	rjmp	.+142    	; 0x23da <xTaskIncrementTick+0x17c>
    234c:	8e 81       	ldd	r24, Y+6	; 0x06
    234e:	9f 81       	ldd	r25, Y+7	; 0x07
    2350:	02 96       	adiw	r24, 0x02	; 2
    2352:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2356:	8e 81       	ldd	r24, Y+6	; 0x06
    2358:	9f 81       	ldd	r25, Y+7	; 0x07
    235a:	fc 01       	movw	r30, r24
    235c:	84 89       	ldd	r24, Z+20	; 0x14
    235e:	95 89       	ldd	r25, Z+21	; 0x15
    2360:	89 2b       	or	r24, r25
    2362:	29 f0       	breq	.+10     	; 0x236e <xTaskIncrementTick+0x110>
    2364:	8e 81       	ldd	r24, Y+6	; 0x06
    2366:	9f 81       	ldd	r25, Y+7	; 0x07
    2368:	0c 96       	adiw	r24, 0x0c	; 12
    236a:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    236e:	8e 81       	ldd	r24, Y+6	; 0x06
    2370:	9f 81       	ldd	r25, Y+7	; 0x07
    2372:	fc 01       	movw	r30, r24
    2374:	96 89       	ldd	r25, Z+22	; 0x16
    2376:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    237a:	89 17       	cp	r24, r25
    237c:	30 f4       	brcc	.+12     	; 0x238a <xTaskIncrementTick+0x12c>
    237e:	8e 81       	ldd	r24, Y+6	; 0x06
    2380:	9f 81       	ldd	r25, Y+7	; 0x07
    2382:	fc 01       	movw	r30, r24
    2384:	86 89       	ldd	r24, Z+22	; 0x16
    2386:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <uxTopReadyPriority>
    238a:	8e 81       	ldd	r24, Y+6	; 0x06
    238c:	9f 81       	ldd	r25, Y+7	; 0x07
    238e:	ac 01       	movw	r20, r24
    2390:	4e 5f       	subi	r20, 0xFE	; 254
    2392:	5f 4f       	sbci	r21, 0xFF	; 255
    2394:	8e 81       	ldd	r24, Y+6	; 0x06
    2396:	9f 81       	ldd	r25, Y+7	; 0x07
    2398:	fc 01       	movw	r30, r24
    239a:	86 89       	ldd	r24, Z+22	; 0x16
    239c:	28 2f       	mov	r18, r24
    239e:	30 e0       	ldi	r19, 0x00	; 0
    23a0:	c9 01       	movw	r24, r18
    23a2:	88 0f       	add	r24, r24
    23a4:	99 1f       	adc	r25, r25
    23a6:	88 0f       	add	r24, r24
    23a8:	99 1f       	adc	r25, r25
    23aa:	88 0f       	add	r24, r24
    23ac:	99 1f       	adc	r25, r25
    23ae:	82 0f       	add	r24, r18
    23b0:	93 1f       	adc	r25, r19
    23b2:	84 5d       	subi	r24, 0xD4	; 212
    23b4:	93 4f       	sbci	r25, 0xF3	; 243
    23b6:	ba 01       	movw	r22, r20
    23b8:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    23bc:	8e 81       	ldd	r24, Y+6	; 0x06
    23be:	9f 81       	ldd	r25, Y+7	; 0x07
    23c0:	fc 01       	movw	r30, r24
    23c2:	26 89       	ldd	r18, Z+22	; 0x16
    23c4:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    23c8:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    23cc:	fc 01       	movw	r30, r24
    23ce:	86 89       	ldd	r24, Z+22	; 0x16
    23d0:	28 17       	cp	r18, r24
    23d2:	10 f0       	brcs	.+4      	; 0x23d8 <xTaskIncrementTick+0x17a>
    23d4:	81 e0       	ldi	r24, 0x01	; 1
    23d6:	89 83       	std	Y+1, r24	; 0x01
    23d8:	89 cf       	rjmp	.-238    	; 0x22ec <xTaskIncrementTick+0x8e>
    23da:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    23de:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    23e2:	fc 01       	movw	r30, r24
    23e4:	86 89       	ldd	r24, Z+22	; 0x16
    23e6:	28 2f       	mov	r18, r24
    23e8:	30 e0       	ldi	r19, 0x00	; 0
    23ea:	c9 01       	movw	r24, r18
    23ec:	88 0f       	add	r24, r24
    23ee:	99 1f       	adc	r25, r25
    23f0:	88 0f       	add	r24, r24
    23f2:	99 1f       	adc	r25, r25
    23f4:	88 0f       	add	r24, r24
    23f6:	99 1f       	adc	r25, r25
    23f8:	82 0f       	add	r24, r18
    23fa:	93 1f       	adc	r25, r19
    23fc:	84 5d       	subi	r24, 0xD4	; 212
    23fe:	93 4f       	sbci	r25, 0xF3	; 243
    2400:	fc 01       	movw	r30, r24
    2402:	80 81       	ld	r24, Z
    2404:	82 30       	cpi	r24, 0x02	; 2
    2406:	40 f0       	brcs	.+16     	; 0x2418 <xTaskIncrementTick+0x1ba>
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	89 83       	std	Y+1, r24	; 0x01
    240c:	05 c0       	rjmp	.+10     	; 0x2418 <xTaskIncrementTick+0x1ba>
    240e:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <uxPendedTicks>
    2412:	8f 5f       	subi	r24, 0xFF	; 255
    2414:	80 93 87 0c 	sts	0x0C87, r24	; 0x800c87 <uxPendedTicks>
    2418:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <xYieldPending>
    241c:	88 23       	and	r24, r24
    241e:	11 f0       	breq	.+4      	; 0x2424 <xTaskIncrementTick+0x1c6>
    2420:	81 e0       	ldi	r24, 0x01	; 1
    2422:	89 83       	std	Y+1, r24	; 0x01
    2424:	89 81       	ldd	r24, Y+1	; 0x01
    2426:	29 96       	adiw	r28, 0x09	; 9
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	de bf       	out	0x3e, r29	; 62
    242e:	0f be       	out	0x3f, r0	; 63
    2430:	cd bf       	out	0x3d, r28	; 61
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	08 95       	ret

00002438 <vTaskSwitchContext>:
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	1f 92       	push	r1
    243e:	1f 92       	push	r1
    2440:	cd b7       	in	r28, 0x3d	; 61
    2442:	de b7       	in	r29, 0x3e	; 62
    2444:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    2448:	88 23       	and	r24, r24
    244a:	21 f0       	breq	.+8      	; 0x2454 <vTaskSwitchContext+0x1c>
    244c:	81 e0       	ldi	r24, 0x01	; 1
    244e:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <xYieldPending>
    2452:	7b c0       	rjmp	.+246    	; 0x254a <vTaskSwitchContext+0x112>
    2454:	10 92 88 0c 	sts	0x0C88, r1	; 0x800c88 <xYieldPending>
    2458:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    245c:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2460:	fc 01       	movw	r30, r24
    2462:	20 81       	ld	r18, Z
    2464:	31 81       	ldd	r19, Z+1	; 0x01
    2466:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    246a:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    246e:	fc 01       	movw	r30, r24
    2470:	87 89       	ldd	r24, Z+23	; 0x17
    2472:	90 8d       	ldd	r25, Z+24	; 0x18
    2474:	82 17       	cp	r24, r18
    2476:	93 07       	cpc	r25, r19
    2478:	68 f0       	brcs	.+26     	; 0x2494 <vTaskSwitchContext+0x5c>
    247a:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    247e:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2482:	9c 01       	movw	r18, r24
    2484:	27 5e       	subi	r18, 0xE7	; 231
    2486:	3f 4f       	sbci	r19, 0xFF	; 255
    2488:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    248c:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2490:	b9 01       	movw	r22, r18
    2492:	b0 d5       	rcall	.+2912   	; 0x2ff4 <vApplicationStackOverflowHook>
    2494:	05 c0       	rjmp	.+10     	; 0x24a0 <vTaskSwitchContext+0x68>
    2496:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    249a:	81 50       	subi	r24, 0x01	; 1
    249c:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <uxTopReadyPriority>
    24a0:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    24a4:	28 2f       	mov	r18, r24
    24a6:	30 e0       	ldi	r19, 0x00	; 0
    24a8:	c9 01       	movw	r24, r18
    24aa:	88 0f       	add	r24, r24
    24ac:	99 1f       	adc	r25, r25
    24ae:	88 0f       	add	r24, r24
    24b0:	99 1f       	adc	r25, r25
    24b2:	88 0f       	add	r24, r24
    24b4:	99 1f       	adc	r25, r25
    24b6:	82 0f       	add	r24, r18
    24b8:	93 1f       	adc	r25, r19
    24ba:	84 5d       	subi	r24, 0xD4	; 212
    24bc:	93 4f       	sbci	r25, 0xF3	; 243
    24be:	fc 01       	movw	r30, r24
    24c0:	80 81       	ld	r24, Z
    24c2:	88 23       	and	r24, r24
    24c4:	41 f3       	breq	.-48     	; 0x2496 <vTaskSwitchContext+0x5e>
    24c6:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    24ca:	28 2f       	mov	r18, r24
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	c9 01       	movw	r24, r18
    24d0:	88 0f       	add	r24, r24
    24d2:	99 1f       	adc	r25, r25
    24d4:	88 0f       	add	r24, r24
    24d6:	99 1f       	adc	r25, r25
    24d8:	88 0f       	add	r24, r24
    24da:	99 1f       	adc	r25, r25
    24dc:	82 0f       	add	r24, r18
    24de:	93 1f       	adc	r25, r19
    24e0:	84 5d       	subi	r24, 0xD4	; 212
    24e2:	93 4f       	sbci	r25, 0xF3	; 243
    24e4:	9a 83       	std	Y+2, r25	; 0x02
    24e6:	89 83       	std	Y+1, r24	; 0x01
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	9a 81       	ldd	r25, Y+2	; 0x02
    24ec:	fc 01       	movw	r30, r24
    24ee:	81 81       	ldd	r24, Z+1	; 0x01
    24f0:	92 81       	ldd	r25, Z+2	; 0x02
    24f2:	fc 01       	movw	r30, r24
    24f4:	22 81       	ldd	r18, Z+2	; 0x02
    24f6:	33 81       	ldd	r19, Z+3	; 0x03
    24f8:	89 81       	ldd	r24, Y+1	; 0x01
    24fa:	9a 81       	ldd	r25, Y+2	; 0x02
    24fc:	fc 01       	movw	r30, r24
    24fe:	32 83       	std	Z+2, r19	; 0x02
    2500:	21 83       	std	Z+1, r18	; 0x01
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	fc 01       	movw	r30, r24
    2508:	21 81       	ldd	r18, Z+1	; 0x01
    250a:	32 81       	ldd	r19, Z+2	; 0x02
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	9a 81       	ldd	r25, Y+2	; 0x02
    2510:	03 96       	adiw	r24, 0x03	; 3
    2512:	28 17       	cp	r18, r24
    2514:	39 07       	cpc	r19, r25
    2516:	69 f4       	brne	.+26     	; 0x2532 <vTaskSwitchContext+0xfa>
    2518:	89 81       	ldd	r24, Y+1	; 0x01
    251a:	9a 81       	ldd	r25, Y+2	; 0x02
    251c:	fc 01       	movw	r30, r24
    251e:	81 81       	ldd	r24, Z+1	; 0x01
    2520:	92 81       	ldd	r25, Z+2	; 0x02
    2522:	fc 01       	movw	r30, r24
    2524:	22 81       	ldd	r18, Z+2	; 0x02
    2526:	33 81       	ldd	r19, Z+3	; 0x03
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	9a 81       	ldd	r25, Y+2	; 0x02
    252c:	fc 01       	movw	r30, r24
    252e:	32 83       	std	Z+2, r19	; 0x02
    2530:	21 83       	std	Z+1, r18	; 0x01
    2532:	89 81       	ldd	r24, Y+1	; 0x01
    2534:	9a 81       	ldd	r25, Y+2	; 0x02
    2536:	fc 01       	movw	r30, r24
    2538:	81 81       	ldd	r24, Z+1	; 0x01
    253a:	92 81       	ldd	r25, Z+2	; 0x02
    253c:	fc 01       	movw	r30, r24
    253e:	86 81       	ldd	r24, Z+6	; 0x06
    2540:	97 81       	ldd	r25, Z+7	; 0x07
    2542:	90 93 2b 0c 	sts	0x0C2B, r25	; 0x800c2b <pxCurrentTCB+0x1>
    2546:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <pxCurrentTCB>
    254a:	0f 90       	pop	r0
    254c:	0f 90       	pop	r0
    254e:	df 91       	pop	r29
    2550:	cf 91       	pop	r28
    2552:	08 95       	ret

00002554 <vTaskPlaceOnEventList>:
    2554:	cf 93       	push	r28
    2556:	df 93       	push	r29
    2558:	00 d0       	rcall	.+0      	; 0x255a <vTaskPlaceOnEventList+0x6>
    255a:	00 d0       	rcall	.+0      	; 0x255c <vTaskPlaceOnEventList+0x8>
    255c:	cd b7       	in	r28, 0x3d	; 61
    255e:	de b7       	in	r29, 0x3e	; 62
    2560:	9c 83       	std	Y+4, r25	; 0x04
    2562:	8b 83       	std	Y+3, r24	; 0x03
    2564:	7e 83       	std	Y+6, r23	; 0x06
    2566:	6d 83       	std	Y+5, r22	; 0x05
    2568:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    256c:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2570:	9c 01       	movw	r18, r24
    2572:	24 5f       	subi	r18, 0xF4	; 244
    2574:	3f 4f       	sbci	r19, 0xFF	; 255
    2576:	8b 81       	ldd	r24, Y+3	; 0x03
    2578:	9c 81       	ldd	r25, Y+4	; 0x04
    257a:	b9 01       	movw	r22, r18
    257c:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>
    2580:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2584:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2588:	02 96       	adiw	r24, 0x02	; 2
    258a:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    258e:	8d 81       	ldd	r24, Y+5	; 0x05
    2590:	9e 81       	ldd	r25, Y+6	; 0x06
    2592:	01 96       	adiw	r24, 0x01	; 1
    2594:	59 f4       	brne	.+22     	; 0x25ac <vTaskPlaceOnEventList+0x58>
    2596:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    259a:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    259e:	02 96       	adiw	r24, 0x02	; 2
    25a0:	bc 01       	movw	r22, r24
    25a2:	89 e7       	ldi	r24, 0x79	; 121
    25a4:	9c e0       	ldi	r25, 0x0C	; 12
    25a6:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    25aa:	0d c0       	rjmp	.+26     	; 0x25c6 <vTaskPlaceOnEventList+0x72>
    25ac:	20 91 83 0c 	lds	r18, 0x0C83	; 0x800c83 <xTickCount>
    25b0:	30 91 84 0c 	lds	r19, 0x0C84	; 0x800c84 <xTickCount+0x1>
    25b4:	8d 81       	ldd	r24, Y+5	; 0x05
    25b6:	9e 81       	ldd	r25, Y+6	; 0x06
    25b8:	82 0f       	add	r24, r18
    25ba:	93 1f       	adc	r25, r19
    25bc:	9a 83       	std	Y+2, r25	; 0x02
    25be:	89 83       	std	Y+1, r24	; 0x01
    25c0:	89 81       	ldd	r24, Y+1	; 0x01
    25c2:	9a 81       	ldd	r25, Y+2	; 0x02
    25c4:	40 d2       	rcall	.+1152   	; 0x2a46 <prvAddCurrentTaskToDelayedList>
    25c6:	26 96       	adiw	r28, 0x06	; 6
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	de bf       	out	0x3e, r29	; 62
    25ce:	0f be       	out	0x3f, r0	; 63
    25d0:	cd bf       	out	0x3d, r28	; 61
    25d2:	df 91       	pop	r29
    25d4:	cf 91       	pop	r28
    25d6:	08 95       	ret

000025d8 <vTaskPlaceOnEventListRestricted>:
    25d8:	cf 93       	push	r28
    25da:	df 93       	push	r29
    25dc:	00 d0       	rcall	.+0      	; 0x25de <vTaskPlaceOnEventListRestricted+0x6>
    25de:	00 d0       	rcall	.+0      	; 0x25e0 <vTaskPlaceOnEventListRestricted+0x8>
    25e0:	cd b7       	in	r28, 0x3d	; 61
    25e2:	de b7       	in	r29, 0x3e	; 62
    25e4:	9c 83       	std	Y+4, r25	; 0x04
    25e6:	8b 83       	std	Y+3, r24	; 0x03
    25e8:	7e 83       	std	Y+6, r23	; 0x06
    25ea:	6d 83       	std	Y+5, r22	; 0x05
    25ec:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    25f0:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    25f4:	9c 01       	movw	r18, r24
    25f6:	24 5f       	subi	r18, 0xF4	; 244
    25f8:	3f 4f       	sbci	r19, 0xFF	; 255
    25fa:	8b 81       	ldd	r24, Y+3	; 0x03
    25fc:	9c 81       	ldd	r25, Y+4	; 0x04
    25fe:	b9 01       	movw	r22, r18
    2600:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    2604:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2608:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    260c:	02 96       	adiw	r24, 0x02	; 2
    260e:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2612:	20 91 83 0c 	lds	r18, 0x0C83	; 0x800c83 <xTickCount>
    2616:	30 91 84 0c 	lds	r19, 0x0C84	; 0x800c84 <xTickCount+0x1>
    261a:	8d 81       	ldd	r24, Y+5	; 0x05
    261c:	9e 81       	ldd	r25, Y+6	; 0x06
    261e:	82 0f       	add	r24, r18
    2620:	93 1f       	adc	r25, r19
    2622:	9a 83       	std	Y+2, r25	; 0x02
    2624:	89 83       	std	Y+1, r24	; 0x01
    2626:	89 81       	ldd	r24, Y+1	; 0x01
    2628:	9a 81       	ldd	r25, Y+2	; 0x02
    262a:	0d d2       	rcall	.+1050   	; 0x2a46 <prvAddCurrentTaskToDelayedList>
    262c:	26 96       	adiw	r28, 0x06	; 6
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	de bf       	out	0x3e, r29	; 62
    2634:	0f be       	out	0x3f, r0	; 63
    2636:	cd bf       	out	0x3d, r28	; 61
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	08 95       	ret

0000263e <xTaskRemoveFromEventList>:
    263e:	cf 93       	push	r28
    2640:	df 93       	push	r29
    2642:	00 d0       	rcall	.+0      	; 0x2644 <xTaskRemoveFromEventList+0x6>
    2644:	1f 92       	push	r1
    2646:	1f 92       	push	r1
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
    264c:	9d 83       	std	Y+5, r25	; 0x05
    264e:	8c 83       	std	Y+4, r24	; 0x04
    2650:	8c 81       	ldd	r24, Y+4	; 0x04
    2652:	9d 81       	ldd	r25, Y+5	; 0x05
    2654:	fc 01       	movw	r30, r24
    2656:	85 81       	ldd	r24, Z+5	; 0x05
    2658:	96 81       	ldd	r25, Z+6	; 0x06
    265a:	fc 01       	movw	r30, r24
    265c:	86 81       	ldd	r24, Z+6	; 0x06
    265e:	97 81       	ldd	r25, Z+7	; 0x07
    2660:	9b 83       	std	Y+3, r25	; 0x03
    2662:	8a 83       	std	Y+2, r24	; 0x02
    2664:	8a 81       	ldd	r24, Y+2	; 0x02
    2666:	9b 81       	ldd	r25, Y+3	; 0x03
    2668:	0c 96       	adiw	r24, 0x0c	; 12
    266a:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    266e:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    2672:	88 23       	and	r24, r24
    2674:	69 f5       	brne	.+90     	; 0x26d0 <xTaskRemoveFromEventList+0x92>
    2676:	8a 81       	ldd	r24, Y+2	; 0x02
    2678:	9b 81       	ldd	r25, Y+3	; 0x03
    267a:	02 96       	adiw	r24, 0x02	; 2
    267c:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
    2680:	8a 81       	ldd	r24, Y+2	; 0x02
    2682:	9b 81       	ldd	r25, Y+3	; 0x03
    2684:	fc 01       	movw	r30, r24
    2686:	96 89       	ldd	r25, Z+22	; 0x16
    2688:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <uxTopReadyPriority>
    268c:	89 17       	cp	r24, r25
    268e:	30 f4       	brcc	.+12     	; 0x269c <xTaskRemoveFromEventList+0x5e>
    2690:	8a 81       	ldd	r24, Y+2	; 0x02
    2692:	9b 81       	ldd	r25, Y+3	; 0x03
    2694:	fc 01       	movw	r30, r24
    2696:	86 89       	ldd	r24, Z+22	; 0x16
    2698:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <uxTopReadyPriority>
    269c:	8a 81       	ldd	r24, Y+2	; 0x02
    269e:	9b 81       	ldd	r25, Y+3	; 0x03
    26a0:	ac 01       	movw	r20, r24
    26a2:	4e 5f       	subi	r20, 0xFE	; 254
    26a4:	5f 4f       	sbci	r21, 0xFF	; 255
    26a6:	8a 81       	ldd	r24, Y+2	; 0x02
    26a8:	9b 81       	ldd	r25, Y+3	; 0x03
    26aa:	fc 01       	movw	r30, r24
    26ac:	86 89       	ldd	r24, Z+22	; 0x16
    26ae:	28 2f       	mov	r18, r24
    26b0:	30 e0       	ldi	r19, 0x00	; 0
    26b2:	c9 01       	movw	r24, r18
    26b4:	88 0f       	add	r24, r24
    26b6:	99 1f       	adc	r25, r25
    26b8:	88 0f       	add	r24, r24
    26ba:	99 1f       	adc	r25, r25
    26bc:	88 0f       	add	r24, r24
    26be:	99 1f       	adc	r25, r25
    26c0:	82 0f       	add	r24, r18
    26c2:	93 1f       	adc	r25, r19
    26c4:	84 5d       	subi	r24, 0xD4	; 212
    26c6:	93 4f       	sbci	r25, 0xF3	; 243
    26c8:	ba 01       	movw	r22, r20
    26ca:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    26ce:	08 c0       	rjmp	.+16     	; 0x26e0 <xTaskRemoveFromEventList+0xa2>
    26d0:	8a 81       	ldd	r24, Y+2	; 0x02
    26d2:	9b 81       	ldd	r25, Y+3	; 0x03
    26d4:	0c 96       	adiw	r24, 0x0c	; 12
    26d6:	bc 01       	movw	r22, r24
    26d8:	86 e6       	ldi	r24, 0x66	; 102
    26da:	9c e0       	ldi	r25, 0x0C	; 12
    26dc:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    26e0:	8a 81       	ldd	r24, Y+2	; 0x02
    26e2:	9b 81       	ldd	r25, Y+3	; 0x03
    26e4:	fc 01       	movw	r30, r24
    26e6:	26 89       	ldd	r18, Z+22	; 0x16
    26e8:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    26ec:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    26f0:	fc 01       	movw	r30, r24
    26f2:	86 89       	ldd	r24, Z+22	; 0x16
    26f4:	82 17       	cp	r24, r18
    26f6:	30 f4       	brcc	.+12     	; 0x2704 <xTaskRemoveFromEventList+0xc6>
    26f8:	81 e0       	ldi	r24, 0x01	; 1
    26fa:	89 83       	std	Y+1, r24	; 0x01
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <xYieldPending>
    2702:	01 c0       	rjmp	.+2      	; 0x2706 <xTaskRemoveFromEventList+0xc8>
    2704:	19 82       	std	Y+1, r1	; 0x01
    2706:	89 81       	ldd	r24, Y+1	; 0x01
    2708:	0f 90       	pop	r0
    270a:	0f 90       	pop	r0
    270c:	0f 90       	pop	r0
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	08 95       	ret

00002718 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	1f 92       	push	r1
    271e:	1f 92       	push	r1
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
    2724:	9a 83       	std	Y+2, r25	; 0x02
    2726:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2728:	20 91 89 0c 	lds	r18, 0x0C89	; 0x800c89 <xNumOfOverflows>
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	9a 81       	ldd	r25, Y+2	; 0x02
    2730:	fc 01       	movw	r30, r24
    2732:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2734:	20 91 83 0c 	lds	r18, 0x0C83	; 0x800c83 <xTickCount>
    2738:	30 91 84 0c 	lds	r19, 0x0C84	; 0x800c84 <xTickCount+0x1>
    273c:	89 81       	ldd	r24, Y+1	; 0x01
    273e:	9a 81       	ldd	r25, Y+2	; 0x02
    2740:	fc 01       	movw	r30, r24
    2742:	32 83       	std	Z+2, r19	; 0x02
    2744:	21 83       	std	Z+1, r18	; 0x01
}
    2746:	0f 90       	pop	r0
    2748:	0f 90       	pop	r0
    274a:	df 91       	pop	r29
    274c:	cf 91       	pop	r28
    274e:	08 95       	ret

00002750 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2750:	cf 93       	push	r28
    2752:	df 93       	push	r29
    2754:	cd b7       	in	r28, 0x3d	; 61
    2756:	de b7       	in	r29, 0x3e	; 62
    2758:	27 97       	sbiw	r28, 0x07	; 7
    275a:	0f b6       	in	r0, 0x3f	; 63
    275c:	f8 94       	cli
    275e:	de bf       	out	0x3e, r29	; 62
    2760:	0f be       	out	0x3f, r0	; 63
    2762:	cd bf       	out	0x3d, r28	; 61
    2764:	9d 83       	std	Y+5, r25	; 0x05
    2766:	8c 83       	std	Y+4, r24	; 0x04
    2768:	7f 83       	std	Y+7, r23	; 0x07
    276a:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    276c:	0f b6       	in	r0, 0x3f	; 63
    276e:	f8 94       	cli
    2770:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2772:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <xTickCount>
    2776:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <xTickCount+0x1>
    277a:	9b 83       	std	Y+3, r25	; 0x03
    277c:	8a 83       	std	Y+2, r24	; 0x02

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    277e:	8e 81       	ldd	r24, Y+6	; 0x06
    2780:	9f 81       	ldd	r25, Y+7	; 0x07
    2782:	fc 01       	movw	r30, r24
    2784:	80 81       	ld	r24, Z
    2786:	91 81       	ldd	r25, Z+1	; 0x01
    2788:	01 96       	adiw	r24, 0x01	; 1
    278a:	11 f4       	brne	.+4      	; 0x2790 <xTaskCheckForTimeOut+0x40>
			{
				xReturn = pdFALSE;
    278c:	19 82       	std	Y+1, r1	; 0x01
    278e:	44 c0       	rjmp	.+136    	; 0x2818 <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2790:	8c 81       	ldd	r24, Y+4	; 0x04
    2792:	9d 81       	ldd	r25, Y+5	; 0x05
    2794:	fc 01       	movw	r30, r24
    2796:	90 81       	ld	r25, Z
    2798:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <xNumOfOverflows>
    279c:	98 17       	cp	r25, r24
    279e:	69 f0       	breq	.+26     	; 0x27ba <xTaskCheckForTimeOut+0x6a>
    27a0:	8c 81       	ldd	r24, Y+4	; 0x04
    27a2:	9d 81       	ldd	r25, Y+5	; 0x05
    27a4:	fc 01       	movw	r30, r24
    27a6:	21 81       	ldd	r18, Z+1	; 0x01
    27a8:	32 81       	ldd	r19, Z+2	; 0x02
    27aa:	8a 81       	ldd	r24, Y+2	; 0x02
    27ac:	9b 81       	ldd	r25, Y+3	; 0x03
    27ae:	82 17       	cp	r24, r18
    27b0:	93 07       	cpc	r25, r19
    27b2:	18 f0       	brcs	.+6      	; 0x27ba <xTaskCheckForTimeOut+0x6a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    27b4:	81 e0       	ldi	r24, 0x01	; 1
    27b6:	89 83       	std	Y+1, r24	; 0x01
    27b8:	2f c0       	rjmp	.+94     	; 0x2818 <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    27ba:	8c 81       	ldd	r24, Y+4	; 0x04
    27bc:	9d 81       	ldd	r25, Y+5	; 0x05
    27be:	fc 01       	movw	r30, r24
    27c0:	81 81       	ldd	r24, Z+1	; 0x01
    27c2:	92 81       	ldd	r25, Z+2	; 0x02
    27c4:	2a 81       	ldd	r18, Y+2	; 0x02
    27c6:	3b 81       	ldd	r19, Y+3	; 0x03
    27c8:	28 1b       	sub	r18, r24
    27ca:	39 0b       	sbc	r19, r25
    27cc:	8e 81       	ldd	r24, Y+6	; 0x06
    27ce:	9f 81       	ldd	r25, Y+7	; 0x07
    27d0:	fc 01       	movw	r30, r24
    27d2:	80 81       	ld	r24, Z
    27d4:	91 81       	ldd	r25, Z+1	; 0x01
    27d6:	28 17       	cp	r18, r24
    27d8:	39 07       	cpc	r19, r25
    27da:	e0 f4       	brcc	.+56     	; 0x2814 <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    27dc:	8e 81       	ldd	r24, Y+6	; 0x06
    27de:	9f 81       	ldd	r25, Y+7	; 0x07
    27e0:	fc 01       	movw	r30, r24
    27e2:	20 81       	ld	r18, Z
    27e4:	31 81       	ldd	r19, Z+1	; 0x01
    27e6:	8c 81       	ldd	r24, Y+4	; 0x04
    27e8:	9d 81       	ldd	r25, Y+5	; 0x05
    27ea:	fc 01       	movw	r30, r24
    27ec:	41 81       	ldd	r20, Z+1	; 0x01
    27ee:	52 81       	ldd	r21, Z+2	; 0x02
    27f0:	8a 81       	ldd	r24, Y+2	; 0x02
    27f2:	9b 81       	ldd	r25, Y+3	; 0x03
    27f4:	ba 01       	movw	r22, r20
    27f6:	68 1b       	sub	r22, r24
    27f8:	79 0b       	sbc	r23, r25
    27fa:	cb 01       	movw	r24, r22
    27fc:	28 0f       	add	r18, r24
    27fe:	39 1f       	adc	r19, r25
    2800:	8e 81       	ldd	r24, Y+6	; 0x06
    2802:	9f 81       	ldd	r25, Y+7	; 0x07
    2804:	fc 01       	movw	r30, r24
    2806:	31 83       	std	Z+1, r19	; 0x01
    2808:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    280a:	8c 81       	ldd	r24, Y+4	; 0x04
    280c:	9d 81       	ldd	r25, Y+5	; 0x05
    280e:	84 df       	rcall	.-248    	; 0x2718 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2810:	19 82       	std	Y+1, r1	; 0x01
    2812:	02 c0       	rjmp	.+4      	; 0x2818 <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2818:	0f 90       	pop	r0
    281a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    281c:	89 81       	ldd	r24, Y+1	; 0x01
}
    281e:	27 96       	adiw	r28, 0x07	; 7
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	f8 94       	cli
    2824:	de bf       	out	0x3e, r29	; 62
    2826:	0f be       	out	0x3f, r0	; 63
    2828:	cd bf       	out	0x3d, r28	; 61
    282a:	df 91       	pop	r29
    282c:	cf 91       	pop	r28
    282e:	08 95       	ret

00002830 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2830:	cf 93       	push	r28
    2832:	df 93       	push	r29
    2834:	cd b7       	in	r28, 0x3d	; 61
    2836:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2838:	81 e0       	ldi	r24, 0x01	; 1
    283a:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <xYieldPending>
}
    283e:	df 91       	pop	r29
    2840:	cf 91       	pop	r28
    2842:	08 95       	ret

00002844 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2844:	0f 93       	push	r16
    2846:	1f 93       	push	r17
    2848:	cf 93       	push	r28
    284a:	df 93       	push	r29
    284c:	cd b7       	in	r28, 0x3d	; 61
    284e:	de b7       	in	r29, 0x3e	; 62
    2850:	2a 97       	sbiw	r28, 0x0a	; 10
    2852:	0f b6       	in	r0, 0x3f	; 63
    2854:	f8 94       	cli
    2856:	de bf       	out	0x3e, r29	; 62
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	cd bf       	out	0x3d, r28	; 61
    285c:	9b 83       	std	Y+3, r25	; 0x03
    285e:	8a 83       	std	Y+2, r24	; 0x02
    2860:	7d 83       	std	Y+5, r23	; 0x05
    2862:	6c 83       	std	Y+4, r22	; 0x04
    2864:	4e 83       	std	Y+6, r20	; 0x06
    2866:	38 87       	std	Y+8, r19	; 0x08
    2868:	2f 83       	std	Y+7, r18	; 0x07
    286a:	1a 87       	std	Y+10, r17	; 0x0a
    286c:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    286e:	19 82       	std	Y+1, r1	; 0x01
    2870:	22 c0       	rjmp	.+68     	; 0x28b6 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	88 2f       	mov	r24, r24
    2876:	90 e0       	ldi	r25, 0x00	; 0
    2878:	29 81       	ldd	r18, Y+1	; 0x01
    287a:	22 2f       	mov	r18, r18
    287c:	30 e0       	ldi	r19, 0x00	; 0
    287e:	4c 81       	ldd	r20, Y+4	; 0x04
    2880:	5d 81       	ldd	r21, Y+5	; 0x05
    2882:	24 0f       	add	r18, r20
    2884:	35 1f       	adc	r19, r21
    2886:	f9 01       	movw	r30, r18
    2888:	40 81       	ld	r20, Z
    288a:	2a 81       	ldd	r18, Y+2	; 0x02
    288c:	3b 81       	ldd	r19, Y+3	; 0x03
    288e:	82 0f       	add	r24, r18
    2890:	93 1f       	adc	r25, r19
    2892:	49 96       	adiw	r24, 0x19	; 25
    2894:	fc 01       	movw	r30, r24
    2896:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2898:	89 81       	ldd	r24, Y+1	; 0x01
    289a:	88 2f       	mov	r24, r24
    289c:	90 e0       	ldi	r25, 0x00	; 0
    289e:	2c 81       	ldd	r18, Y+4	; 0x04
    28a0:	3d 81       	ldd	r19, Y+5	; 0x05
    28a2:	82 0f       	add	r24, r18
    28a4:	93 1f       	adc	r25, r19
    28a6:	fc 01       	movw	r30, r24
    28a8:	80 81       	ld	r24, Z
    28aa:	88 23       	and	r24, r24
    28ac:	09 f4       	brne	.+2      	; 0x28b0 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    28ae:	06 c0       	rjmp	.+12     	; 0x28bc <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	8f 5f       	subi	r24, 0xFF	; 255
    28b4:	89 83       	std	Y+1, r24	; 0x01
    28b6:	89 81       	ldd	r24, Y+1	; 0x01
    28b8:	88 30       	cpi	r24, 0x08	; 8
    28ba:	d8 f2       	brcs	.-74     	; 0x2872 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    28bc:	8a 81       	ldd	r24, Y+2	; 0x02
    28be:	9b 81       	ldd	r25, Y+3	; 0x03
    28c0:	fc 01       	movw	r30, r24
    28c2:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    28c4:	8e 81       	ldd	r24, Y+6	; 0x06
    28c6:	84 30       	cpi	r24, 0x04	; 4
    28c8:	10 f0       	brcs	.+4      	; 0x28ce <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    28ca:	83 e0       	ldi	r24, 0x03	; 3
    28cc:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    28ce:	8a 81       	ldd	r24, Y+2	; 0x02
    28d0:	9b 81       	ldd	r25, Y+3	; 0x03
    28d2:	2e 81       	ldd	r18, Y+6	; 0x06
    28d4:	fc 01       	movw	r30, r24
    28d6:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    28d8:	8a 81       	ldd	r24, Y+2	; 0x02
    28da:	9b 81       	ldd	r25, Y+3	; 0x03
    28dc:	02 96       	adiw	r24, 0x02	; 2
    28de:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    28e2:	8a 81       	ldd	r24, Y+2	; 0x02
    28e4:	9b 81       	ldd	r25, Y+3	; 0x03
    28e6:	0c 96       	adiw	r24, 0x0c	; 12
    28e8:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    28ec:	8a 81       	ldd	r24, Y+2	; 0x02
    28ee:	9b 81       	ldd	r25, Y+3	; 0x03
    28f0:	2a 81       	ldd	r18, Y+2	; 0x02
    28f2:	3b 81       	ldd	r19, Y+3	; 0x03
    28f4:	fc 01       	movw	r30, r24
    28f6:	31 87       	std	Z+9, r19	; 0x09
    28f8:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    28fa:	8e 81       	ldd	r24, Y+6	; 0x06
    28fc:	88 2f       	mov	r24, r24
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	24 e0       	ldi	r18, 0x04	; 4
    2902:	30 e0       	ldi	r19, 0x00	; 0
    2904:	28 1b       	sub	r18, r24
    2906:	39 0b       	sbc	r19, r25
    2908:	8a 81       	ldd	r24, Y+2	; 0x02
    290a:	9b 81       	ldd	r25, Y+3	; 0x03
    290c:	fc 01       	movw	r30, r24
    290e:	35 87       	std	Z+13, r19	; 0x0d
    2910:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2912:	8a 81       	ldd	r24, Y+2	; 0x02
    2914:	9b 81       	ldd	r25, Y+3	; 0x03
    2916:	2a 81       	ldd	r18, Y+2	; 0x02
    2918:	3b 81       	ldd	r19, Y+3	; 0x03
    291a:	fc 01       	movw	r30, r24
    291c:	33 8b       	std	Z+19, r19	; 0x13
    291e:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    2920:	8a 81       	ldd	r24, Y+2	; 0x02
    2922:	9b 81       	ldd	r25, Y+3	; 0x03
    2924:	fc 01       	movw	r30, r24
    2926:	11 a2       	std	Z+33, r1	; 0x21
    2928:	12 a2       	std	Z+34, r1	; 0x22
    292a:	13 a2       	std	Z+35, r1	; 0x23
    292c:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    292e:	8a 81       	ldd	r24, Y+2	; 0x02
    2930:	9b 81       	ldd	r25, Y+3	; 0x03
    2932:	fc 01       	movw	r30, r24
    2934:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    2936:	2a 96       	adiw	r28, 0x0a	; 10
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	de bf       	out	0x3e, r29	; 62
    293e:	0f be       	out	0x3f, r0	; 63
    2940:	cd bf       	out	0x3d, r28	; 61
    2942:	df 91       	pop	r29
    2944:	cf 91       	pop	r28
    2946:	1f 91       	pop	r17
    2948:	0f 91       	pop	r16
    294a:	08 95       	ret

0000294c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    294c:	cf 93       	push	r28
    294e:	df 93       	push	r29
    2950:	1f 92       	push	r1
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2956:	19 82       	std	Y+1, r1	; 0x01
    2958:	13 c0       	rjmp	.+38     	; 0x2980 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    295a:	89 81       	ldd	r24, Y+1	; 0x01
    295c:	28 2f       	mov	r18, r24
    295e:	30 e0       	ldi	r19, 0x00	; 0
    2960:	c9 01       	movw	r24, r18
    2962:	88 0f       	add	r24, r24
    2964:	99 1f       	adc	r25, r25
    2966:	88 0f       	add	r24, r24
    2968:	99 1f       	adc	r25, r25
    296a:	88 0f       	add	r24, r24
    296c:	99 1f       	adc	r25, r25
    296e:	82 0f       	add	r24, r18
    2970:	93 1f       	adc	r25, r19
    2972:	84 5d       	subi	r24, 0xD4	; 212
    2974:	93 4f       	sbci	r25, 0xF3	; 243
    2976:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    297a:	89 81       	ldd	r24, Y+1	; 0x01
    297c:	8f 5f       	subi	r24, 0xFF	; 255
    297e:	89 83       	std	Y+1, r24	; 0x01
    2980:	89 81       	ldd	r24, Y+1	; 0x01
    2982:	84 30       	cpi	r24, 0x04	; 4
    2984:	50 f3       	brcs	.-44     	; 0x295a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2986:	80 e5       	ldi	r24, 0x50	; 80
    2988:	9c e0       	ldi	r25, 0x0C	; 12
    298a:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    298e:	89 e5       	ldi	r24, 0x59	; 89
    2990:	9c e0       	ldi	r25, 0x0C	; 12
    2992:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2996:	86 e6       	ldi	r24, 0x66	; 102
    2998:	9c e0       	ldi	r25, 0x0C	; 12
    299a:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    299e:	8f e6       	ldi	r24, 0x6F	; 111
    29a0:	9c e0       	ldi	r25, 0x0C	; 12
    29a2:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    29a6:	89 e7       	ldi	r24, 0x79	; 121
    29a8:	9c e0       	ldi	r25, 0x0C	; 12
    29aa:	0e 94 95 04 	call	0x92a	; 0x92a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    29ae:	80 e5       	ldi	r24, 0x50	; 80
    29b0:	9c e0       	ldi	r25, 0x0C	; 12
    29b2:	90 93 63 0c 	sts	0x0C63, r25	; 0x800c63 <pxDelayedTaskList+0x1>
    29b6:	80 93 62 0c 	sts	0x0C62, r24	; 0x800c62 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    29ba:	89 e5       	ldi	r24, 0x59	; 89
    29bc:	9c e0       	ldi	r25, 0x0C	; 12
    29be:	90 93 65 0c 	sts	0x0C65, r25	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    29c2:	80 93 64 0c 	sts	0x0C64, r24	; 0x800c64 <pxOverflowDelayedTaskList>
}
    29c6:	0f 90       	pop	r0
    29c8:	df 91       	pop	r29
    29ca:	cf 91       	pop	r28
    29cc:	08 95       	ret

000029ce <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    29ce:	cf 93       	push	r28
    29d0:	df 93       	push	r29
    29d2:	00 d0       	rcall	.+0      	; 0x29d4 <prvCheckTasksWaitingTermination+0x6>
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    29d8:	2c c0       	rjmp	.+88     	; 0x2a32 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
    29da:	91 db       	rcall	.-2270   	; 0x20fe <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    29dc:	90 91 6f 0c 	lds	r25, 0x0C6F	; 0x800c6f <xTasksWaitingTermination>
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	99 23       	and	r25, r25
    29e4:	09 f0       	breq	.+2      	; 0x29e8 <prvCheckTasksWaitingTermination+0x1a>
    29e6:	80 e0       	ldi	r24, 0x00	; 0
    29e8:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    29ea:	95 db       	rcall	.-2262   	; 0x2116 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    29ec:	89 81       	ldd	r24, Y+1	; 0x01
    29ee:	88 23       	and	r24, r24
    29f0:	01 f5       	brne	.+64     	; 0x2a32 <prvCheckTasksWaitingTermination+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    29f2:	0f b6       	in	r0, 0x3f	; 63
    29f4:	f8 94       	cli
    29f6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    29f8:	80 91 74 0c 	lds	r24, 0x0C74	; 0x800c74 <xTasksWaitingTermination+0x5>
    29fc:	90 91 75 0c 	lds	r25, 0x0C75	; 0x800c75 <xTasksWaitingTermination+0x6>
    2a00:	fc 01       	movw	r30, r24
    2a02:	86 81       	ldd	r24, Z+6	; 0x06
    2a04:	97 81       	ldd	r25, Z+7	; 0x07
    2a06:	9b 83       	std	Y+3, r25	; 0x03
    2a08:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a0e:	02 96       	adiw	r24, 0x02	; 2
    2a10:	0e 94 a1 05 	call	0xb42	; 0xb42 <uxListRemove>
					--uxCurrentNumberOfTasks;
    2a14:	80 91 82 0c 	lds	r24, 0x0C82	; 0x800c82 <uxCurrentNumberOfTasks>
    2a18:	81 50       	subi	r24, 0x01	; 1
    2a1a:	80 93 82 0c 	sts	0x0C82, r24	; 0x800c82 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    2a1e:	80 91 78 0c 	lds	r24, 0x0C78	; 0x800c78 <uxTasksDeleted>
    2a22:	81 50       	subi	r24, 0x01	; 1
    2a24:	80 93 78 0c 	sts	0x0C78, r24	; 0x800c78 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    2a28:	0f 90       	pop	r0
    2a2a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2a2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a30:	98 d0       	rcall	.+304    	; 0x2b62 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2a32:	80 91 78 0c 	lds	r24, 0x0C78	; 0x800c78 <uxTasksDeleted>
    2a36:	88 23       	and	r24, r24
    2a38:	81 f6       	brne	.-96     	; 0x29da <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    2a3a:	0f 90       	pop	r0
    2a3c:	0f 90       	pop	r0
    2a3e:	0f 90       	pop	r0
    2a40:	df 91       	pop	r29
    2a42:	cf 91       	pop	r28
    2a44:	08 95       	ret

00002a46 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2a46:	cf 93       	push	r28
    2a48:	df 93       	push	r29
    2a4a:	1f 92       	push	r1
    2a4c:	1f 92       	push	r1
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
    2a52:	9a 83       	std	Y+2, r25	; 0x02
    2a54:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a56:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2a5a:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2a5e:	29 81       	ldd	r18, Y+1	; 0x01
    2a60:	3a 81       	ldd	r19, Y+2	; 0x02
    2a62:	fc 01       	movw	r30, r24
    2a64:	33 83       	std	Z+3, r19	; 0x03
    2a66:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    2a68:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <xTickCount>
    2a6c:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <xTickCount+0x1>
    2a70:	29 81       	ldd	r18, Y+1	; 0x01
    2a72:	3a 81       	ldd	r19, Y+2	; 0x02
    2a74:	28 17       	cp	r18, r24
    2a76:	39 07       	cpc	r19, r25
    2a78:	78 f4       	brcc	.+30     	; 0x2a98 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2a7a:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2a7e:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2a82:	9c 01       	movw	r18, r24
    2a84:	2e 5f       	subi	r18, 0xFE	; 254
    2a86:	3f 4f       	sbci	r19, 0xFF	; 255
    2a88:	80 91 64 0c 	lds	r24, 0x0C64	; 0x800c64 <pxOverflowDelayedTaskList>
    2a8c:	90 91 65 0c 	lds	r25, 0x0C65	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    2a90:	b9 01       	movw	r22, r18
    2a92:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>
    2a96:	1d c0       	rjmp	.+58     	; 0x2ad2 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2a98:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <pxCurrentTCB>
    2a9c:	90 91 2b 0c 	lds	r25, 0x0C2B	; 0x800c2b <pxCurrentTCB+0x1>
    2aa0:	9c 01       	movw	r18, r24
    2aa2:	2e 5f       	subi	r18, 0xFE	; 254
    2aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    2aa6:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    2aaa:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    2aae:	b9 01       	movw	r22, r18
    2ab0:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2ab4:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    2ab8:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    2abc:	29 81       	ldd	r18, Y+1	; 0x01
    2abe:	3a 81       	ldd	r19, Y+2	; 0x02
    2ac0:	28 17       	cp	r18, r24
    2ac2:	39 07       	cpc	r19, r25
    2ac4:	30 f4       	brcc	.+12     	; 0x2ad2 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2ac6:	89 81       	ldd	r24, Y+1	; 0x01
    2ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aca:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    2ace:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2ad2:	0f 90       	pop	r0
    2ad4:	0f 90       	pop	r0
    2ad6:	df 91       	pop	r29
    2ad8:	cf 91       	pop	r28
    2ada:	08 95       	ret

00002adc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62
    2ae4:	28 97       	sbiw	r28, 0x08	; 8
    2ae6:	0f b6       	in	r0, 0x3f	; 63
    2ae8:	f8 94       	cli
    2aea:	de bf       	out	0x3e, r29	; 62
    2aec:	0f be       	out	0x3f, r0	; 63
    2aee:	cd bf       	out	0x3d, r28	; 61
    2af0:	9e 83       	std	Y+6, r25	; 0x06
    2af2:	8d 83       	std	Y+5, r24	; 0x05
    2af4:	78 87       	std	Y+8, r23	; 0x08
    2af6:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2af8:	8f 81       	ldd	r24, Y+7	; 0x07
    2afa:	98 85       	ldd	r25, Y+8	; 0x08
    2afc:	89 2b       	or	r24, r25
    2afe:	29 f4       	brne	.+10     	; 0x2b0a <prvAllocateTCBAndStack+0x2e>
    2b00:	8d 81       	ldd	r24, Y+5	; 0x05
    2b02:	9e 81       	ldd	r25, Y+6	; 0x06
    2b04:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <pvPortMalloc>
    2b08:	02 c0       	rjmp	.+4      	; 0x2b0e <prvAllocateTCBAndStack+0x32>
    2b0a:	8f 81       	ldd	r24, Y+7	; 0x07
    2b0c:	98 85       	ldd	r25, Y+8	; 0x08
    2b0e:	9c 83       	std	Y+4, r25	; 0x04
    2b10:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	89 2b       	or	r24, r25
    2b18:	b9 f0       	breq	.+46     	; 0x2b48 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    2b1a:	86 e2       	ldi	r24, 0x26	; 38
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <pvPortMalloc>
    2b22:	9a 83       	std	Y+2, r25	; 0x02
    2b24:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    2b26:	89 81       	ldd	r24, Y+1	; 0x01
    2b28:	9a 81       	ldd	r25, Y+2	; 0x02
    2b2a:	89 2b       	or	r24, r25
    2b2c:	41 f0       	breq	.+16     	; 0x2b3e <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
    2b30:	9a 81       	ldd	r25, Y+2	; 0x02
    2b32:	2b 81       	ldd	r18, Y+3	; 0x03
    2b34:	3c 81       	ldd	r19, Y+4	; 0x04
    2b36:	fc 01       	movw	r30, r24
    2b38:	30 8f       	std	Z+24, r19	; 0x18
    2b3a:	27 8b       	std	Z+23, r18	; 0x17
    2b3c:	07 c0       	rjmp	.+14     	; 0x2b4c <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    2b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b40:	9c 81       	ldd	r25, Y+4	; 0x04
    2b42:	0e 94 be 09 	call	0x137c	; 0x137c <vPortFree>
    2b46:	02 c0       	rjmp	.+4      	; 0x2b4c <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    2b48:	1a 82       	std	Y+2, r1	; 0x02
    2b4a:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    2b4c:	89 81       	ldd	r24, Y+1	; 0x01
    2b4e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b50:	28 96       	adiw	r28, 0x08	; 8
    2b52:	0f b6       	in	r0, 0x3f	; 63
    2b54:	f8 94       	cli
    2b56:	de bf       	out	0x3e, r29	; 62
    2b58:	0f be       	out	0x3f, r0	; 63
    2b5a:	cd bf       	out	0x3d, r28	; 61
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	08 95       	ret

00002b62 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	1f 92       	push	r1
    2b68:	1f 92       	push	r1
    2b6a:	cd b7       	in	r28, 0x3d	; 61
    2b6c:	de b7       	in	r29, 0x3e	; 62
    2b6e:	9a 83       	std	Y+2, r25	; 0x02
    2b70:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    2b72:	89 81       	ldd	r24, Y+1	; 0x01
    2b74:	9a 81       	ldd	r25, Y+2	; 0x02
    2b76:	fc 01       	movw	r30, r24
    2b78:	87 89       	ldd	r24, Z+23	; 0x17
    2b7a:	90 8d       	ldd	r25, Z+24	; 0x18
    2b7c:	0e 94 be 09 	call	0x137c	; 0x137c <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    2b80:	89 81       	ldd	r24, Y+1	; 0x01
    2b82:	9a 81       	ldd	r25, Y+2	; 0x02
    2b84:	0e 94 be 09 	call	0x137c	; 0x137c <vPortFree>
	}
    2b88:	0f 90       	pop	r0
    2b8a:	0f 90       	pop	r0
    2b8c:	df 91       	pop	r29
    2b8e:	cf 91       	pop	r28
    2b90:	08 95       	ret

00002b92 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2b92:	cf 93       	push	r28
    2b94:	df 93       	push	r29
    2b96:	1f 92       	push	r1
    2b98:	1f 92       	push	r1
    2b9a:	cd b7       	in	r28, 0x3d	; 61
    2b9c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2b9e:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    2ba2:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    2ba6:	fc 01       	movw	r30, r24
    2ba8:	80 81       	ld	r24, Z
    2baa:	88 23       	and	r24, r24
    2bac:	39 f4       	brne	.+14     	; 0x2bbc <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2bae:	8f ef       	ldi	r24, 0xFF	; 255
    2bb0:	9f ef       	ldi	r25, 0xFF	; 255
    2bb2:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    2bb6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    2bba:	15 c0       	rjmp	.+42     	; 0x2be6 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2bbc:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <pxDelayedTaskList>
    2bc0:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <pxDelayedTaskList+0x1>
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	85 81       	ldd	r24, Z+5	; 0x05
    2bc8:	96 81       	ldd	r25, Z+6	; 0x06
    2bca:	fc 01       	movw	r30, r24
    2bcc:	86 81       	ldd	r24, Z+6	; 0x06
    2bce:	97 81       	ldd	r25, Z+7	; 0x07
    2bd0:	9a 83       	std	Y+2, r25	; 0x02
    2bd2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2bd4:	89 81       	ldd	r24, Y+1	; 0x01
    2bd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd8:	fc 01       	movw	r30, r24
    2bda:	82 81       	ldd	r24, Z+2	; 0x02
    2bdc:	93 81       	ldd	r25, Z+3	; 0x03
    2bde:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    2be2:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
	}
}
    2be6:	0f 90       	pop	r0
    2be8:	0f 90       	pop	r0
    2bea:	df 91       	pop	r29
    2bec:	cf 91       	pop	r28
    2bee:	08 95       	ret

00002bf0 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
    2bf0:	cf 93       	push	r28
    2bf2:	df 93       	push	r29
    2bf4:	1f 92       	push	r1
    2bf6:	cd b7       	in	r28, 0x3d	; 61
    2bf8:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2bfa:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <xSchedulerRunning>
    2bfe:	88 23       	and	r24, r24
    2c00:	19 f4       	brne	.+6      	; 0x2c08 <xTaskGetSchedulerState+0x18>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2c02:	81 e0       	ldi	r24, 0x01	; 1
    2c04:	89 83       	std	Y+1, r24	; 0x01
    2c06:	08 c0       	rjmp	.+16     	; 0x2c18 <xTaskGetSchedulerState+0x28>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c08:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <uxSchedulerSuspended>
    2c0c:	88 23       	and	r24, r24
    2c0e:	19 f4       	brne	.+6      	; 0x2c16 <xTaskGetSchedulerState+0x26>
			{
				xReturn = taskSCHEDULER_RUNNING;
    2c10:	82 e0       	ldi	r24, 0x02	; 2
    2c12:	89 83       	std	Y+1, r24	; 0x01
    2c14:	01 c0       	rjmp	.+2      	; 0x2c18 <xTaskGetSchedulerState+0x28>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2c16:	19 82       	std	Y+1, r1	; 0x01
			}
		}

		return xReturn;
    2c18:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2c1a:	0f 90       	pop	r0
    2c1c:	df 91       	pop	r29
    2c1e:	cf 91       	pop	r28
    2c20:	08 95       	ret

00002c22 <vTimerCallback1>:
TaskHandle_t x2Handle;
TimerHandle_t xTimer1;
TimerHandle_t xTimer2;
TimerHandle_t xTimer3;

void vTimerCallback1( TimerHandle_t pxTimer ){
    2c22:	cf 93       	push	r28
    2c24:	df 93       	push	r29
    2c26:	1f 92       	push	r1
    2c28:	1f 92       	push	r1
    2c2a:	cd b7       	in	r28, 0x3d	; 61
    2c2c:	de b7       	in	r29, 0x3e	; 62
    2c2e:	9a 83       	std	Y+2, r25	; 0x02
    2c30:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore1);
    2c32:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <xSemaphore1>
    2c36:	90 91 97 0c 	lds	r25, 0x0C97	; 0x800c97 <xSemaphore1+0x1>
    2c3a:	20 e0       	ldi	r18, 0x00	; 0
    2c3c:	40 e0       	ldi	r20, 0x00	; 0
    2c3e:	50 e0       	ldi	r21, 0x00	; 0
    2c40:	60 e0       	ldi	r22, 0x00	; 0
    2c42:	70 e0       	ldi	r23, 0x00	; 0
    2c44:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xQueueGenericSend>
}
    2c48:	0f 90       	pop	r0
    2c4a:	0f 90       	pop	r0
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	08 95       	ret

00002c52 <vTimerCallback2>:

void vTimerCallback2( TimerHandle_t pxTimer ){
    2c52:	cf 93       	push	r28
    2c54:	df 93       	push	r29
    2c56:	1f 92       	push	r1
    2c58:	1f 92       	push	r1
    2c5a:	cd b7       	in	r28, 0x3d	; 61
    2c5c:	de b7       	in	r29, 0x3e	; 62
    2c5e:	9a 83       	std	Y+2, r25	; 0x02
    2c60:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore2);
    2c62:	80 91 9a 0c 	lds	r24, 0x0C9A	; 0x800c9a <xSemaphore2>
    2c66:	90 91 9b 0c 	lds	r25, 0x0C9B	; 0x800c9b <xSemaphore2+0x1>
    2c6a:	20 e0       	ldi	r18, 0x00	; 0
    2c6c:	40 e0       	ldi	r20, 0x00	; 0
    2c6e:	50 e0       	ldi	r21, 0x00	; 0
    2c70:	60 e0       	ldi	r22, 0x00	; 0
    2c72:	70 e0       	ldi	r23, 0x00	; 0
    2c74:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xQueueGenericSend>
}
    2c78:	0f 90       	pop	r0
    2c7a:	0f 90       	pop	r0
    2c7c:	df 91       	pop	r29
    2c7e:	cf 91       	pop	r28
    2c80:	08 95       	ret

00002c82 <vTimerCallback3>:

void vTimerCallback3( TimerHandle_t pxTimer ){
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	1f 92       	push	r1
    2c88:	1f 92       	push	r1
    2c8a:	cd b7       	in	r28, 0x3d	; 61
    2c8c:	de b7       	in	r29, 0x3e	; 62
    2c8e:	9a 83       	std	Y+2, r25	; 0x02
    2c90:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore3);
    2c92:	80 91 90 0c 	lds	r24, 0x0C90	; 0x800c90 <xSemaphore3>
    2c96:	90 91 91 0c 	lds	r25, 0x0C91	; 0x800c91 <xSemaphore3+0x1>
    2c9a:	20 e0       	ldi	r18, 0x00	; 0
    2c9c:	40 e0       	ldi	r20, 0x00	; 0
    2c9e:	50 e0       	ldi	r21, 0x00	; 0
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	70 e0       	ldi	r23, 0x00	; 0
    2ca4:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xQueueGenericSend>
}
    2ca8:	0f 90       	pop	r0
    2caa:	0f 90       	pop	r0
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	08 95       	ret

00002cb2 <vTask4>:

void vTask4(void *pvParameters) {
    2cb2:	0f 93       	push	r16
    2cb4:	1f 93       	push	r17
    2cb6:	cf 93       	push	r28
    2cb8:	df 93       	push	r29
    2cba:	1f 92       	push	r1
    2cbc:	1f 92       	push	r1
    2cbe:	cd b7       	in	r28, 0x3d	; 61
    2cc0:	de b7       	in	r29, 0x3e	; 62
    2cc2:	9a 83       	std	Y+2, r25	; 0x02
    2cc4:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	
	xTimer1 = xTimerCreate( "Timer 1",( 4000 ), pdTRUE,( void * ) 42, vTimerCallback1);
    2cc6:	01 e1       	ldi	r16, 0x11	; 17
    2cc8:	16 e1       	ldi	r17, 0x16	; 22
    2cca:	2a e2       	ldi	r18, 0x2A	; 42
    2ccc:	30 e0       	ldi	r19, 0x00	; 0
    2cce:	41 e0       	ldi	r20, 0x01	; 1
    2cd0:	60 ea       	ldi	r22, 0xA0	; 160
    2cd2:	7f e0       	ldi	r23, 0x0F	; 15
    2cd4:	8f e0       	ldi	r24, 0x0F	; 15
    2cd6:	92 e0       	ldi	r25, 0x02	; 2
    2cd8:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <xTimerCreate>
    2cdc:	90 93 9d 0c 	sts	0x0C9D, r25	; 0x800c9d <xTimer1+0x1>
    2ce0:	80 93 9c 0c 	sts	0x0C9C, r24	; 0x800c9c <xTimer1>
	xTimerStart(xTimer1,0);
    2ce4:	a4 da       	rcall	.-2744   	; 0x222e <xTaskGetTickCount>
    2ce6:	ac 01       	movw	r20, r24
    2ce8:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <xTimer1>
    2cec:	90 91 9d 0c 	lds	r25, 0x0C9D	; 0x800c9d <xTimer1+0x1>
    2cf0:	00 e0       	ldi	r16, 0x00	; 0
    2cf2:	10 e0       	ldi	r17, 0x00	; 0
    2cf4:	20 e0       	ldi	r18, 0x00	; 0
    2cf6:	30 e0       	ldi	r19, 0x00	; 0
    2cf8:	61 e0       	ldi	r22, 0x01	; 1
    2cfa:	0e 94 3c 01 	call	0x278	; 0x278 <xTimerGenericCommand>
	
	vTaskDelay(2000);
    2cfe:	80 ed       	ldi	r24, 0xD0	; 208
    2d00:	97 e0       	ldi	r25, 0x07	; 7
    2d02:	30 d9       	rcall	.-3488   	; 0x1f64 <vTaskDelay>
	xTimer2 = xTimerCreate( "Timer 2",( 4000 ), pdTRUE,( void * ) 42, vTimerCallback2);
    2d04:	09 e2       	ldi	r16, 0x29	; 41
    2d06:	16 e1       	ldi	r17, 0x16	; 22
    2d08:	2a e2       	ldi	r18, 0x2A	; 42
    2d0a:	30 e0       	ldi	r19, 0x00	; 0
    2d0c:	41 e0       	ldi	r20, 0x01	; 1
    2d0e:	60 ea       	ldi	r22, 0xA0	; 160
    2d10:	7f e0       	ldi	r23, 0x0F	; 15
    2d12:	87 e1       	ldi	r24, 0x17	; 23
    2d14:	92 e0       	ldi	r25, 0x02	; 2
    2d16:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <xTimerCreate>
    2d1a:	90 93 99 0c 	sts	0x0C99, r25	; 0x800c99 <xTimer2+0x1>
    2d1e:	80 93 98 0c 	sts	0x0C98, r24	; 0x800c98 <xTimer2>
	xTimerStart(xTimer2,0);
    2d22:	85 da       	rcall	.-2806   	; 0x222e <xTaskGetTickCount>
    2d24:	ac 01       	movw	r20, r24
    2d26:	80 91 98 0c 	lds	r24, 0x0C98	; 0x800c98 <xTimer2>
    2d2a:	90 91 99 0c 	lds	r25, 0x0C99	; 0x800c99 <xTimer2+0x1>
    2d2e:	00 e0       	ldi	r16, 0x00	; 0
    2d30:	10 e0       	ldi	r17, 0x00	; 0
    2d32:	20 e0       	ldi	r18, 0x00	; 0
    2d34:	30 e0       	ldi	r19, 0x00	; 0
    2d36:	61 e0       	ldi	r22, 0x01	; 1
    2d38:	0e 94 3c 01 	call	0x278	; 0x278 <xTimerGenericCommand>
	
	vTaskDelay(1000);
    2d3c:	88 ee       	ldi	r24, 0xE8	; 232
    2d3e:	93 e0       	ldi	r25, 0x03	; 3
    2d40:	11 d9       	rcall	.-3550   	; 0x1f64 <vTaskDelay>
	xTimer3 = xTimerCreate( "Timer 3",( 2000 ), pdTRUE,( void * ) 42, vTimerCallback3);
    2d42:	01 e4       	ldi	r16, 0x41	; 65
    2d44:	16 e1       	ldi	r17, 0x16	; 22
    2d46:	2a e2       	ldi	r18, 0x2A	; 42
    2d48:	30 e0       	ldi	r19, 0x00	; 0
    2d4a:	41 e0       	ldi	r20, 0x01	; 1
    2d4c:	60 ed       	ldi	r22, 0xD0	; 208
    2d4e:	77 e0       	ldi	r23, 0x07	; 7
    2d50:	8f e1       	ldi	r24, 0x1F	; 31
    2d52:	92 e0       	ldi	r25, 0x02	; 2
    2d54:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <xTimerCreate>
    2d58:	90 93 a1 0c 	sts	0x0CA1, r25	; 0x800ca1 <xTimer3+0x1>
    2d5c:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <xTimer3>
	xTimerStart(xTimer3,0);
    2d60:	66 da       	rcall	.-2868   	; 0x222e <xTaskGetTickCount>
    2d62:	ac 01       	movw	r20, r24
    2d64:	80 91 a0 0c 	lds	r24, 0x0CA0	; 0x800ca0 <xTimer3>
    2d68:	90 91 a1 0c 	lds	r25, 0x0CA1	; 0x800ca1 <xTimer3+0x1>
    2d6c:	00 e0       	ldi	r16, 0x00	; 0
    2d6e:	10 e0       	ldi	r17, 0x00	; 0
    2d70:	20 e0       	ldi	r18, 0x00	; 0
    2d72:	30 e0       	ldi	r19, 0x00	; 0
    2d74:	61 e0       	ldi	r22, 0x01	; 1
    2d76:	0e 94 3c 01 	call	0x278	; 0x278 <xTimerGenericCommand>
	
	while (1) {
		vTaskSuspend(NULL);
    2d7a:	80 e0       	ldi	r24, 0x00	; 0
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	23 d9       	rcall	.-3514   	; 0x1fc6 <vTaskSuspend>
	}
    2d80:	fc cf       	rjmp	.-8      	; 0x2d7a <vTask4+0xc8>

00002d82 <vTask1>:
	vTaskDelete(NULL);
}

void vTask1(void *pvParameters) {
    2d82:	cf 93       	push	r28
    2d84:	df 93       	push	r29
    2d86:	1f 92       	push	r1
    2d88:	1f 92       	push	r1
    2d8a:	cd b7       	in	r28, 0x3d	; 61
    2d8c:	de b7       	in	r29, 0x3e	; 62
    2d8e:	9a 83       	std	Y+2, r25	; 0x02
    2d90:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	while (1) {
		xSemaphoreTake(xSemaphore1,  portMAX_DELAY);
    2d92:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <xSemaphore1>
    2d96:	90 91 97 0c 	lds	r25, 0x0C97	; 0x800c97 <xSemaphore1+0x1>
    2d9a:	20 e0       	ldi	r18, 0x00	; 0
    2d9c:	4f ef       	ldi	r20, 0xFF	; 255
    2d9e:	5f ef       	ldi	r21, 0xFF	; 255
    2da0:	60 e0       	ldi	r22, 0x00	; 0
    2da2:	70 e0       	ldi	r23, 0x00	; 0
    2da4:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericReceive>
		delay(10,1);
    2da8:	61 e0       	ldi	r22, 0x01	; 1
    2daa:	8a e0       	ldi	r24, 0x0A	; 10
    2dac:	ab d0       	rcall	.+342    	; 0x2f04 <delay>
	}
    2dae:	f1 cf       	rjmp	.-30     	; 0x2d92 <vTask1+0x10>

00002db0 <vTask2>:
	vTaskDelete(NULL);
}

void vTask2(void *pvParameters) {
    2db0:	cf 93       	push	r28
    2db2:	df 93       	push	r29
    2db4:	1f 92       	push	r1
    2db6:	1f 92       	push	r1
    2db8:	cd b7       	in	r28, 0x3d	; 61
    2dba:	de b7       	in	r29, 0x3e	; 62
    2dbc:	9a 83       	std	Y+2, r25	; 0x02
    2dbe:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	
	while (1) {
		xSemaphoreTake(xSemaphore2,  portMAX_DELAY);
    2dc0:	80 91 9a 0c 	lds	r24, 0x0C9A	; 0x800c9a <xSemaphore2>
    2dc4:	90 91 9b 0c 	lds	r25, 0x0C9B	; 0x800c9b <xSemaphore2+0x1>
    2dc8:	20 e0       	ldi	r18, 0x00	; 0
    2dca:	4f ef       	ldi	r20, 0xFF	; 255
    2dcc:	5f ef       	ldi	r21, 0xFF	; 255
    2dce:	60 e0       	ldi	r22, 0x00	; 0
    2dd0:	70 e0       	ldi	r23, 0x00	; 0
    2dd2:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericReceive>
		delay(10, 1<<1);
    2dd6:	62 e0       	ldi	r22, 0x02	; 2
    2dd8:	8a e0       	ldi	r24, 0x0A	; 10
    2dda:	94 d0       	rcall	.+296    	; 0x2f04 <delay>
		
	}
    2ddc:	f1 cf       	rjmp	.-30     	; 0x2dc0 <vTask2+0x10>

00002dde <vTask3>:
	vTaskDelete(NULL);
}

void vTask3(void *pvParameters) {
    2dde:	cf 93       	push	r28
    2de0:	df 93       	push	r29
    2de2:	1f 92       	push	r1
    2de4:	1f 92       	push	r1
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
    2dea:	9a 83       	std	Y+2, r25	; 0x02
    2dec:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	
	while (1) {
		xSemaphoreTake(xSemaphore3,  portMAX_DELAY);
    2dee:	80 91 90 0c 	lds	r24, 0x0C90	; 0x800c90 <xSemaphore3>
    2df2:	90 91 91 0c 	lds	r25, 0x0C91	; 0x800c91 <xSemaphore3+0x1>
    2df6:	20 e0       	ldi	r18, 0x00	; 0
    2df8:	4f ef       	ldi	r20, 0xFF	; 255
    2dfa:	5f ef       	ldi	r21, 0xFF	; 255
    2dfc:	60 e0       	ldi	r22, 0x00	; 0
    2dfe:	70 e0       	ldi	r23, 0x00	; 0
    2e00:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericReceive>
		delay(4, 1<<2);
    2e04:	64 e0       	ldi	r22, 0x04	; 4
    2e06:	84 e0       	ldi	r24, 0x04	; 4
    2e08:	7d d0       	rcall	.+250    	; 0x2f04 <delay>
		
	}
    2e0a:	f1 cf       	rjmp	.-30     	; 0x2dee <vTask3+0x10>

00002e0c <main>:
	vTaskDelete(NULL);
}

int main( void )
{
    2e0c:	af 92       	push	r10
    2e0e:	bf 92       	push	r11
    2e10:	cf 92       	push	r12
    2e12:	df 92       	push	r13
    2e14:	ef 92       	push	r14
    2e16:	ff 92       	push	r15
    2e18:	0f 93       	push	r16
    2e1a:	cf 93       	push	r28
    2e1c:	df 93       	push	r29
    2e1e:	cd b7       	in	r28, 0x3d	; 61
    2e20:	de b7       	in	r29, 0x3e	; 62
	DDRB = 0xff;
    2e22:	84 e2       	ldi	r24, 0x24	; 36
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	2f ef       	ldi	r18, 0xFF	; 255
    2e28:	fc 01       	movw	r30, r24
    2e2a:	20 83       	st	Z, r18

	xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL,
    2e2c:	a1 2c       	mov	r10, r1
    2e2e:	b1 2c       	mov	r11, r1
    2e30:	c1 2c       	mov	r12, r1
    2e32:	d1 2c       	mov	r13, r1
    2e34:	e1 2c       	mov	r14, r1
    2e36:	f1 2c       	mov	r15, r1
    2e38:	01 e0       	ldi	r16, 0x01	; 1
    2e3a:	20 e0       	ldi	r18, 0x00	; 0
    2e3c:	30 e0       	ldi	r19, 0x00	; 0
    2e3e:	49 eb       	ldi	r20, 0xB9	; 185
    2e40:	50 e0       	ldi	r21, 0x00	; 0
    2e42:	67 e2       	ldi	r22, 0x27	; 39
    2e44:	72 e0       	ldi	r23, 0x02	; 2
    2e46:	81 ec       	ldi	r24, 0xC1	; 193
    2e48:	96 e1       	ldi	r25, 0x16	; 22
    2e4a:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);
	xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL,
    2e4e:	a1 2c       	mov	r10, r1
    2e50:	b1 2c       	mov	r11, r1
    2e52:	c1 2c       	mov	r12, r1
    2e54:	d1 2c       	mov	r13, r1
    2e56:	e1 2c       	mov	r14, r1
    2e58:	f1 2c       	mov	r15, r1
    2e5a:	02 e0       	ldi	r16, 0x02	; 2
    2e5c:	20 e0       	ldi	r18, 0x00	; 0
    2e5e:	30 e0       	ldi	r19, 0x00	; 0
    2e60:	49 eb       	ldi	r20, 0xB9	; 185
    2e62:	50 e0       	ldi	r21, 0x00	; 0
    2e64:	6e e2       	ldi	r22, 0x2E	; 46
    2e66:	72 e0       	ldi	r23, 0x02	; 2
    2e68:	88 ed       	ldi	r24, 0xD8	; 216
    2e6a:	96 e1       	ldi	r25, 0x16	; 22
    2e6c:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskGenericCreate>
	task2_TASK_PRIORITY, NULL);
	xTaskCreate(vTask3, "Task 3", configMINIMAL_STACK_SIZE, NULL,
    2e70:	a1 2c       	mov	r10, r1
    2e72:	b1 2c       	mov	r11, r1
    2e74:	c1 2c       	mov	r12, r1
    2e76:	d1 2c       	mov	r13, r1
    2e78:	e1 2c       	mov	r14, r1
    2e7a:	f1 2c       	mov	r15, r1
    2e7c:	03 e0       	ldi	r16, 0x03	; 3
    2e7e:	20 e0       	ldi	r18, 0x00	; 0
    2e80:	30 e0       	ldi	r19, 0x00	; 0
    2e82:	49 eb       	ldi	r20, 0xB9	; 185
    2e84:	50 e0       	ldi	r21, 0x00	; 0
    2e86:	65 e3       	ldi	r22, 0x35	; 53
    2e88:	72 e0       	ldi	r23, 0x02	; 2
    2e8a:	8f ee       	ldi	r24, 0xEF	; 239
    2e8c:	96 e1       	ldi	r25, 0x16	; 22
    2e8e:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskGenericCreate>
	task3_TASK_PRIORITY, NULL);
	
	xTaskCreate(vTask4, "Task 4", configMINIMAL_STACK_SIZE, NULL,
    2e92:	a1 2c       	mov	r10, r1
    2e94:	b1 2c       	mov	r11, r1
    2e96:	c1 2c       	mov	r12, r1
    2e98:	d1 2c       	mov	r13, r1
    2e9a:	e1 2c       	mov	r14, r1
    2e9c:	f1 2c       	mov	r15, r1
    2e9e:	04 e0       	ldi	r16, 0x04	; 4
    2ea0:	20 e0       	ldi	r18, 0x00	; 0
    2ea2:	30 e0       	ldi	r19, 0x00	; 0
    2ea4:	49 eb       	ldi	r20, 0xB9	; 185
    2ea6:	50 e0       	ldi	r21, 0x00	; 0
    2ea8:	6c e3       	ldi	r22, 0x3C	; 60
    2eaa:	72 e0       	ldi	r23, 0x02	; 2
    2eac:	89 e5       	ldi	r24, 0x59	; 89
    2eae:	96 e1       	ldi	r25, 0x16	; 22
    2eb0:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskGenericCreate>
	task4_TASK_PRIORITY, NULL);

	xSemaphore1 = xSemaphoreCreateBinary();
    2eb4:	43 e0       	ldi	r20, 0x03	; 3
    2eb6:	60 e0       	ldi	r22, 0x00	; 0
    2eb8:	81 e0       	ldi	r24, 0x01	; 1
    2eba:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <xQueueGenericCreate>
    2ebe:	90 93 97 0c 	sts	0x0C97, r25	; 0x800c97 <xSemaphore1+0x1>
    2ec2:	80 93 96 0c 	sts	0x0C96, r24	; 0x800c96 <xSemaphore1>
	xSemaphore2 = xSemaphoreCreateBinary();
    2ec6:	43 e0       	ldi	r20, 0x03	; 3
    2ec8:	60 e0       	ldi	r22, 0x00	; 0
    2eca:	81 e0       	ldi	r24, 0x01	; 1
    2ecc:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <xQueueGenericCreate>
    2ed0:	90 93 9b 0c 	sts	0x0C9B, r25	; 0x800c9b <xSemaphore2+0x1>
    2ed4:	80 93 9a 0c 	sts	0x0C9A, r24	; 0x800c9a <xSemaphore2>
	xSemaphore3 = xSemaphoreCreateBinary();
    2ed8:	43 e0       	ldi	r20, 0x03	; 3
    2eda:	60 e0       	ldi	r22, 0x00	; 0
    2edc:	81 e0       	ldi	r24, 0x01	; 1
    2ede:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <xQueueGenericCreate>
    2ee2:	90 93 91 0c 	sts	0x0C91, r25	; 0x800c91 <xSemaphore3+0x1>
    2ee6:	80 93 90 0c 	sts	0x0C90, r24	; 0x800c90 <xSemaphore3>
	
	vTaskStartScheduler();
    2eea:	ce d8       	rcall	.-3684   	; 0x2088 <vTaskStartScheduler>

	return 0;
    2eec:	80 e0       	ldi	r24, 0x00	; 0
    2eee:	90 e0       	ldi	r25, 0x00	; 0
}
    2ef0:	df 91       	pop	r29
    2ef2:	cf 91       	pop	r28
    2ef4:	0f 91       	pop	r16
    2ef6:	ff 90       	pop	r15
    2ef8:	ef 90       	pop	r14
    2efa:	df 90       	pop	r13
    2efc:	cf 90       	pop	r12
    2efe:	bf 90       	pop	r11
    2f00:	af 90       	pop	r10
    2f02:	08 95       	ret

00002f04 <delay>:
/*-----------------------------------------------------------*/

void delay(uint8_t t, uint8_t p){
    2f04:	cf 93       	push	r28
    2f06:	df 93       	push	r29
    2f08:	00 d0       	rcall	.+0      	; 0x2f0a <delay+0x6>
    2f0a:	1f 92       	push	r1
    2f0c:	1f 92       	push	r1
    2f0e:	cd b7       	in	r28, 0x3d	; 61
    2f10:	de b7       	in	r29, 0x3e	; 62
    2f12:	8c 83       	std	Y+4, r24	; 0x04
    2f14:	6d 83       	std	Y+5, r22	; 0x05
	uint8_t c;
	uint16_t ic;
	for(c=0; c<t; c++){
    2f16:	19 82       	std	Y+1, r1	; 0x01
    2f18:	2d c0       	rjmp	.+90     	; 0x2f74 <delay+0x70>
		if(c%2==0){
    2f1a:	89 81       	ldd	r24, Y+1	; 0x01
    2f1c:	81 70       	andi	r24, 0x01	; 1
    2f1e:	88 23       	and	r24, r24
    2f20:	a1 f4       	brne	.+40     	; 0x2f4a <delay+0x46>
			for(ic = 0; ic <10000; ic++){
    2f22:	1b 82       	std	Y+3, r1	; 0x03
    2f24:	1a 82       	std	Y+2, r1	; 0x02
    2f26:	0b c0       	rjmp	.+22     	; 0x2f3e <delay+0x3a>
				PORTB = ~p;
    2f28:	85 e2       	ldi	r24, 0x25	; 37
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f2e:	20 95       	com	r18
    2f30:	fc 01       	movw	r30, r24
    2f32:	20 83       	st	Z, r18
void delay(uint8_t t, uint8_t p){
	uint8_t c;
	uint16_t ic;
	for(c=0; c<t; c++){
		if(c%2==0){
			for(ic = 0; ic <10000; ic++){
    2f34:	8a 81       	ldd	r24, Y+2	; 0x02
    2f36:	9b 81       	ldd	r25, Y+3	; 0x03
    2f38:	01 96       	adiw	r24, 0x01	; 1
    2f3a:	9b 83       	std	Y+3, r25	; 0x03
    2f3c:	8a 83       	std	Y+2, r24	; 0x02
    2f3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f40:	9b 81       	ldd	r25, Y+3	; 0x03
    2f42:	80 31       	cpi	r24, 0x10	; 16
    2f44:	97 42       	sbci	r25, 0x27	; 39
    2f46:	80 f3       	brcs	.-32     	; 0x2f28 <delay+0x24>
    2f48:	12 c0       	rjmp	.+36     	; 0x2f6e <delay+0x6a>
				PORTB = ~p;
			}
		}
		else {
			for(ic = 0; ic <10000; ic++){
    2f4a:	1b 82       	std	Y+3, r1	; 0x03
    2f4c:	1a 82       	std	Y+2, r1	; 0x02
    2f4e:	0a c0       	rjmp	.+20     	; 0x2f64 <delay+0x60>
				PORTB = 0xFF;
    2f50:	85 e2       	ldi	r24, 0x25	; 37
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	2f ef       	ldi	r18, 0xFF	; 255
    2f56:	fc 01       	movw	r30, r24
    2f58:	20 83       	st	Z, r18
			for(ic = 0; ic <10000; ic++){
				PORTB = ~p;
			}
		}
		else {
			for(ic = 0; ic <10000; ic++){
    2f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f5e:	01 96       	adiw	r24, 0x01	; 1
    2f60:	9b 83       	std	Y+3, r25	; 0x03
    2f62:	8a 83       	std	Y+2, r24	; 0x02
    2f64:	8a 81       	ldd	r24, Y+2	; 0x02
    2f66:	9b 81       	ldd	r25, Y+3	; 0x03
    2f68:	80 31       	cpi	r24, 0x10	; 16
    2f6a:	97 42       	sbci	r25, 0x27	; 39
    2f6c:	88 f3       	brcs	.-30     	; 0x2f50 <delay+0x4c>
/*-----------------------------------------------------------*/

void delay(uint8_t t, uint8_t p){
	uint8_t c;
	uint16_t ic;
	for(c=0; c<t; c++){
    2f6e:	89 81       	ldd	r24, Y+1	; 0x01
    2f70:	8f 5f       	subi	r24, 0xFF	; 255
    2f72:	89 83       	std	Y+1, r24	; 0x01
    2f74:	99 81       	ldd	r25, Y+1	; 0x01
    2f76:	8c 81       	ldd	r24, Y+4	; 0x04
    2f78:	98 17       	cp	r25, r24
    2f7a:	78 f2       	brcs	.-98     	; 0x2f1a <delay+0x16>
				PORTB = 0xFF;
			}
		}
	}
	
}
    2f7c:	0f 90       	pop	r0
    2f7e:	0f 90       	pop	r0
    2f80:	0f 90       	pop	r0
    2f82:	0f 90       	pop	r0
    2f84:	0f 90       	pop	r0
    2f86:	df 91       	pop	r29
    2f88:	cf 91       	pop	r28
    2f8a:	08 95       	ret

00002f8c <vApplicationIdleHook>:


/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
    2f8c:	cf 93       	push	r28
    2f8e:	df 93       	push	r29
    2f90:	cd b7       	in	r28, 0x3d	; 61
    2f92:	de b7       	in	r29, 0x3e	; 62
	//vCoRoutineSchedule();
}
    2f94:	df 91       	pop	r29
    2f96:	cf 91       	pop	r28
    2f98:	08 95       	ret

00002f9a <__vector_default>:

ISR(BADISR_vect)
{
    2f9a:	1f 92       	push	r1
    2f9c:	0f 92       	push	r0
    2f9e:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    2fa2:	0f 92       	push	r0
    2fa4:	11 24       	eor	r1, r1
    2fa6:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    2faa:	0f 92       	push	r0
    2fac:	2f 93       	push	r18
    2fae:	3f 93       	push	r19
    2fb0:	8f 93       	push	r24
    2fb2:	9f 93       	push	r25
    2fb4:	ef 93       	push	r30
    2fb6:	ff 93       	push	r31
    2fb8:	cf 93       	push	r28
    2fba:	df 93       	push	r29
    2fbc:	cd b7       	in	r28, 0x3d	; 61
    2fbe:	de b7       	in	r29, 0x3e	; 62
	PORTA &= ~_BV(PA1);
    2fc0:	82 e2       	ldi	r24, 0x22	; 34
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	22 e2       	ldi	r18, 0x22	; 34
    2fc6:	30 e0       	ldi	r19, 0x00	; 0
    2fc8:	f9 01       	movw	r30, r18
    2fca:	20 81       	ld	r18, Z
    2fcc:	2d 7f       	andi	r18, 0xFD	; 253
    2fce:	fc 01       	movw	r30, r24
    2fd0:	20 83       	st	Z, r18
}
    2fd2:	df 91       	pop	r29
    2fd4:	cf 91       	pop	r28
    2fd6:	ff 91       	pop	r31
    2fd8:	ef 91       	pop	r30
    2fda:	9f 91       	pop	r25
    2fdc:	8f 91       	pop	r24
    2fde:	3f 91       	pop	r19
    2fe0:	2f 91       	pop	r18
    2fe2:	0f 90       	pop	r0
    2fe4:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    2fe8:	0f 90       	pop	r0
    2fea:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    2fee:	0f 90       	pop	r0
    2ff0:	1f 90       	pop	r1
    2ff2:	18 95       	reti

00002ff4 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	00 d0       	rcall	.+0      	; 0x2ffa <vApplicationStackOverflowHook+0x6>
    2ffa:	1f 92       	push	r1
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
    3000:	9a 83       	std	Y+2, r25	; 0x02
    3002:	89 83       	std	Y+1, r24	; 0x01
    3004:	7c 83       	std	Y+4, r23	; 0x04
    3006:	6b 83       	std	Y+3, r22	; 0x03
	PORTA |= _BV(PA7);
    3008:	82 e2       	ldi	r24, 0x22	; 34
    300a:	90 e0       	ldi	r25, 0x00	; 0
    300c:	22 e2       	ldi	r18, 0x22	; 34
    300e:	30 e0       	ldi	r19, 0x00	; 0
    3010:	f9 01       	movw	r30, r18
    3012:	20 81       	ld	r18, Z
    3014:	20 68       	ori	r18, 0x80	; 128
    3016:	fc 01       	movw	r30, r24
    3018:	20 83       	st	Z, r18
    301a:	0f 90       	pop	r0
    301c:	0f 90       	pop	r0
    301e:	0f 90       	pop	r0
    3020:	0f 90       	pop	r0
    3022:	df 91       	pop	r29
    3024:	cf 91       	pop	r28
    3026:	08 95       	ret

00003028 <__vector_25>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
ISR(USART0_RX_vect)
{
    3028:	1f 92       	push	r1
    302a:	0f 92       	push	r0
    302c:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    3030:	0f 92       	push	r0
    3032:	11 24       	eor	r1, r1
    3034:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    3038:	0f 92       	push	r0
    303a:	2f 93       	push	r18
    303c:	3f 93       	push	r19
    303e:	4f 93       	push	r20
    3040:	5f 93       	push	r21
    3042:	6f 93       	push	r22
    3044:	7f 93       	push	r23
    3046:	8f 93       	push	r24
    3048:	9f 93       	push	r25
    304a:	af 93       	push	r26
    304c:	bf 93       	push	r27
    304e:	ef 93       	push	r30
    3050:	ff 93       	push	r31
    3052:	cf 93       	push	r28
    3054:	df 93       	push	r29
    3056:	1f 92       	push	r1
    3058:	1f 92       	push	r1
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    305e:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    3060:	86 ec       	ldi	r24, 0xC6	; 198
    3062:	90 e0       	ldi	r25, 0x00	; 0
    3064:	fc 01       	movw	r30, r24
    3066:	80 81       	ld	r24, Z
    3068:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    306a:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <xRxedChars>
    306e:	90 91 8d 0c 	lds	r25, 0x0C8D	; 0x800c8d <xRxedChars+0x1>
    3072:	ae 01       	movw	r20, r28
    3074:	4e 5f       	subi	r20, 0xFE	; 254
    3076:	5f 4f       	sbci	r21, 0xFF	; 255
    3078:	20 e0       	ldi	r18, 0x00	; 0
    307a:	be 01       	movw	r22, r28
    307c:	6f 5f       	subi	r22, 0xFF	; 255
    307e:	7f 4f       	sbci	r23, 0xFF	; 255
    3080:	0e 94 67 0b 	call	0x16ce	; 0x16ce <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    3084:	8a 81       	ldd	r24, Y+2	; 0x02
    3086:	88 23       	and	r24, r24
    3088:	11 f0       	breq	.+4      	; 0x308e <__vector_25+0x66>
	{
		taskYIELD();
    308a:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vPortYield>
	}
}
    308e:	0f 90       	pop	r0
    3090:	0f 90       	pop	r0
    3092:	df 91       	pop	r29
    3094:	cf 91       	pop	r28
    3096:	ff 91       	pop	r31
    3098:	ef 91       	pop	r30
    309a:	bf 91       	pop	r27
    309c:	af 91       	pop	r26
    309e:	9f 91       	pop	r25
    30a0:	8f 91       	pop	r24
    30a2:	7f 91       	pop	r23
    30a4:	6f 91       	pop	r22
    30a6:	5f 91       	pop	r21
    30a8:	4f 91       	pop	r20
    30aa:	3f 91       	pop	r19
    30ac:	2f 91       	pop	r18
    30ae:	0f 90       	pop	r0
    30b0:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    30b4:	0f 90       	pop	r0
    30b6:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    30ba:	0f 90       	pop	r0
    30bc:	1f 90       	pop	r1
    30be:	18 95       	reti

000030c0 <__vector_26>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
ISR(USART0_UDRE_vect)
{
    30c0:	1f 92       	push	r1
    30c2:	0f 92       	push	r0
    30c4:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    30c8:	0f 92       	push	r0
    30ca:	11 24       	eor	r1, r1
    30cc:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    30d0:	0f 92       	push	r0
    30d2:	2f 93       	push	r18
    30d4:	3f 93       	push	r19
    30d6:	4f 93       	push	r20
    30d8:	5f 93       	push	r21
    30da:	6f 93       	push	r22
    30dc:	7f 93       	push	r23
    30de:	8f 93       	push	r24
    30e0:	9f 93       	push	r25
    30e2:	af 93       	push	r26
    30e4:	bf 93       	push	r27
    30e6:	ef 93       	push	r30
    30e8:	ff 93       	push	r31
    30ea:	cf 93       	push	r28
    30ec:	df 93       	push	r29
    30ee:	00 d0       	rcall	.+0      	; 0x30f0 <__vector_26+0x30>
    30f0:	cd b7       	in	r28, 0x3d	; 61
    30f2:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    30f4:	80 91 8e 0c 	lds	r24, 0x0C8E	; 0x800c8e <xCharsForTx>
    30f8:	90 91 8f 0c 	lds	r25, 0x0C8F	; 0x800c8f <xCharsForTx+0x1>
    30fc:	ae 01       	movw	r20, r28
    30fe:	4d 5f       	subi	r20, 0xFD	; 253
    3100:	5f 4f       	sbci	r21, 0xFF	; 255
    3102:	9e 01       	movw	r18, r28
    3104:	2e 5f       	subi	r18, 0xFE	; 254
    3106:	3f 4f       	sbci	r19, 0xFF	; 255
    3108:	b9 01       	movw	r22, r18
    310a:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueReceiveFromISR>
    310e:	81 30       	cpi	r24, 0x01	; 1
    3110:	31 f4       	brne	.+12     	; 0x311e <__vector_26+0x5e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    3112:	86 ec       	ldi	r24, 0xC6	; 198
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	2a 81       	ldd	r18, Y+2	; 0x02
    3118:	fc 01       	movw	r30, r24
    311a:	20 83       	st	Z, r18
    311c:	0d c0       	rjmp	.+26     	; 0x3138 <__vector_26+0x78>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    311e:	81 ec       	ldi	r24, 0xC1	; 193
    3120:	90 e0       	ldi	r25, 0x00	; 0
    3122:	fc 01       	movw	r30, r24
    3124:	80 81       	ld	r24, Z
    3126:	89 83       	std	Y+1, r24	; 0x01
    3128:	89 81       	ldd	r24, Y+1	; 0x01
    312a:	8f 7d       	andi	r24, 0xDF	; 223
    312c:	89 83       	std	Y+1, r24	; 0x01
    312e:	81 ec       	ldi	r24, 0xC1	; 193
    3130:	90 e0       	ldi	r25, 0x00	; 0
    3132:	29 81       	ldd	r18, Y+1	; 0x01
    3134:	fc 01       	movw	r30, r24
    3136:	20 83       	st	Z, r18
	}
}
    3138:	0f 90       	pop	r0
    313a:	0f 90       	pop	r0
    313c:	0f 90       	pop	r0
    313e:	df 91       	pop	r29
    3140:	cf 91       	pop	r28
    3142:	ff 91       	pop	r31
    3144:	ef 91       	pop	r30
    3146:	bf 91       	pop	r27
    3148:	af 91       	pop	r26
    314a:	9f 91       	pop	r25
    314c:	8f 91       	pop	r24
    314e:	7f 91       	pop	r23
    3150:	6f 91       	pop	r22
    3152:	5f 91       	pop	r21
    3154:	4f 91       	pop	r20
    3156:	3f 91       	pop	r19
    3158:	2f 91       	pop	r18
    315a:	0f 90       	pop	r0
    315c:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    3160:	0f 90       	pop	r0
    3162:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    3166:	0f 90       	pop	r0
    3168:	1f 90       	pop	r1
    316a:	18 95       	reti

0000316c <__udivmodsi4>:
    316c:	a1 e2       	ldi	r26, 0x21	; 33
    316e:	1a 2e       	mov	r1, r26
    3170:	aa 1b       	sub	r26, r26
    3172:	bb 1b       	sub	r27, r27
    3174:	fd 01       	movw	r30, r26
    3176:	0d c0       	rjmp	.+26     	; 0x3192 <__udivmodsi4_ep>

00003178 <__udivmodsi4_loop>:
    3178:	aa 1f       	adc	r26, r26
    317a:	bb 1f       	adc	r27, r27
    317c:	ee 1f       	adc	r30, r30
    317e:	ff 1f       	adc	r31, r31
    3180:	a2 17       	cp	r26, r18
    3182:	b3 07       	cpc	r27, r19
    3184:	e4 07       	cpc	r30, r20
    3186:	f5 07       	cpc	r31, r21
    3188:	20 f0       	brcs	.+8      	; 0x3192 <__udivmodsi4_ep>
    318a:	a2 1b       	sub	r26, r18
    318c:	b3 0b       	sbc	r27, r19
    318e:	e4 0b       	sbc	r30, r20
    3190:	f5 0b       	sbc	r31, r21

00003192 <__udivmodsi4_ep>:
    3192:	66 1f       	adc	r22, r22
    3194:	77 1f       	adc	r23, r23
    3196:	88 1f       	adc	r24, r24
    3198:	99 1f       	adc	r25, r25
    319a:	1a 94       	dec	r1
    319c:	69 f7       	brne	.-38     	; 0x3178 <__udivmodsi4_loop>
    319e:	60 95       	com	r22
    31a0:	70 95       	com	r23
    31a2:	80 95       	com	r24
    31a4:	90 95       	com	r25
    31a6:	9b 01       	movw	r18, r22
    31a8:	ac 01       	movw	r20, r24
    31aa:	bd 01       	movw	r22, r26
    31ac:	cf 01       	movw	r24, r30
    31ae:	08 95       	ret

000031b0 <__tablejump2__>:
    31b0:	ee 0f       	add	r30, r30
    31b2:	ff 1f       	adc	r31, r31
    31b4:	88 1f       	adc	r24, r24
    31b6:	8b bf       	out	0x3b, r24	; 59
    31b8:	07 90       	elpm	r0, Z+
    31ba:	f6 91       	elpm	r31, Z
    31bc:	e0 2d       	mov	r30, r0
    31be:	19 94       	eijmp

000031c0 <memcpy>:
    31c0:	fb 01       	movw	r30, r22
    31c2:	dc 01       	movw	r26, r24
    31c4:	02 c0       	rjmp	.+4      	; 0x31ca <memcpy+0xa>
    31c6:	01 90       	ld	r0, Z+
    31c8:	0d 92       	st	X+, r0
    31ca:	41 50       	subi	r20, 0x01	; 1
    31cc:	50 40       	sbci	r21, 0x00	; 0
    31ce:	d8 f7       	brcc	.-10     	; 0x31c6 <memcpy+0x6>
    31d0:	08 95       	ret

000031d2 <_exit>:
    31d2:	f8 94       	cli

000031d4 <__stop_program>:
    31d4:	ff cf       	rjmp	.-2      	; 0x31d4 <__stop_program>
