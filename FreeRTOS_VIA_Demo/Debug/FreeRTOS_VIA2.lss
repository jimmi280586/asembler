
FreeRTOS_VIA2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800200  00001fec  00002080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a3a  0080021c  0080021c  0000209c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000209c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000020cc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000358  00000000  00000000  0000210c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002551  00000000  00000000  00002464  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000827  00000000  00000000  000049b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002718  00000000  00000000  000051dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c9c  00000000  00000000  000078f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000119d  00000000  00000000  00008590  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001a80  00000000  00000000  0000972d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000300  00000000  00000000  0000b1ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	83 c0       	rjmp	.+262    	; 0x108 <__ctors_end>
       2:	00 00       	nop
       4:	a2 c0       	rjmp	.+324    	; 0x14a <__bad_interrupt>
       6:	00 00       	nop
       8:	a0 c0       	rjmp	.+320    	; 0x14a <__bad_interrupt>
       a:	00 00       	nop
       c:	9e c0       	rjmp	.+316    	; 0x14a <__bad_interrupt>
       e:	00 00       	nop
      10:	9c c0       	rjmp	.+312    	; 0x14a <__bad_interrupt>
      12:	00 00       	nop
      14:	9a c0       	rjmp	.+308    	; 0x14a <__bad_interrupt>
      16:	00 00       	nop
      18:	98 c0       	rjmp	.+304    	; 0x14a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	96 c0       	rjmp	.+300    	; 0x14a <__bad_interrupt>
      1e:	00 00       	nop
      20:	94 c0       	rjmp	.+296    	; 0x14a <__bad_interrupt>
      22:	00 00       	nop
      24:	92 c0       	rjmp	.+292    	; 0x14a <__bad_interrupt>
      26:	00 00       	nop
      28:	90 c0       	rjmp	.+288    	; 0x14a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8e c0       	rjmp	.+284    	; 0x14a <__bad_interrupt>
      2e:	00 00       	nop
      30:	8c c0       	rjmp	.+280    	; 0x14a <__bad_interrupt>
      32:	00 00       	nop
      34:	8a c0       	rjmp	.+276    	; 0x14a <__bad_interrupt>
      36:	00 00       	nop
      38:	88 c0       	rjmp	.+272    	; 0x14a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	86 c0       	rjmp	.+268    	; 0x14a <__bad_interrupt>
      3e:	00 00       	nop
      40:	84 c0       	rjmp	.+264    	; 0x14a <__bad_interrupt>
      42:	00 00       	nop
      44:	82 c0       	rjmp	.+260    	; 0x14a <__bad_interrupt>
      46:	00 00       	nop
      48:	80 c0       	rjmp	.+256    	; 0x14a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7e c0       	rjmp	.+252    	; 0x14a <__bad_interrupt>
      4e:	00 00       	nop
      50:	7c c0       	rjmp	.+248    	; 0x14a <__bad_interrupt>
      52:	00 00       	nop
      54:	7a c0       	rjmp	.+244    	; 0x14a <__bad_interrupt>
      56:	00 00       	nop
      58:	78 c0       	rjmp	.+240    	; 0x14a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	76 c0       	rjmp	.+236    	; 0x14a <__bad_interrupt>
      5e:	00 00       	nop
      60:	74 c0       	rjmp	.+232    	; 0x14a <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 27 0f 	jmp	0x1e4e	; 0x1e4e <__vector_25>
      68:	0c 94 73 0f 	jmp	0x1ee6	; 0x1ee6 <__vector_26>
      6c:	6e c0       	rjmp	.+220    	; 0x14a <__bad_interrupt>
      6e:	00 00       	nop
      70:	6c c0       	rjmp	.+216    	; 0x14a <__bad_interrupt>
      72:	00 00       	nop
      74:	6a c0       	rjmp	.+212    	; 0x14a <__bad_interrupt>
      76:	00 00       	nop
      78:	68 c0       	rjmp	.+208    	; 0x14a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	66 c0       	rjmp	.+204    	; 0x14a <__bad_interrupt>
      7e:	00 00       	nop
      80:	37 c5       	rjmp	.+2670   	; 0xaf0 <__vector_32>
      82:	00 00       	nop
      84:	62 c0       	rjmp	.+196    	; 0x14a <__bad_interrupt>
      86:	00 00       	nop
      88:	60 c0       	rjmp	.+192    	; 0x14a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5e c0       	rjmp	.+188    	; 0x14a <__bad_interrupt>
      8e:	00 00       	nop
      90:	5c c0       	rjmp	.+184    	; 0x14a <__bad_interrupt>
      92:	00 00       	nop
      94:	5a c0       	rjmp	.+180    	; 0x14a <__bad_interrupt>
      96:	00 00       	nop
      98:	58 c0       	rjmp	.+176    	; 0x14a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	56 c0       	rjmp	.+172    	; 0x14a <__bad_interrupt>
      9e:	00 00       	nop
      a0:	54 c0       	rjmp	.+168    	; 0x14a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	52 c0       	rjmp	.+164    	; 0x14a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	50 c0       	rjmp	.+160    	; 0x14a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4e c0       	rjmp	.+156    	; 0x14a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4c c0       	rjmp	.+152    	; 0x14a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	4a c0       	rjmp	.+148    	; 0x14a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	48 c0       	rjmp	.+144    	; 0x14a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	46 c0       	rjmp	.+140    	; 0x14a <__bad_interrupt>
      be:	00 00       	nop
      c0:	44 c0       	rjmp	.+136    	; 0x14a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	42 c0       	rjmp	.+132    	; 0x14a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	40 c0       	rjmp	.+128    	; 0x14a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3e c0       	rjmp	.+124    	; 0x14a <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3c c0       	rjmp	.+120    	; 0x14a <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3a c0       	rjmp	.+116    	; 0x14a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	38 c0       	rjmp	.+112    	; 0x14a <__bad_interrupt>
      da:	00 00       	nop
      dc:	36 c0       	rjmp	.+108    	; 0x14a <__bad_interrupt>
      de:	00 00       	nop
      e0:	34 c0       	rjmp	.+104    	; 0x14a <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	1f 92       	push	r1
      ea:	1f 92       	push	r1
      ec:	cd b7       	in	r28, 0x3d	; 61
      ee:	de b7       	in	r29, 0x3e	; 62
      f0:	9a 83       	std	Y+2, r25	; 0x02
      f2:	89 83       	std	Y+1, r24	; 0x01
      f4:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvCheckTasksWaitingTermination>
      f8:	80 91 ea 0b 	lds	r24, 0x0BEA	; 0x800bea <pxReadyTasksLists>
      fc:	82 30       	cpi	r24, 0x02	; 2
      fe:	08 f0       	brcs	.+2      	; 0x102 <prvIdleTask+0x1e>
     100:	85 d3       	rcall	.+1802   	; 0x80c <vPortYield>
     102:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vApplicationIdleHook>
     106:	f6 cf       	rjmp	.-20     	; 0xf4 <prvIdleTask+0x10>

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf ef       	ldi	r28, 0xFF	; 255
     10e:	d1 e2       	ldi	r29, 0x21	; 33
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61
     114:	00 e0       	ldi	r16, 0x00	; 0
     116:	0c bf       	out	0x3c, r16	; 60

00000118 <__do_copy_data>:
     118:	12 e0       	ldi	r17, 0x02	; 2
     11a:	a0 e0       	ldi	r26, 0x00	; 0
     11c:	b2 e0       	ldi	r27, 0x02	; 2
     11e:	ec ee       	ldi	r30, 0xEC	; 236
     120:	ff e1       	ldi	r31, 0x1F	; 31
     122:	00 e0       	ldi	r16, 0x00	; 0
     124:	0b bf       	out	0x3b, r16	; 59
     126:	02 c0       	rjmp	.+4      	; 0x12c <__do_copy_data+0x14>
     128:	07 90       	elpm	r0, Z+
     12a:	0d 92       	st	X+, r0
     12c:	ac 31       	cpi	r26, 0x1C	; 28
     12e:	b1 07       	cpc	r27, r17
     130:	d9 f7       	brne	.-10     	; 0x128 <__do_copy_data+0x10>

00000132 <__do_clear_bss>:
     132:	2c e0       	ldi	r18, 0x0C	; 12
     134:	ac e1       	ldi	r26, 0x1C	; 28
     136:	b2 e0       	ldi	r27, 0x02	; 2
     138:	01 c0       	rjmp	.+2      	; 0x13c <.do_clear_bss_start>

0000013a <.do_clear_bss_loop>:
     13a:	1d 92       	st	X+, r1

0000013c <.do_clear_bss_start>:
     13c:	a6 35       	cpi	r26, 0x56	; 86
     13e:	b2 07       	cpc	r27, r18
     140:	e1 f7       	brne	.-8      	; 0x13a <.do_clear_bss_loop>
     142:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <main>
     146:	0c 94 f4 0f 	jmp	0x1fe8	; 0x1fe8 <_exit>

0000014a <__bad_interrupt>:
     14a:	0c 94 e0 0e 	jmp	0x1dc0	; 0x1dc0 <__vector_default>

0000014e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	1f 92       	push	r1
     154:	1f 92       	push	r1
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
     15a:	9a 83       	std	Y+2, r25	; 0x02
     15c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     15e:	89 81       	ldd	r24, Y+1	; 0x01
     160:	9a 81       	ldd	r25, Y+2	; 0x02
     162:	9c 01       	movw	r18, r24
     164:	2d 5f       	subi	r18, 0xFD	; 253
     166:	3f 4f       	sbci	r19, 0xFF	; 255
     168:	89 81       	ldd	r24, Y+1	; 0x01
     16a:	9a 81       	ldd	r25, Y+2	; 0x02
     16c:	fc 01       	movw	r30, r24
     16e:	32 83       	std	Z+2, r19	; 0x02
     170:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     172:	89 81       	ldd	r24, Y+1	; 0x01
     174:	9a 81       	ldd	r25, Y+2	; 0x02
     176:	2f ef       	ldi	r18, 0xFF	; 255
     178:	3f ef       	ldi	r19, 0xFF	; 255
     17a:	fc 01       	movw	r30, r24
     17c:	34 83       	std	Z+4, r19	; 0x04
     17e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     180:	89 81       	ldd	r24, Y+1	; 0x01
     182:	9a 81       	ldd	r25, Y+2	; 0x02
     184:	9c 01       	movw	r18, r24
     186:	2d 5f       	subi	r18, 0xFD	; 253
     188:	3f 4f       	sbci	r19, 0xFF	; 255
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	fc 01       	movw	r30, r24
     190:	36 83       	std	Z+6, r19	; 0x06
     192:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     194:	89 81       	ldd	r24, Y+1	; 0x01
     196:	9a 81       	ldd	r25, Y+2	; 0x02
     198:	9c 01       	movw	r18, r24
     19a:	2d 5f       	subi	r18, 0xFD	; 253
     19c:	3f 4f       	sbci	r19, 0xFF	; 255
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	9a 81       	ldd	r25, Y+2	; 0x02
     1a2:	fc 01       	movw	r30, r24
     1a4:	30 87       	std	Z+8, r19	; 0x08
     1a6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1a8:	89 81       	ldd	r24, Y+1	; 0x01
     1aa:	9a 81       	ldd	r25, Y+2	; 0x02
     1ac:	fc 01       	movw	r30, r24
     1ae:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     1b0:	0f 90       	pop	r0
     1b2:	0f 90       	pop	r0
     1b4:	df 91       	pop	r29
     1b6:	cf 91       	pop	r28
     1b8:	08 95       	ret

000001ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	1f 92       	push	r1
     1c0:	1f 92       	push	r1
     1c2:	cd b7       	in	r28, 0x3d	; 61
     1c4:	de b7       	in	r29, 0x3e	; 62
     1c6:	9a 83       	std	Y+2, r25	; 0x02
     1c8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1ca:	89 81       	ldd	r24, Y+1	; 0x01
     1cc:	9a 81       	ldd	r25, Y+2	; 0x02
     1ce:	fc 01       	movw	r30, r24
     1d0:	11 86       	std	Z+9, r1	; 0x09
     1d2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     1d4:	0f 90       	pop	r0
     1d6:	0f 90       	pop	r0
     1d8:	df 91       	pop	r29
     1da:	cf 91       	pop	r28
     1dc:	08 95       	ret

000001de <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1de:	cf 93       	push	r28
     1e0:	df 93       	push	r29
     1e2:	00 d0       	rcall	.+0      	; 0x1e4 <vListInsertEnd+0x6>
     1e4:	00 d0       	rcall	.+0      	; 0x1e6 <vListInsertEnd+0x8>
     1e6:	cd b7       	in	r28, 0x3d	; 61
     1e8:	de b7       	in	r29, 0x3e	; 62
     1ea:	9c 83       	std	Y+4, r25	; 0x04
     1ec:	8b 83       	std	Y+3, r24	; 0x03
     1ee:	7e 83       	std	Y+6, r23	; 0x06
     1f0:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     1f2:	8b 81       	ldd	r24, Y+3	; 0x03
     1f4:	9c 81       	ldd	r25, Y+4	; 0x04
     1f6:	fc 01       	movw	r30, r24
     1f8:	81 81       	ldd	r24, Z+1	; 0x01
     1fa:	92 81       	ldd	r25, Z+2	; 0x02
     1fc:	9a 83       	std	Y+2, r25	; 0x02
     1fe:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     200:	8d 81       	ldd	r24, Y+5	; 0x05
     202:	9e 81       	ldd	r25, Y+6	; 0x06
     204:	29 81       	ldd	r18, Y+1	; 0x01
     206:	3a 81       	ldd	r19, Y+2	; 0x02
     208:	fc 01       	movw	r30, r24
     20a:	33 83       	std	Z+3, r19	; 0x03
     20c:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	9a 81       	ldd	r25, Y+2	; 0x02
     212:	fc 01       	movw	r30, r24
     214:	24 81       	ldd	r18, Z+4	; 0x04
     216:	35 81       	ldd	r19, Z+5	; 0x05
     218:	8d 81       	ldd	r24, Y+5	; 0x05
     21a:	9e 81       	ldd	r25, Y+6	; 0x06
     21c:	fc 01       	movw	r30, r24
     21e:	35 83       	std	Z+5, r19	; 0x05
     220:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     222:	89 81       	ldd	r24, Y+1	; 0x01
     224:	9a 81       	ldd	r25, Y+2	; 0x02
     226:	fc 01       	movw	r30, r24
     228:	84 81       	ldd	r24, Z+4	; 0x04
     22a:	95 81       	ldd	r25, Z+5	; 0x05
     22c:	2d 81       	ldd	r18, Y+5	; 0x05
     22e:	3e 81       	ldd	r19, Y+6	; 0x06
     230:	fc 01       	movw	r30, r24
     232:	33 83       	std	Z+3, r19	; 0x03
     234:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	9a 81       	ldd	r25, Y+2	; 0x02
     23a:	2d 81       	ldd	r18, Y+5	; 0x05
     23c:	3e 81       	ldd	r19, Y+6	; 0x06
     23e:	fc 01       	movw	r30, r24
     240:	35 83       	std	Z+5, r19	; 0x05
     242:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     244:	8d 81       	ldd	r24, Y+5	; 0x05
     246:	9e 81       	ldd	r25, Y+6	; 0x06
     248:	2b 81       	ldd	r18, Y+3	; 0x03
     24a:	3c 81       	ldd	r19, Y+4	; 0x04
     24c:	fc 01       	movw	r30, r24
     24e:	31 87       	std	Z+9, r19	; 0x09
     250:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	9c 81       	ldd	r25, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	80 81       	ld	r24, Z
     25a:	21 e0       	ldi	r18, 0x01	; 1
     25c:	28 0f       	add	r18, r24
     25e:	8b 81       	ldd	r24, Y+3	; 0x03
     260:	9c 81       	ldd	r25, Y+4	; 0x04
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
}
     266:	26 96       	adiw	r28, 0x06	; 6
     268:	0f b6       	in	r0, 0x3f	; 63
     26a:	f8 94       	cli
     26c:	de bf       	out	0x3e, r29	; 62
     26e:	0f be       	out	0x3f, r0	; 63
     270:	cd bf       	out	0x3d, r28	; 61
     272:	df 91       	pop	r29
     274:	cf 91       	pop	r28
     276:	08 95       	ret

00000278 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	cd b7       	in	r28, 0x3d	; 61
     27e:	de b7       	in	r29, 0x3e	; 62
     280:	28 97       	sbiw	r28, 0x08	; 8
     282:	0f b6       	in	r0, 0x3f	; 63
     284:	f8 94       	cli
     286:	de bf       	out	0x3e, r29	; 62
     288:	0f be       	out	0x3f, r0	; 63
     28a:	cd bf       	out	0x3d, r28	; 61
     28c:	9e 83       	std	Y+6, r25	; 0x06
     28e:	8d 83       	std	Y+5, r24	; 0x05
     290:	78 87       	std	Y+8, r23	; 0x08
     292:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     294:	8f 81       	ldd	r24, Y+7	; 0x07
     296:	98 85       	ldd	r25, Y+8	; 0x08
     298:	fc 01       	movw	r30, r24
     29a:	80 81       	ld	r24, Z
     29c:	91 81       	ldd	r25, Z+1	; 0x01
     29e:	9c 83       	std	Y+4, r25	; 0x04
     2a0:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 96       	adiw	r24, 0x01	; 1
     2a8:	41 f4       	brne	.+16     	; 0x2ba <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2aa:	8d 81       	ldd	r24, Y+5	; 0x05
     2ac:	9e 81       	ldd	r25, Y+6	; 0x06
     2ae:	fc 01       	movw	r30, r24
     2b0:	87 81       	ldd	r24, Z+7	; 0x07
     2b2:	90 85       	ldd	r25, Z+8	; 0x08
     2b4:	9a 83       	std	Y+2, r25	; 0x02
     2b6:	89 83       	std	Y+1, r24	; 0x01
     2b8:	1a c0       	rjmp	.+52     	; 0x2ee <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ba:	8d 81       	ldd	r24, Y+5	; 0x05
     2bc:	9e 81       	ldd	r25, Y+6	; 0x06
     2be:	03 96       	adiw	r24, 0x03	; 3
     2c0:	9a 83       	std	Y+2, r25	; 0x02
     2c2:	89 83       	std	Y+1, r24	; 0x01
     2c4:	07 c0       	rjmp	.+14     	; 0x2d4 <vListInsert+0x5c>
     2c6:	89 81       	ldd	r24, Y+1	; 0x01
     2c8:	9a 81       	ldd	r25, Y+2	; 0x02
     2ca:	fc 01       	movw	r30, r24
     2cc:	82 81       	ldd	r24, Z+2	; 0x02
     2ce:	93 81       	ldd	r25, Z+3	; 0x03
     2d0:	9a 83       	std	Y+2, r25	; 0x02
     2d2:	89 83       	std	Y+1, r24	; 0x01
     2d4:	89 81       	ldd	r24, Y+1	; 0x01
     2d6:	9a 81       	ldd	r25, Y+2	; 0x02
     2d8:	fc 01       	movw	r30, r24
     2da:	82 81       	ldd	r24, Z+2	; 0x02
     2dc:	93 81       	ldd	r25, Z+3	; 0x03
     2de:	fc 01       	movw	r30, r24
     2e0:	20 81       	ld	r18, Z
     2e2:	31 81       	ldd	r19, Z+1	; 0x01
     2e4:	8b 81       	ldd	r24, Y+3	; 0x03
     2e6:	9c 81       	ldd	r25, Y+4	; 0x04
     2e8:	82 17       	cp	r24, r18
     2ea:	93 07       	cpc	r25, r19
     2ec:	60 f7       	brcc	.-40     	; 0x2c6 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2ee:	89 81       	ldd	r24, Y+1	; 0x01
     2f0:	9a 81       	ldd	r25, Y+2	; 0x02
     2f2:	fc 01       	movw	r30, r24
     2f4:	22 81       	ldd	r18, Z+2	; 0x02
     2f6:	33 81       	ldd	r19, Z+3	; 0x03
     2f8:	8f 81       	ldd	r24, Y+7	; 0x07
     2fa:	98 85       	ldd	r25, Y+8	; 0x08
     2fc:	fc 01       	movw	r30, r24
     2fe:	33 83       	std	Z+3, r19	; 0x03
     300:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     302:	8f 81       	ldd	r24, Y+7	; 0x07
     304:	98 85       	ldd	r25, Y+8	; 0x08
     306:	fc 01       	movw	r30, r24
     308:	82 81       	ldd	r24, Z+2	; 0x02
     30a:	93 81       	ldd	r25, Z+3	; 0x03
     30c:	2f 81       	ldd	r18, Y+7	; 0x07
     30e:	38 85       	ldd	r19, Y+8	; 0x08
     310:	fc 01       	movw	r30, r24
     312:	35 83       	std	Z+5, r19	; 0x05
     314:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     316:	8f 81       	ldd	r24, Y+7	; 0x07
     318:	98 85       	ldd	r25, Y+8	; 0x08
     31a:	29 81       	ldd	r18, Y+1	; 0x01
     31c:	3a 81       	ldd	r19, Y+2	; 0x02
     31e:	fc 01       	movw	r30, r24
     320:	35 83       	std	Z+5, r19	; 0x05
     322:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     324:	89 81       	ldd	r24, Y+1	; 0x01
     326:	9a 81       	ldd	r25, Y+2	; 0x02
     328:	2f 81       	ldd	r18, Y+7	; 0x07
     32a:	38 85       	ldd	r19, Y+8	; 0x08
     32c:	fc 01       	movw	r30, r24
     32e:	33 83       	std	Z+3, r19	; 0x03
     330:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     332:	8f 81       	ldd	r24, Y+7	; 0x07
     334:	98 85       	ldd	r25, Y+8	; 0x08
     336:	2d 81       	ldd	r18, Y+5	; 0x05
     338:	3e 81       	ldd	r19, Y+6	; 0x06
     33a:	fc 01       	movw	r30, r24
     33c:	31 87       	std	Z+9, r19	; 0x09
     33e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     340:	8d 81       	ldd	r24, Y+5	; 0x05
     342:	9e 81       	ldd	r25, Y+6	; 0x06
     344:	fc 01       	movw	r30, r24
     346:	80 81       	ld	r24, Z
     348:	21 e0       	ldi	r18, 0x01	; 1
     34a:	28 0f       	add	r18, r24
     34c:	8d 81       	ldd	r24, Y+5	; 0x05
     34e:	9e 81       	ldd	r25, Y+6	; 0x06
     350:	fc 01       	movw	r30, r24
     352:	20 83       	st	Z, r18
}
     354:	28 96       	adiw	r28, 0x08	; 8
     356:	0f b6       	in	r0, 0x3f	; 63
     358:	f8 94       	cli
     35a:	de bf       	out	0x3e, r29	; 62
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	cd bf       	out	0x3d, r28	; 61
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	08 95       	ret

00000366 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	00 d0       	rcall	.+0      	; 0x36c <uxListRemove+0x6>
     36c:	1f 92       	push	r1
     36e:	cd b7       	in	r28, 0x3d	; 61
     370:	de b7       	in	r29, 0x3e	; 62
     372:	9c 83       	std	Y+4, r25	; 0x04
     374:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     376:	8b 81       	ldd	r24, Y+3	; 0x03
     378:	9c 81       	ldd	r25, Y+4	; 0x04
     37a:	fc 01       	movw	r30, r24
     37c:	80 85       	ldd	r24, Z+8	; 0x08
     37e:	91 85       	ldd	r25, Z+9	; 0x09
     380:	9a 83       	std	Y+2, r25	; 0x02
     382:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     384:	8b 81       	ldd	r24, Y+3	; 0x03
     386:	9c 81       	ldd	r25, Y+4	; 0x04
     388:	fc 01       	movw	r30, r24
     38a:	82 81       	ldd	r24, Z+2	; 0x02
     38c:	93 81       	ldd	r25, Z+3	; 0x03
     38e:	2b 81       	ldd	r18, Y+3	; 0x03
     390:	3c 81       	ldd	r19, Y+4	; 0x04
     392:	f9 01       	movw	r30, r18
     394:	24 81       	ldd	r18, Z+4	; 0x04
     396:	35 81       	ldd	r19, Z+5	; 0x05
     398:	fc 01       	movw	r30, r24
     39a:	35 83       	std	Z+5, r19	; 0x05
     39c:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	fc 01       	movw	r30, r24
     3a4:	84 81       	ldd	r24, Z+4	; 0x04
     3a6:	95 81       	ldd	r25, Z+5	; 0x05
     3a8:	2b 81       	ldd	r18, Y+3	; 0x03
     3aa:	3c 81       	ldd	r19, Y+4	; 0x04
     3ac:	f9 01       	movw	r30, r18
     3ae:	22 81       	ldd	r18, Z+2	; 0x02
     3b0:	33 81       	ldd	r19, Z+3	; 0x03
     3b2:	fc 01       	movw	r30, r24
     3b4:	33 83       	std	Z+3, r19	; 0x03
     3b6:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3b8:	89 81       	ldd	r24, Y+1	; 0x01
     3ba:	9a 81       	ldd	r25, Y+2	; 0x02
     3bc:	fc 01       	movw	r30, r24
     3be:	21 81       	ldd	r18, Z+1	; 0x01
     3c0:	32 81       	ldd	r19, Z+2	; 0x02
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	28 17       	cp	r18, r24
     3c8:	39 07       	cpc	r19, r25
     3ca:	51 f4       	brne	.+20     	; 0x3e0 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3cc:	8b 81       	ldd	r24, Y+3	; 0x03
     3ce:	9c 81       	ldd	r25, Y+4	; 0x04
     3d0:	fc 01       	movw	r30, r24
     3d2:	24 81       	ldd	r18, Z+4	; 0x04
     3d4:	35 81       	ldd	r19, Z+5	; 0x05
     3d6:	89 81       	ldd	r24, Y+1	; 0x01
     3d8:	9a 81       	ldd	r25, Y+2	; 0x02
     3da:	fc 01       	movw	r30, r24
     3dc:	32 83       	std	Z+2, r19	; 0x02
     3de:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3e0:	8b 81       	ldd	r24, Y+3	; 0x03
     3e2:	9c 81       	ldd	r25, Y+4	; 0x04
     3e4:	fc 01       	movw	r30, r24
     3e6:	11 86       	std	Z+9, r1	; 0x09
     3e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3ea:	89 81       	ldd	r24, Y+1	; 0x01
     3ec:	9a 81       	ldd	r25, Y+2	; 0x02
     3ee:	fc 01       	movw	r30, r24
     3f0:	80 81       	ld	r24, Z
     3f2:	2f ef       	ldi	r18, 0xFF	; 255
     3f4:	28 0f       	add	r18, r24
     3f6:	89 81       	ldd	r24, Y+1	; 0x01
     3f8:	9a 81       	ldd	r25, Y+2	; 0x02
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     3fe:	89 81       	ldd	r24, Y+1	; 0x01
     400:	9a 81       	ldd	r25, Y+2	; 0x02
     402:	fc 01       	movw	r30, r24
     404:	80 81       	ld	r24, Z
}
     406:	0f 90       	pop	r0
     408:	0f 90       	pop	r0
     40a:	0f 90       	pop	r0
     40c:	0f 90       	pop	r0
     40e:	df 91       	pop	r29
     410:	cf 91       	pop	r28
     412:	08 95       	ret

00000414 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts

#endif
}
     414:	cf 93       	push	r28
     416:	df 93       	push	r29
     418:	cd b7       	in	r28, 0x3d	; 61
     41a:	de b7       	in	r29, 0x3e	; 62
     41c:	28 97       	sbiw	r28, 0x08	; 8
     41e:	0f b6       	in	r0, 0x3f	; 63
     420:	f8 94       	cli
     422:	de bf       	out	0x3e, r29	; 62
     424:	0f be       	out	0x3f, r0	; 63
     426:	cd bf       	out	0x3d, r28	; 61
     428:	9c 83       	std	Y+4, r25	; 0x04
     42a:	8b 83       	std	Y+3, r24	; 0x03
     42c:	7e 83       	std	Y+6, r23	; 0x06
     42e:	6d 83       	std	Y+5, r22	; 0x05
     430:	58 87       	std	Y+8, r21	; 0x08
     432:	4f 83       	std	Y+7, r20	; 0x07
     434:	8b 81       	ldd	r24, Y+3	; 0x03
     436:	9c 81       	ldd	r25, Y+4	; 0x04
     438:	21 e1       	ldi	r18, 0x11	; 17
     43a:	fc 01       	movw	r30, r24
     43c:	20 83       	st	Z, r18
     43e:	8b 81       	ldd	r24, Y+3	; 0x03
     440:	9c 81       	ldd	r25, Y+4	; 0x04
     442:	01 97       	sbiw	r24, 0x01	; 1
     444:	9c 83       	std	Y+4, r25	; 0x04
     446:	8b 83       	std	Y+3, r24	; 0x03
     448:	8b 81       	ldd	r24, Y+3	; 0x03
     44a:	9c 81       	ldd	r25, Y+4	; 0x04
     44c:	22 e2       	ldi	r18, 0x22	; 34
     44e:	fc 01       	movw	r30, r24
     450:	20 83       	st	Z, r18
     452:	8b 81       	ldd	r24, Y+3	; 0x03
     454:	9c 81       	ldd	r25, Y+4	; 0x04
     456:	01 97       	sbiw	r24, 0x01	; 1
     458:	9c 83       	std	Y+4, r25	; 0x04
     45a:	8b 83       	std	Y+3, r24	; 0x03
     45c:	8b 81       	ldd	r24, Y+3	; 0x03
     45e:	9c 81       	ldd	r25, Y+4	; 0x04
     460:	23 e3       	ldi	r18, 0x33	; 51
     462:	fc 01       	movw	r30, r24
     464:	20 83       	st	Z, r18
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
     470:	8d 81       	ldd	r24, Y+5	; 0x05
     472:	9e 81       	ldd	r25, Y+6	; 0x06
     474:	9a 83       	std	Y+2, r25	; 0x02
     476:	89 83       	std	Y+1, r24	; 0x01
     478:	29 81       	ldd	r18, Y+1	; 0x01
     47a:	8b 81       	ldd	r24, Y+3	; 0x03
     47c:	9c 81       	ldd	r25, Y+4	; 0x04
     47e:	fc 01       	movw	r30, r24
     480:	20 83       	st	Z, r18
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
     486:	01 97       	sbiw	r24, 0x01	; 1
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	8b 83       	std	Y+3, r24	; 0x03
     48c:	89 81       	ldd	r24, Y+1	; 0x01
     48e:	9a 81       	ldd	r25, Y+2	; 0x02
     490:	89 2f       	mov	r24, r25
     492:	99 27       	eor	r25, r25
     494:	9a 83       	std	Y+2, r25	; 0x02
     496:	89 83       	std	Y+1, r24	; 0x01
     498:	29 81       	ldd	r18, Y+1	; 0x01
     49a:	8b 81       	ldd	r24, Y+3	; 0x03
     49c:	9c 81       	ldd	r25, Y+4	; 0x04
     49e:	fc 01       	movw	r30, r24
     4a0:	20 83       	st	Z, r18
     4a2:	8b 81       	ldd	r24, Y+3	; 0x03
     4a4:	9c 81       	ldd	r25, Y+4	; 0x04
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	9c 83       	std	Y+4, r25	; 0x04
     4aa:	8b 83       	std	Y+3, r24	; 0x03
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	fc 01       	movw	r30, r24
     4b2:	10 82       	st	Z, r1
     4b4:	8b 81       	ldd	r24, Y+3	; 0x03
     4b6:	9c 81       	ldd	r25, Y+4	; 0x04
     4b8:	01 97       	sbiw	r24, 0x01	; 1
     4ba:	9c 83       	std	Y+4, r25	; 0x04
     4bc:	8b 83       	std	Y+3, r24	; 0x03
     4be:	8b 81       	ldd	r24, Y+3	; 0x03
     4c0:	9c 81       	ldd	r25, Y+4	; 0x04
     4c2:	fc 01       	movw	r30, r24
     4c4:	10 82       	st	Z, r1
     4c6:	8b 81       	ldd	r24, Y+3	; 0x03
     4c8:	9c 81       	ldd	r25, Y+4	; 0x04
     4ca:	01 97       	sbiw	r24, 0x01	; 1
     4cc:	9c 83       	std	Y+4, r25	; 0x04
     4ce:	8b 83       	std	Y+3, r24	; 0x03
     4d0:	8b 81       	ldd	r24, Y+3	; 0x03
     4d2:	9c 81       	ldd	r25, Y+4	; 0x04
     4d4:	20 e8       	ldi	r18, 0x80	; 128
     4d6:	fc 01       	movw	r30, r24
     4d8:	20 83       	st	Z, r18
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	9c 81       	ldd	r25, Y+4	; 0x04
     4de:	01 97       	sbiw	r24, 0x01	; 1
     4e0:	9c 83       	std	Y+4, r25	; 0x04
     4e2:	8b 83       	std	Y+3, r24	; 0x03
     4e4:	8b 81       	ldd	r24, Y+3	; 0x03
     4e6:	9c 81       	ldd	r25, Y+4	; 0x04
     4e8:	fc 01       	movw	r30, r24
     4ea:	10 82       	st	Z, r1
     4ec:	8b 81       	ldd	r24, Y+3	; 0x03
     4ee:	9c 81       	ldd	r25, Y+4	; 0x04
     4f0:	01 97       	sbiw	r24, 0x01	; 1
     4f2:	9c 83       	std	Y+4, r25	; 0x04
     4f4:	8b 83       	std	Y+3, r24	; 0x03
     4f6:	8b 81       	ldd	r24, Y+3	; 0x03
     4f8:	9c 81       	ldd	r25, Y+4	; 0x04
     4fa:	fc 01       	movw	r30, r24
     4fc:	10 82       	st	Z, r1
     4fe:	8b 81       	ldd	r24, Y+3	; 0x03
     500:	9c 81       	ldd	r25, Y+4	; 0x04
     502:	01 97       	sbiw	r24, 0x01	; 1
     504:	9c 83       	std	Y+4, r25	; 0x04
     506:	8b 83       	std	Y+3, r24	; 0x03
     508:	8b 81       	ldd	r24, Y+3	; 0x03
     50a:	9c 81       	ldd	r25, Y+4	; 0x04
     50c:	fc 01       	movw	r30, r24
     50e:	10 82       	st	Z, r1
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	01 97       	sbiw	r24, 0x01	; 1
     516:	9c 83       	std	Y+4, r25	; 0x04
     518:	8b 83       	std	Y+3, r24	; 0x03
     51a:	8b 81       	ldd	r24, Y+3	; 0x03
     51c:	9c 81       	ldd	r25, Y+4	; 0x04
     51e:	22 e0       	ldi	r18, 0x02	; 2
     520:	fc 01       	movw	r30, r24
     522:	20 83       	st	Z, r18
     524:	8b 81       	ldd	r24, Y+3	; 0x03
     526:	9c 81       	ldd	r25, Y+4	; 0x04
     528:	01 97       	sbiw	r24, 0x01	; 1
     52a:	9c 83       	std	Y+4, r25	; 0x04
     52c:	8b 83       	std	Y+3, r24	; 0x03
     52e:	8b 81       	ldd	r24, Y+3	; 0x03
     530:	9c 81       	ldd	r25, Y+4	; 0x04
     532:	23 e0       	ldi	r18, 0x03	; 3
     534:	fc 01       	movw	r30, r24
     536:	20 83       	st	Z, r18
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	01 97       	sbiw	r24, 0x01	; 1
     53e:	9c 83       	std	Y+4, r25	; 0x04
     540:	8b 83       	std	Y+3, r24	; 0x03
     542:	8b 81       	ldd	r24, Y+3	; 0x03
     544:	9c 81       	ldd	r25, Y+4	; 0x04
     546:	24 e0       	ldi	r18, 0x04	; 4
     548:	fc 01       	movw	r30, r24
     54a:	20 83       	st	Z, r18
     54c:	8b 81       	ldd	r24, Y+3	; 0x03
     54e:	9c 81       	ldd	r25, Y+4	; 0x04
     550:	01 97       	sbiw	r24, 0x01	; 1
     552:	9c 83       	std	Y+4, r25	; 0x04
     554:	8b 83       	std	Y+3, r24	; 0x03
     556:	8b 81       	ldd	r24, Y+3	; 0x03
     558:	9c 81       	ldd	r25, Y+4	; 0x04
     55a:	25 e0       	ldi	r18, 0x05	; 5
     55c:	fc 01       	movw	r30, r24
     55e:	20 83       	st	Z, r18
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	9c 81       	ldd	r25, Y+4	; 0x04
     564:	01 97       	sbiw	r24, 0x01	; 1
     566:	9c 83       	std	Y+4, r25	; 0x04
     568:	8b 83       	std	Y+3, r24	; 0x03
     56a:	8b 81       	ldd	r24, Y+3	; 0x03
     56c:	9c 81       	ldd	r25, Y+4	; 0x04
     56e:	26 e0       	ldi	r18, 0x06	; 6
     570:	fc 01       	movw	r30, r24
     572:	20 83       	st	Z, r18
     574:	8b 81       	ldd	r24, Y+3	; 0x03
     576:	9c 81       	ldd	r25, Y+4	; 0x04
     578:	01 97       	sbiw	r24, 0x01	; 1
     57a:	9c 83       	std	Y+4, r25	; 0x04
     57c:	8b 83       	std	Y+3, r24	; 0x03
     57e:	8b 81       	ldd	r24, Y+3	; 0x03
     580:	9c 81       	ldd	r25, Y+4	; 0x04
     582:	27 e0       	ldi	r18, 0x07	; 7
     584:	fc 01       	movw	r30, r24
     586:	20 83       	st	Z, r18
     588:	8b 81       	ldd	r24, Y+3	; 0x03
     58a:	9c 81       	ldd	r25, Y+4	; 0x04
     58c:	01 97       	sbiw	r24, 0x01	; 1
     58e:	9c 83       	std	Y+4, r25	; 0x04
     590:	8b 83       	std	Y+3, r24	; 0x03
     592:	8b 81       	ldd	r24, Y+3	; 0x03
     594:	9c 81       	ldd	r25, Y+4	; 0x04
     596:	28 e0       	ldi	r18, 0x08	; 8
     598:	fc 01       	movw	r30, r24
     59a:	20 83       	st	Z, r18
     59c:	8b 81       	ldd	r24, Y+3	; 0x03
     59e:	9c 81       	ldd	r25, Y+4	; 0x04
     5a0:	01 97       	sbiw	r24, 0x01	; 1
     5a2:	9c 83       	std	Y+4, r25	; 0x04
     5a4:	8b 83       	std	Y+3, r24	; 0x03
     5a6:	8b 81       	ldd	r24, Y+3	; 0x03
     5a8:	9c 81       	ldd	r25, Y+4	; 0x04
     5aa:	29 e0       	ldi	r18, 0x09	; 9
     5ac:	fc 01       	movw	r30, r24
     5ae:	20 83       	st	Z, r18
     5b0:	8b 81       	ldd	r24, Y+3	; 0x03
     5b2:	9c 81       	ldd	r25, Y+4	; 0x04
     5b4:	01 97       	sbiw	r24, 0x01	; 1
     5b6:	9c 83       	std	Y+4, r25	; 0x04
     5b8:	8b 83       	std	Y+3, r24	; 0x03
     5ba:	8b 81       	ldd	r24, Y+3	; 0x03
     5bc:	9c 81       	ldd	r25, Y+4	; 0x04
     5be:	20 e1       	ldi	r18, 0x10	; 16
     5c0:	fc 01       	movw	r30, r24
     5c2:	20 83       	st	Z, r18
     5c4:	8b 81       	ldd	r24, Y+3	; 0x03
     5c6:	9c 81       	ldd	r25, Y+4	; 0x04
     5c8:	01 97       	sbiw	r24, 0x01	; 1
     5ca:	9c 83       	std	Y+4, r25	; 0x04
     5cc:	8b 83       	std	Y+3, r24	; 0x03
     5ce:	8b 81       	ldd	r24, Y+3	; 0x03
     5d0:	9c 81       	ldd	r25, Y+4	; 0x04
     5d2:	21 e1       	ldi	r18, 0x11	; 17
     5d4:	fc 01       	movw	r30, r24
     5d6:	20 83       	st	Z, r18
     5d8:	8b 81       	ldd	r24, Y+3	; 0x03
     5da:	9c 81       	ldd	r25, Y+4	; 0x04
     5dc:	01 97       	sbiw	r24, 0x01	; 1
     5de:	9c 83       	std	Y+4, r25	; 0x04
     5e0:	8b 83       	std	Y+3, r24	; 0x03
     5e2:	8b 81       	ldd	r24, Y+3	; 0x03
     5e4:	9c 81       	ldd	r25, Y+4	; 0x04
     5e6:	22 e1       	ldi	r18, 0x12	; 18
     5e8:	fc 01       	movw	r30, r24
     5ea:	20 83       	st	Z, r18
     5ec:	8b 81       	ldd	r24, Y+3	; 0x03
     5ee:	9c 81       	ldd	r25, Y+4	; 0x04
     5f0:	01 97       	sbiw	r24, 0x01	; 1
     5f2:	9c 83       	std	Y+4, r25	; 0x04
     5f4:	8b 83       	std	Y+3, r24	; 0x03
     5f6:	8b 81       	ldd	r24, Y+3	; 0x03
     5f8:	9c 81       	ldd	r25, Y+4	; 0x04
     5fa:	23 e1       	ldi	r18, 0x13	; 19
     5fc:	fc 01       	movw	r30, r24
     5fe:	20 83       	st	Z, r18
     600:	8b 81       	ldd	r24, Y+3	; 0x03
     602:	9c 81       	ldd	r25, Y+4	; 0x04
     604:	01 97       	sbiw	r24, 0x01	; 1
     606:	9c 83       	std	Y+4, r25	; 0x04
     608:	8b 83       	std	Y+3, r24	; 0x03
     60a:	8b 81       	ldd	r24, Y+3	; 0x03
     60c:	9c 81       	ldd	r25, Y+4	; 0x04
     60e:	24 e1       	ldi	r18, 0x14	; 20
     610:	fc 01       	movw	r30, r24
     612:	20 83       	st	Z, r18
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	9c 81       	ldd	r25, Y+4	; 0x04
     618:	01 97       	sbiw	r24, 0x01	; 1
     61a:	9c 83       	std	Y+4, r25	; 0x04
     61c:	8b 83       	std	Y+3, r24	; 0x03
     61e:	8b 81       	ldd	r24, Y+3	; 0x03
     620:	9c 81       	ldd	r25, Y+4	; 0x04
     622:	25 e1       	ldi	r18, 0x15	; 21
     624:	fc 01       	movw	r30, r24
     626:	20 83       	st	Z, r18
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	9c 81       	ldd	r25, Y+4	; 0x04
     62c:	01 97       	sbiw	r24, 0x01	; 1
     62e:	9c 83       	std	Y+4, r25	; 0x04
     630:	8b 83       	std	Y+3, r24	; 0x03
     632:	8b 81       	ldd	r24, Y+3	; 0x03
     634:	9c 81       	ldd	r25, Y+4	; 0x04
     636:	26 e1       	ldi	r18, 0x16	; 22
     638:	fc 01       	movw	r30, r24
     63a:	20 83       	st	Z, r18
     63c:	8b 81       	ldd	r24, Y+3	; 0x03
     63e:	9c 81       	ldd	r25, Y+4	; 0x04
     640:	01 97       	sbiw	r24, 0x01	; 1
     642:	9c 83       	std	Y+4, r25	; 0x04
     644:	8b 83       	std	Y+3, r24	; 0x03
     646:	8b 81       	ldd	r24, Y+3	; 0x03
     648:	9c 81       	ldd	r25, Y+4	; 0x04
     64a:	27 e1       	ldi	r18, 0x17	; 23
     64c:	fc 01       	movw	r30, r24
     64e:	20 83       	st	Z, r18
     650:	8b 81       	ldd	r24, Y+3	; 0x03
     652:	9c 81       	ldd	r25, Y+4	; 0x04
     654:	01 97       	sbiw	r24, 0x01	; 1
     656:	9c 83       	std	Y+4, r25	; 0x04
     658:	8b 83       	std	Y+3, r24	; 0x03
     65a:	8b 81       	ldd	r24, Y+3	; 0x03
     65c:	9c 81       	ldd	r25, Y+4	; 0x04
     65e:	28 e1       	ldi	r18, 0x18	; 24
     660:	fc 01       	movw	r30, r24
     662:	20 83       	st	Z, r18
     664:	8b 81       	ldd	r24, Y+3	; 0x03
     666:	9c 81       	ldd	r25, Y+4	; 0x04
     668:	01 97       	sbiw	r24, 0x01	; 1
     66a:	9c 83       	std	Y+4, r25	; 0x04
     66c:	8b 83       	std	Y+3, r24	; 0x03
     66e:	8b 81       	ldd	r24, Y+3	; 0x03
     670:	9c 81       	ldd	r25, Y+4	; 0x04
     672:	29 e1       	ldi	r18, 0x19	; 25
     674:	fc 01       	movw	r30, r24
     676:	20 83       	st	Z, r18
     678:	8b 81       	ldd	r24, Y+3	; 0x03
     67a:	9c 81       	ldd	r25, Y+4	; 0x04
     67c:	01 97       	sbiw	r24, 0x01	; 1
     67e:	9c 83       	std	Y+4, r25	; 0x04
     680:	8b 83       	std	Y+3, r24	; 0x03
     682:	8b 81       	ldd	r24, Y+3	; 0x03
     684:	9c 81       	ldd	r25, Y+4	; 0x04
     686:	20 e2       	ldi	r18, 0x20	; 32
     688:	fc 01       	movw	r30, r24
     68a:	20 83       	st	Z, r18
     68c:	8b 81       	ldd	r24, Y+3	; 0x03
     68e:	9c 81       	ldd	r25, Y+4	; 0x04
     690:	01 97       	sbiw	r24, 0x01	; 1
     692:	9c 83       	std	Y+4, r25	; 0x04
     694:	8b 83       	std	Y+3, r24	; 0x03
     696:	8b 81       	ldd	r24, Y+3	; 0x03
     698:	9c 81       	ldd	r25, Y+4	; 0x04
     69a:	21 e2       	ldi	r18, 0x21	; 33
     69c:	fc 01       	movw	r30, r24
     69e:	20 83       	st	Z, r18
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	9c 81       	ldd	r25, Y+4	; 0x04
     6a4:	01 97       	sbiw	r24, 0x01	; 1
     6a6:	9c 83       	std	Y+4, r25	; 0x04
     6a8:	8b 83       	std	Y+3, r24	; 0x03
     6aa:	8b 81       	ldd	r24, Y+3	; 0x03
     6ac:	9c 81       	ldd	r25, Y+4	; 0x04
     6ae:	22 e2       	ldi	r18, 0x22	; 34
     6b0:	fc 01       	movw	r30, r24
     6b2:	20 83       	st	Z, r18
     6b4:	8b 81       	ldd	r24, Y+3	; 0x03
     6b6:	9c 81       	ldd	r25, Y+4	; 0x04
     6b8:	01 97       	sbiw	r24, 0x01	; 1
     6ba:	9c 83       	std	Y+4, r25	; 0x04
     6bc:	8b 83       	std	Y+3, r24	; 0x03
     6be:	8b 81       	ldd	r24, Y+3	; 0x03
     6c0:	9c 81       	ldd	r25, Y+4	; 0x04
     6c2:	23 e2       	ldi	r18, 0x23	; 35
     6c4:	fc 01       	movw	r30, r24
     6c6:	20 83       	st	Z, r18
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	9c 81       	ldd	r25, Y+4	; 0x04
     6cc:	01 97       	sbiw	r24, 0x01	; 1
     6ce:	9c 83       	std	Y+4, r25	; 0x04
     6d0:	8b 83       	std	Y+3, r24	; 0x03
     6d2:	8f 81       	ldd	r24, Y+7	; 0x07
     6d4:	98 85       	ldd	r25, Y+8	; 0x08
     6d6:	9a 83       	std	Y+2, r25	; 0x02
     6d8:	89 83       	std	Y+1, r24	; 0x01
     6da:	29 81       	ldd	r18, Y+1	; 0x01
     6dc:	8b 81       	ldd	r24, Y+3	; 0x03
     6de:	9c 81       	ldd	r25, Y+4	; 0x04
     6e0:	fc 01       	movw	r30, r24
     6e2:	20 83       	st	Z, r18
     6e4:	8b 81       	ldd	r24, Y+3	; 0x03
     6e6:	9c 81       	ldd	r25, Y+4	; 0x04
     6e8:	01 97       	sbiw	r24, 0x01	; 1
     6ea:	9c 83       	std	Y+4, r25	; 0x04
     6ec:	8b 83       	std	Y+3, r24	; 0x03
     6ee:	89 81       	ldd	r24, Y+1	; 0x01
     6f0:	9a 81       	ldd	r25, Y+2	; 0x02
     6f2:	89 2f       	mov	r24, r25
     6f4:	99 27       	eor	r25, r25
     6f6:	9a 83       	std	Y+2, r25	; 0x02
     6f8:	89 83       	std	Y+1, r24	; 0x01
     6fa:	29 81       	ldd	r18, Y+1	; 0x01
     6fc:	8b 81       	ldd	r24, Y+3	; 0x03
     6fe:	9c 81       	ldd	r25, Y+4	; 0x04
     700:	fc 01       	movw	r30, r24
     702:	20 83       	st	Z, r18
     704:	8b 81       	ldd	r24, Y+3	; 0x03
     706:	9c 81       	ldd	r25, Y+4	; 0x04
     708:	01 97       	sbiw	r24, 0x01	; 1
     70a:	9c 83       	std	Y+4, r25	; 0x04
     70c:	8b 83       	std	Y+3, r24	; 0x03
     70e:	8b 81       	ldd	r24, Y+3	; 0x03
     710:	9c 81       	ldd	r25, Y+4	; 0x04
     712:	26 e2       	ldi	r18, 0x26	; 38
     714:	fc 01       	movw	r30, r24
     716:	20 83       	st	Z, r18
     718:	8b 81       	ldd	r24, Y+3	; 0x03
     71a:	9c 81       	ldd	r25, Y+4	; 0x04
     71c:	01 97       	sbiw	r24, 0x01	; 1
     71e:	9c 83       	std	Y+4, r25	; 0x04
     720:	8b 83       	std	Y+3, r24	; 0x03
     722:	8b 81       	ldd	r24, Y+3	; 0x03
     724:	9c 81       	ldd	r25, Y+4	; 0x04
     726:	27 e2       	ldi	r18, 0x27	; 39
     728:	fc 01       	movw	r30, r24
     72a:	20 83       	st	Z, r18
     72c:	8b 81       	ldd	r24, Y+3	; 0x03
     72e:	9c 81       	ldd	r25, Y+4	; 0x04
     730:	01 97       	sbiw	r24, 0x01	; 1
     732:	9c 83       	std	Y+4, r25	; 0x04
     734:	8b 83       	std	Y+3, r24	; 0x03
     736:	8b 81       	ldd	r24, Y+3	; 0x03
     738:	9c 81       	ldd	r25, Y+4	; 0x04
     73a:	28 e2       	ldi	r18, 0x28	; 40
     73c:	fc 01       	movw	r30, r24
     73e:	20 83       	st	Z, r18
     740:	8b 81       	ldd	r24, Y+3	; 0x03
     742:	9c 81       	ldd	r25, Y+4	; 0x04
     744:	01 97       	sbiw	r24, 0x01	; 1
     746:	9c 83       	std	Y+4, r25	; 0x04
     748:	8b 83       	std	Y+3, r24	; 0x03
     74a:	8b 81       	ldd	r24, Y+3	; 0x03
     74c:	9c 81       	ldd	r25, Y+4	; 0x04
     74e:	29 e2       	ldi	r18, 0x29	; 41
     750:	fc 01       	movw	r30, r24
     752:	20 83       	st	Z, r18
     754:	8b 81       	ldd	r24, Y+3	; 0x03
     756:	9c 81       	ldd	r25, Y+4	; 0x04
     758:	01 97       	sbiw	r24, 0x01	; 1
     75a:	9c 83       	std	Y+4, r25	; 0x04
     75c:	8b 83       	std	Y+3, r24	; 0x03
     75e:	8b 81       	ldd	r24, Y+3	; 0x03
     760:	9c 81       	ldd	r25, Y+4	; 0x04
     762:	20 e3       	ldi	r18, 0x30	; 48
     764:	fc 01       	movw	r30, r24
     766:	20 83       	st	Z, r18
     768:	8b 81       	ldd	r24, Y+3	; 0x03
     76a:	9c 81       	ldd	r25, Y+4	; 0x04
     76c:	01 97       	sbiw	r24, 0x01	; 1
     76e:	9c 83       	std	Y+4, r25	; 0x04
     770:	8b 83       	std	Y+3, r24	; 0x03
     772:	8b 81       	ldd	r24, Y+3	; 0x03
     774:	9c 81       	ldd	r25, Y+4	; 0x04
     776:	21 e3       	ldi	r18, 0x31	; 49
     778:	fc 01       	movw	r30, r24
     77a:	20 83       	st	Z, r18
     77c:	8b 81       	ldd	r24, Y+3	; 0x03
     77e:	9c 81       	ldd	r25, Y+4	; 0x04
     780:	01 97       	sbiw	r24, 0x01	; 1
     782:	9c 83       	std	Y+4, r25	; 0x04
     784:	8b 83       	std	Y+3, r24	; 0x03
     786:	8b 81       	ldd	r24, Y+3	; 0x03
     788:	9c 81       	ldd	r25, Y+4	; 0x04
     78a:	28 96       	adiw	r28, 0x08	; 8
     78c:	0f b6       	in	r0, 0x3f	; 63
     78e:	f8 94       	cli
     790:	de bf       	out	0x3e, r29	; 62
     792:	0f be       	out	0x3f, r0	; 63
     794:	cd bf       	out	0x3d, r28	; 61
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret

0000079c <xPortStartScheduler>:
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	cd b7       	in	r28, 0x3d	; 61
     7a2:	de b7       	in	r29, 0x3e	; 62
     7a4:	0d d1       	rcall	.+538    	; 0x9c0 <prvSetupTimerInterrupt>
     7a6:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
     7aa:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
     7ae:	cd 91       	ld	r28, X+
     7b0:	cd bf       	out	0x3d, r28	; 61
     7b2:	dd 91       	ld	r29, X+
     7b4:	de bf       	out	0x3e, r29	; 62
     7b6:	ff 91       	pop	r31
     7b8:	ef 91       	pop	r30
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	bf 91       	pop	r27
     7c0:	af 91       	pop	r26
     7c2:	9f 91       	pop	r25
     7c4:	8f 91       	pop	r24
     7c6:	7f 91       	pop	r23
     7c8:	6f 91       	pop	r22
     7ca:	5f 91       	pop	r21
     7cc:	4f 91       	pop	r20
     7ce:	3f 91       	pop	r19
     7d0:	2f 91       	pop	r18
     7d2:	1f 91       	pop	r17
     7d4:	0f 91       	pop	r16
     7d6:	ff 90       	pop	r15
     7d8:	ef 90       	pop	r14
     7da:	df 90       	pop	r13
     7dc:	cf 90       	pop	r12
     7de:	bf 90       	pop	r11
     7e0:	af 90       	pop	r10
     7e2:	9f 90       	pop	r9
     7e4:	8f 90       	pop	r8
     7e6:	7f 90       	pop	r7
     7e8:	6f 90       	pop	r6
     7ea:	5f 90       	pop	r5
     7ec:	4f 90       	pop	r4
     7ee:	3f 90       	pop	r3
     7f0:	2f 90       	pop	r2
     7f2:	1f 90       	pop	r1
     7f4:	0f 90       	pop	r0
     7f6:	0c be       	out	0x3c, r0	; 60
     7f8:	0f 90       	pop	r0
     7fa:	0b be       	out	0x3b, r0	; 59
     7fc:	0f 90       	pop	r0
     7fe:	0f be       	out	0x3f, r0	; 63
     800:	0f 90       	pop	r0
     802:	08 95       	ret
     804:	81 e0       	ldi	r24, 0x01	; 1
     806:	df 91       	pop	r29
     808:	cf 91       	pop	r28
     80a:	08 95       	ret

0000080c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     80c:	0f 92       	push	r0
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	0f 92       	push	r0
     814:	0b b6       	in	r0, 0x3b	; 59
     816:	0f 92       	push	r0
     818:	0c b6       	in	r0, 0x3c	; 60
     81a:	0f 92       	push	r0
     81c:	1f 92       	push	r1
     81e:	11 24       	eor	r1, r1
     820:	2f 92       	push	r2
     822:	3f 92       	push	r3
     824:	4f 92       	push	r4
     826:	5f 92       	push	r5
     828:	6f 92       	push	r6
     82a:	7f 92       	push	r7
     82c:	8f 92       	push	r8
     82e:	9f 92       	push	r9
     830:	af 92       	push	r10
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	2f 93       	push	r18
     842:	3f 93       	push	r19
     844:	4f 93       	push	r20
     846:	5f 93       	push	r21
     848:	6f 93       	push	r22
     84a:	7f 93       	push	r23
     84c:	8f 93       	push	r24
     84e:	9f 93       	push	r25
     850:	af 93       	push	r26
     852:	bf 93       	push	r27
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	ef 93       	push	r30
     85a:	ff 93       	push	r31
     85c:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
     860:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
     864:	0d b6       	in	r0, 0x3d	; 61
     866:	0d 92       	st	X+, r0
     868:	0e b6       	in	r0, 0x3e	; 62
     86a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     86c:	28 d7       	rcall	.+3664   	; 0x16be <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     86e:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
     872:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
     876:	cd 91       	ld	r28, X+
     878:	cd bf       	out	0x3d, r28	; 61
     87a:	dd 91       	ld	r29, X+
     87c:	de bf       	out	0x3e, r29	; 62
     87e:	ff 91       	pop	r31
     880:	ef 91       	pop	r30
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	bf 91       	pop	r27
     888:	af 91       	pop	r26
     88a:	9f 91       	pop	r25
     88c:	8f 91       	pop	r24
     88e:	7f 91       	pop	r23
     890:	6f 91       	pop	r22
     892:	5f 91       	pop	r21
     894:	4f 91       	pop	r20
     896:	3f 91       	pop	r19
     898:	2f 91       	pop	r18
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	ef 90       	pop	r14
     8a2:	df 90       	pop	r13
     8a4:	cf 90       	pop	r12
     8a6:	bf 90       	pop	r11
     8a8:	af 90       	pop	r10
     8aa:	9f 90       	pop	r9
     8ac:	8f 90       	pop	r8
     8ae:	7f 90       	pop	r7
     8b0:	6f 90       	pop	r6
     8b2:	5f 90       	pop	r5
     8b4:	4f 90       	pop	r4
     8b6:	3f 90       	pop	r3
     8b8:	2f 90       	pop	r2
     8ba:	1f 90       	pop	r1
     8bc:	0f 90       	pop	r0
     8be:	0c be       	out	0x3c, r0	; 60
     8c0:	0f 90       	pop	r0
     8c2:	0b be       	out	0x3b, r0	; 59
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63
     8c8:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     8ca:	08 95       	ret

000008cc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     8cc:	0f 92       	push	r0
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	f8 94       	cli
     8d2:	0f 92       	push	r0
     8d4:	0b b6       	in	r0, 0x3b	; 59
     8d6:	0f 92       	push	r0
     8d8:	0c b6       	in	r0, 0x3c	; 60
     8da:	0f 92       	push	r0
     8dc:	1f 92       	push	r1
     8de:	11 24       	eor	r1, r1
     8e0:	2f 92       	push	r2
     8e2:	3f 92       	push	r3
     8e4:	4f 92       	push	r4
     8e6:	5f 92       	push	r5
     8e8:	6f 92       	push	r6
     8ea:	7f 92       	push	r7
     8ec:	8f 92       	push	r8
     8ee:	9f 92       	push	r9
     8f0:	af 92       	push	r10
     8f2:	bf 92       	push	r11
     8f4:	cf 92       	push	r12
     8f6:	df 92       	push	r13
     8f8:	ef 92       	push	r14
     8fa:	ff 92       	push	r15
     8fc:	0f 93       	push	r16
     8fe:	1f 93       	push	r17
     900:	2f 93       	push	r18
     902:	3f 93       	push	r19
     904:	4f 93       	push	r20
     906:	5f 93       	push	r21
     908:	6f 93       	push	r22
     90a:	7f 93       	push	r23
     90c:	8f 93       	push	r24
     90e:	9f 93       	push	r25
     910:	af 93       	push	r26
     912:	bf 93       	push	r27
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
     918:	ef 93       	push	r30
     91a:	ff 93       	push	r31
     91c:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
     920:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
     924:	0d b6       	in	r0, 0x3d	; 61
     926:	0d 92       	st	X+, r0
     928:	0e b6       	in	r0, 0x3e	; 62
     92a:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
     92c:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <ticksRemainingInSec>
     930:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <ticksRemainingInSec+0x1>
     934:	01 97       	sbiw	r24, 0x01	; 1
     936:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <ticksRemainingInSec+0x1>
     93a:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <ticksRemainingInSec>
     93e:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <ticksRemainingInSec>
     942:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <ticksRemainingInSec+0x1>
     946:	89 2b       	or	r24, r25
     948:	41 f4       	brne	.+16     	; 0x95a <vPortYieldFromTick+0x8e>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
     94a:	80 91 1c 02 	lds	r24, 0x021C	; 0x80021c <__data_end>
     94e:	90 91 1d 02 	lds	r25, 0x021D	; 0x80021d <__data_end+0x1>
     952:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <ticksRemainingInSec+0x1>
     956:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <ticksRemainingInSec>
	}

	if( xTaskIncrementTick() != pdFALSE )
     95a:	c4 d5       	rcall	.+2952   	; 0x14e4 <xTaskIncrementTick>
     95c:	88 23       	and	r24, r24
     95e:	09 f0       	breq	.+2      	; 0x962 <vPortYieldFromTick+0x96>
	{
		vTaskSwitchContext();
     960:	ae d6       	rcall	.+3420   	; 0x16be <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     962:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
     966:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
     96a:	cd 91       	ld	r28, X+
     96c:	cd bf       	out	0x3d, r28	; 61
     96e:	dd 91       	ld	r29, X+
     970:	de bf       	out	0x3e, r29	; 62
     972:	ff 91       	pop	r31
     974:	ef 91       	pop	r30
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	bf 91       	pop	r27
     97c:	af 91       	pop	r26
     97e:	9f 91       	pop	r25
     980:	8f 91       	pop	r24
     982:	7f 91       	pop	r23
     984:	6f 91       	pop	r22
     986:	5f 91       	pop	r21
     988:	4f 91       	pop	r20
     98a:	3f 91       	pop	r19
     98c:	2f 91       	pop	r18
     98e:	1f 91       	pop	r17
     990:	0f 91       	pop	r16
     992:	ff 90       	pop	r15
     994:	ef 90       	pop	r14
     996:	df 90       	pop	r13
     998:	cf 90       	pop	r12
     99a:	bf 90       	pop	r11
     99c:	af 90       	pop	r10
     99e:	9f 90       	pop	r9
     9a0:	8f 90       	pop	r8
     9a2:	7f 90       	pop	r7
     9a4:	6f 90       	pop	r6
     9a6:	5f 90       	pop	r5
     9a8:	4f 90       	pop	r4
     9aa:	3f 90       	pop	r3
     9ac:	2f 90       	pop	r2
     9ae:	1f 90       	pop	r1
     9b0:	0f 90       	pop	r0
     9b2:	0c be       	out	0x3c, r0	; 60
     9b4:	0f 90       	pop	r0
     9b6:	0b be       	out	0x3b, r0	; 59
     9b8:	0f 90       	pop	r0
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     9be:	08 95       	ret

000009c0 <prvSetupTimerInterrupt>:
#ifndef portUSE_TIMER2
/*
 * Setup timer 0 or 1 or 3 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	cd b7       	in	r28, 0x3d	; 61
     9c6:	de b7       	in	r29, 0x3e	; 62
     9c8:	2a 97       	sbiw	r28, 0x0a	; 10
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	de bf       	out	0x3e, r29	; 62
     9d0:	0f be       	out	0x3f, r0	; 63
     9d2:	cd bf       	out	0x3d, r28	; 61
    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock.*/

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     9d4:	80 e1       	ldi	r24, 0x10	; 16
     9d6:	97 e2       	ldi	r25, 0x27	; 39
     9d8:	a0 e0       	ldi	r26, 0x00	; 0
     9da:	b0 e0       	ldi	r27, 0x00	; 0
     9dc:	89 83       	std	Y+1, r24	; 0x01
     9de:	9a 83       	std	Y+2, r25	; 0x02
     9e0:	ab 83       	std	Y+3, r26	; 0x03
     9e2:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
     9e4:	89 81       	ldd	r24, Y+1	; 0x01
     9e6:	9a 81       	ldd	r25, Y+2	; 0x02
     9e8:	ab 81       	ldd	r26, Y+3	; 0x03
     9ea:	bc 81       	ldd	r27, Y+4	; 0x04
     9ec:	68 94       	set
     9ee:	15 f8       	bld	r1, 5
     9f0:	b6 95       	lsr	r27
     9f2:	a7 95       	ror	r26
     9f4:	97 95       	ror	r25
     9f6:	87 95       	ror	r24
     9f8:	16 94       	lsr	r1
     9fa:	d1 f7       	brne	.-12     	; 0x9f0 <prvSetupTimerInterrupt+0x30>
     9fc:	89 83       	std	Y+1, r24	; 0x01
     9fe:	9a 83       	std	Y+2, r25	; 0x02
     a00:	ab 83       	std	Y+3, r26	; 0x03
     a02:	bc 83       	std	Y+4, r27	; 0x04

 	/* actual port tick rate in Hz, calculated */
	portTickRateHz = (TickType_t) ((uint32_t) configCPU_CLOCK_HZ / ( portCLOCK_PRESCALER * ulCompareMatch ));
     a04:	89 81       	ldd	r24, Y+1	; 0x01
     a06:	9a 81       	ldd	r25, Y+2	; 0x02
     a08:	ab 81       	ldd	r26, Y+3	; 0x03
     a0a:	bc 81       	ldd	r27, Y+4	; 0x04
     a0c:	88 0f       	add	r24, r24
     a0e:	99 1f       	adc	r25, r25
     a10:	aa 1f       	adc	r26, r26
     a12:	bb 1f       	adc	r27, r27
     a14:	88 0f       	add	r24, r24
     a16:	99 1f       	adc	r25, r25
     a18:	aa 1f       	adc	r26, r26
     a1a:	bb 1f       	adc	r27, r27
     a1c:	88 0f       	add	r24, r24
     a1e:	99 1f       	adc	r25, r25
     a20:	aa 1f       	adc	r26, r26
     a22:	bb 1f       	adc	r27, r27
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	aa 1f       	adc	r26, r26
     a2a:	bb 1f       	adc	r27, r27
     a2c:	88 0f       	add	r24, r24
     a2e:	99 1f       	adc	r25, r25
     a30:	aa 1f       	adc	r26, r26
     a32:	bb 1f       	adc	r27, r27
     a34:	88 0f       	add	r24, r24
     a36:	99 1f       	adc	r25, r25
     a38:	aa 1f       	adc	r26, r26
     a3a:	bb 1f       	adc	r27, r27
     a3c:	9c 01       	movw	r18, r24
     a3e:	ad 01       	movw	r20, r26
     a40:	80 e8       	ldi	r24, 0x80	; 128
     a42:	96 e9       	ldi	r25, 0x96	; 150
     a44:	a8 e9       	ldi	r26, 0x98	; 152
     a46:	b0 e0       	ldi	r27, 0x00	; 0
     a48:	bc 01       	movw	r22, r24
     a4a:	cd 01       	movw	r24, r26
     a4c:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__udivmodsi4>
     a50:	da 01       	movw	r26, r20
     a52:	c9 01       	movw	r24, r18
     a54:	90 93 1d 02 	sts	0x021D, r25	; 0x80021d <__data_end+0x1>
     a58:	80 93 1c 02 	sts	0x021C, r24	; 0x80021c <__data_end>
	/* initialise first second of ticks */
	ticksRemainingInSec = portTickRateHz;
     a5c:	80 91 1c 02 	lds	r24, 0x021C	; 0x80021c <__data_end>
     a60:	90 91 1d 02 	lds	r25, 0x021D	; 0x80021d <__data_end+0x1>
     a64:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <ticksRemainingInSec+0x1>
     a68:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <ticksRemainingInSec>

    /* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     a6c:	89 81       	ldd	r24, Y+1	; 0x01
     a6e:	9a 81       	ldd	r25, Y+2	; 0x02
     a70:	ab 81       	ldd	r26, Y+3	; 0x03
     a72:	bc 81       	ldd	r27, Y+4	; 0x04
     a74:	01 97       	sbiw	r24, 0x01	; 1
     a76:	a1 09       	sbc	r26, r1
     a78:	b1 09       	sbc	r27, r1
     a7a:	89 83       	std	Y+1, r24	; 0x01
     a7c:	9a 83       	std	Y+2, r25	; 0x02
     a7e:	ab 83       	std	Y+3, r26	; 0x03
     a80:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     a82:	89 81       	ldd	r24, Y+1	; 0x01
     a84:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AH = ucHighByte;
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH
    ulCompareMatch >>= 8;
     a86:	89 81       	ldd	r24, Y+1	; 0x01
     a88:	9a 81       	ldd	r25, Y+2	; 0x02
     a8a:	ab 81       	ldd	r26, Y+3	; 0x03
     a8c:	bc 81       	ldd	r27, Y+4	; 0x04
     a8e:	89 2f       	mov	r24, r25
     a90:	9a 2f       	mov	r25, r26
     a92:	ab 2f       	mov	r26, r27
     a94:	bb 27       	eor	r27, r27
     a96:	89 83       	std	Y+1, r24	; 0x01
     a98:	9a 83       	std	Y+2, r25	; 0x02
     a9a:	ab 83       	std	Y+3, r26	; 0x03
     a9c:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t) 0xff );
     a9e:	89 81       	ldd	r24, Y+1	; 0x01
     aa0:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
     aa2:	89 e9       	ldi	r24, 0x99	; 153
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	2e 81       	ldd	r18, Y+6	; 0x06
     aa8:	fc 01       	movw	r30, r24
     aaa:	20 83       	st	Z, r18
#endif

    portOCRL = ucLowByte;
     aac:	88 e9       	ldi	r24, 0x98	; 152
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	2d 81       	ldd	r18, Y+5	; 0x05
     ab2:	fc 01       	movw	r30, r24
     ab4:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     ab6:	8b e0       	ldi	r24, 0x0B	; 11
     ab8:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
     aba:	81 e9       	ldi	r24, 0x91	; 145
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	2d 81       	ldd	r18, Y+5	; 0x05
     ac0:	fc 01       	movw	r30, r24
     ac2:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     ac4:	81 e7       	ldi	r24, 0x71	; 113
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	fc 01       	movw	r30, r24
     aca:	80 81       	ld	r24, Z
     acc:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     ace:	8d 81       	ldd	r24, Y+5	; 0x05
     ad0:	82 60       	ori	r24, 0x02	; 2
     ad2:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
     ad4:	81 e7       	ldi	r24, 0x71	; 113
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	2d 81       	ldd	r18, Y+5	; 0x05
     ada:	fc 01       	movw	r30, r24
     adc:	20 83       	st	Z, r18

}
     ade:	2a 96       	adiw	r28, 0x0a	; 10
     ae0:	0f b6       	in	r0, 0x3f	; 63
     ae2:	f8 94       	cli
     ae4:	de bf       	out	0x3e, r29	; 62
     ae6:	0f be       	out	0x3f, r0	; 63
     ae8:	cd bf       	out	0x3d, r28	; 61
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	08 95       	ret

00000af0 <__vector_32>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
     af0:	ed de       	rcall	.-550    	; 0x8cc <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     af2:	18 95       	reti

00000af4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     af4:	cf 93       	push	r28
     af6:	df 93       	push	r29
     af8:	00 d0       	rcall	.+0      	; 0xafa <pvPortMalloc+0x6>
     afa:	1f 92       	push	r1
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
     b00:	9c 83       	std	Y+4, r25	; 0x04
     b02:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     b04:	1a 82       	std	Y+2, r1	; 0x02
     b06:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     b08:	56 d4       	rcall	.+2220   	; 0x13b6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     b0a:	80 91 e6 0b 	lds	r24, 0x0BE6	; 0x800be6 <pucAlignedHeap.1892>
     b0e:	90 91 e7 0b 	lds	r25, 0x0BE7	; 0x800be7 <pucAlignedHeap.1892+0x1>
     b12:	89 2b       	or	r24, r25
     b14:	31 f4       	brne	.+12     	; 0xb22 <pvPortMalloc+0x2e>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     b16:	81 e2       	ldi	r24, 0x21	; 33
     b18:	92 e0       	ldi	r25, 0x02	; 2
     b1a:	90 93 e7 0b 	sts	0x0BE7, r25	; 0x800be7 <pucAlignedHeap.1892+0x1>
     b1e:	80 93 e6 0b 	sts	0x0BE6, r24	; 0x800be6 <pucAlignedHeap.1892>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     b22:	20 91 e4 0b 	lds	r18, 0x0BE4	; 0x800be4 <xNextFreeByte>
     b26:	30 91 e5 0b 	lds	r19, 0x0BE5	; 0x800be5 <xNextFreeByte+0x1>
     b2a:	8b 81       	ldd	r24, Y+3	; 0x03
     b2c:	9c 81       	ldd	r25, Y+4	; 0x04
     b2e:	82 0f       	add	r24, r18
     b30:	93 1f       	adc	r25, r19
     b32:	83 3c       	cpi	r24, 0xC3	; 195
     b34:	99 40       	sbci	r25, 0x09	; 9
     b36:	38 f5       	brcc	.+78     	; 0xb86 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     b38:	20 91 e4 0b 	lds	r18, 0x0BE4	; 0x800be4 <xNextFreeByte>
     b3c:	30 91 e5 0b 	lds	r19, 0x0BE5	; 0x800be5 <xNextFreeByte+0x1>
     b40:	8b 81       	ldd	r24, Y+3	; 0x03
     b42:	9c 81       	ldd	r25, Y+4	; 0x04
     b44:	28 0f       	add	r18, r24
     b46:	39 1f       	adc	r19, r25
     b48:	80 91 e4 0b 	lds	r24, 0x0BE4	; 0x800be4 <xNextFreeByte>
     b4c:	90 91 e5 0b 	lds	r25, 0x0BE5	; 0x800be5 <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     b50:	82 17       	cp	r24, r18
     b52:	93 07       	cpc	r25, r19
     b54:	c0 f4       	brcc	.+48     	; 0xb86 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     b56:	20 91 e6 0b 	lds	r18, 0x0BE6	; 0x800be6 <pucAlignedHeap.1892>
     b5a:	30 91 e7 0b 	lds	r19, 0x0BE7	; 0x800be7 <pucAlignedHeap.1892+0x1>
     b5e:	80 91 e4 0b 	lds	r24, 0x0BE4	; 0x800be4 <xNextFreeByte>
     b62:	90 91 e5 0b 	lds	r25, 0x0BE5	; 0x800be5 <xNextFreeByte+0x1>
     b66:	82 0f       	add	r24, r18
     b68:	93 1f       	adc	r25, r19
     b6a:	9a 83       	std	Y+2, r25	; 0x02
     b6c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     b6e:	20 91 e4 0b 	lds	r18, 0x0BE4	; 0x800be4 <xNextFreeByte>
     b72:	30 91 e5 0b 	lds	r19, 0x0BE5	; 0x800be5 <xNextFreeByte+0x1>
     b76:	8b 81       	ldd	r24, Y+3	; 0x03
     b78:	9c 81       	ldd	r25, Y+4	; 0x04
     b7a:	82 0f       	add	r24, r18
     b7c:	93 1f       	adc	r25, r19
     b7e:	90 93 e5 0b 	sts	0x0BE5, r25	; 0x800be5 <xNextFreeByte+0x1>
     b82:	80 93 e4 0b 	sts	0x0BE4, r24	; 0x800be4 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     b86:	23 d4       	rcall	.+2118   	; 0x13ce <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     b88:	89 81       	ldd	r24, Y+1	; 0x01
     b8a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     b8c:	0f 90       	pop	r0
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	0f 90       	pop	r0
     b94:	df 91       	pop	r29
     b96:	cf 91       	pop	r28
     b98:	08 95       	ret

00000b9a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	1f 92       	push	r1
     ba0:	1f 92       	push	r1
     ba2:	cd b7       	in	r28, 0x3d	; 61
     ba4:	de b7       	in	r29, 0x3e	; 62
     ba6:	9a 83       	std	Y+2, r25	; 0x02
     ba8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     baa:	0f 90       	pop	r0
     bac:	0f 90       	pop	r0
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <xQueueGenericSendFromISR>:
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
}
     bb4:	cf 93       	push	r28
     bb6:	df 93       	push	r29
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
     bbc:	2b 97       	sbiw	r28, 0x0b	; 11
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	de bf       	out	0x3e, r29	; 62
     bc4:	0f be       	out	0x3f, r0	; 63
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	9e 83       	std	Y+6, r25	; 0x06
     bca:	8d 83       	std	Y+5, r24	; 0x05
     bcc:	78 87       	std	Y+8, r23	; 0x08
     bce:	6f 83       	std	Y+7, r22	; 0x07
     bd0:	5a 87       	std	Y+10, r21	; 0x0a
     bd2:	49 87       	std	Y+9, r20	; 0x09
     bd4:	2b 87       	std	Y+11, r18	; 0x0b
     bd6:	8d 81       	ldd	r24, Y+5	; 0x05
     bd8:	9e 81       	ldd	r25, Y+6	; 0x06
     bda:	9b 83       	std	Y+3, r25	; 0x03
     bdc:	8a 83       	std	Y+2, r24	; 0x02
     bde:	1c 82       	std	Y+4, r1	; 0x04
     be0:	8a 81       	ldd	r24, Y+2	; 0x02
     be2:	9b 81       	ldd	r25, Y+3	; 0x03
     be4:	fc 01       	movw	r30, r24
     be6:	22 8d       	ldd	r18, Z+26	; 0x1a
     be8:	8a 81       	ldd	r24, Y+2	; 0x02
     bea:	9b 81       	ldd	r25, Y+3	; 0x03
     bec:	fc 01       	movw	r30, r24
     bee:	83 8d       	ldd	r24, Z+27	; 0x1b
     bf0:	28 17       	cp	r18, r24
     bf2:	18 f0       	brcs	.+6      	; 0xbfa <xQueueGenericSendFromISR+0x46>
     bf4:	8b 85       	ldd	r24, Y+11	; 0x0b
     bf6:	82 30       	cpi	r24, 0x02	; 2
     bf8:	81 f5       	brne	.+96     	; 0xc5a <xQueueGenericSendFromISR+0xa6>
     bfa:	2f 81       	ldd	r18, Y+7	; 0x07
     bfc:	38 85       	ldd	r19, Y+8	; 0x08
     bfe:	8a 81       	ldd	r24, Y+2	; 0x02
     c00:	9b 81       	ldd	r25, Y+3	; 0x03
     c02:	4b 85       	ldd	r20, Y+11	; 0x0b
     c04:	b9 01       	movw	r22, r18
     c06:	93 d0       	rcall	.+294    	; 0xd2e <prvCopyDataToQueue>
     c08:	8a 81       	ldd	r24, Y+2	; 0x02
     c0a:	9b 81       	ldd	r25, Y+3	; 0x03
     c0c:	fc 01       	movw	r30, r24
     c0e:	86 8d       	ldd	r24, Z+30	; 0x1e
     c10:	8f 3f       	cpi	r24, 0xFF	; 255
     c12:	b1 f4       	brne	.+44     	; 0xc40 <xQueueGenericSendFromISR+0x8c>
     c14:	8a 81       	ldd	r24, Y+2	; 0x02
     c16:	9b 81       	ldd	r25, Y+3	; 0x03
     c18:	fc 01       	movw	r30, r24
     c1a:	81 89       	ldd	r24, Z+17	; 0x11
     c1c:	88 23       	and	r24, r24
     c1e:	d1 f0       	breq	.+52     	; 0xc54 <xQueueGenericSendFromISR+0xa0>
     c20:	8a 81       	ldd	r24, Y+2	; 0x02
     c22:	9b 81       	ldd	r25, Y+3	; 0x03
     c24:	41 96       	adiw	r24, 0x11	; 17
     c26:	d9 d5       	rcall	.+2994   	; 0x17da <xTaskRemoveFromEventList>
     c28:	88 23       	and	r24, r24
     c2a:	a1 f0       	breq	.+40     	; 0xc54 <xQueueGenericSendFromISR+0xa0>
     c2c:	89 85       	ldd	r24, Y+9	; 0x09
     c2e:	9a 85       	ldd	r25, Y+10	; 0x0a
     c30:	89 2b       	or	r24, r25
     c32:	81 f0       	breq	.+32     	; 0xc54 <xQueueGenericSendFromISR+0xa0>
     c34:	89 85       	ldd	r24, Y+9	; 0x09
     c36:	9a 85       	ldd	r25, Y+10	; 0x0a
     c38:	21 e0       	ldi	r18, 0x01	; 1
     c3a:	fc 01       	movw	r30, r24
     c3c:	20 83       	st	Z, r18
     c3e:	0a c0       	rjmp	.+20     	; 0xc54 <xQueueGenericSendFromISR+0xa0>
     c40:	8a 81       	ldd	r24, Y+2	; 0x02
     c42:	9b 81       	ldd	r25, Y+3	; 0x03
     c44:	fc 01       	movw	r30, r24
     c46:	86 8d       	ldd	r24, Z+30	; 0x1e
     c48:	8f 5f       	subi	r24, 0xFF	; 255
     c4a:	28 2f       	mov	r18, r24
     c4c:	8a 81       	ldd	r24, Y+2	; 0x02
     c4e:	9b 81       	ldd	r25, Y+3	; 0x03
     c50:	fc 01       	movw	r30, r24
     c52:	26 8f       	std	Z+30, r18	; 0x1e
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	89 83       	std	Y+1, r24	; 0x01
     c58:	01 c0       	rjmp	.+2      	; 0xc5c <xQueueGenericSendFromISR+0xa8>
     c5a:	19 82       	std	Y+1, r1	; 0x01
     c5c:	89 81       	ldd	r24, Y+1	; 0x01
     c5e:	2b 96       	adiw	r28, 0x0b	; 11
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	de bf       	out	0x3e, r29	; 62
     c66:	0f be       	out	0x3f, r0	; 63
     c68:	cd bf       	out	0x3d, r28	; 61
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	08 95       	ret

00000c70 <xQueueReceiveFromISR>:
     c70:	cf 93       	push	r28
     c72:	df 93       	push	r29
     c74:	cd b7       	in	r28, 0x3d	; 61
     c76:	de b7       	in	r29, 0x3e	; 62
     c78:	2a 97       	sbiw	r28, 0x0a	; 10
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	f8 94       	cli
     c7e:	de bf       	out	0x3e, r29	; 62
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	cd bf       	out	0x3d, r28	; 61
     c84:	9e 83       	std	Y+6, r25	; 0x06
     c86:	8d 83       	std	Y+5, r24	; 0x05
     c88:	78 87       	std	Y+8, r23	; 0x08
     c8a:	6f 83       	std	Y+7, r22	; 0x07
     c8c:	5a 87       	std	Y+10, r21	; 0x0a
     c8e:	49 87       	std	Y+9, r20	; 0x09
     c90:	8d 81       	ldd	r24, Y+5	; 0x05
     c92:	9e 81       	ldd	r25, Y+6	; 0x06
     c94:	9b 83       	std	Y+3, r25	; 0x03
     c96:	8a 83       	std	Y+2, r24	; 0x02
     c98:	1c 82       	std	Y+4, r1	; 0x04
     c9a:	8a 81       	ldd	r24, Y+2	; 0x02
     c9c:	9b 81       	ldd	r25, Y+3	; 0x03
     c9e:	fc 01       	movw	r30, r24
     ca0:	82 8d       	ldd	r24, Z+26	; 0x1a
     ca2:	88 23       	and	r24, r24
     ca4:	c9 f1       	breq	.+114    	; 0xd18 <xQueueReceiveFromISR+0xa8>
     ca6:	2f 81       	ldd	r18, Y+7	; 0x07
     ca8:	38 85       	ldd	r19, Y+8	; 0x08
     caa:	8a 81       	ldd	r24, Y+2	; 0x02
     cac:	9b 81       	ldd	r25, Y+3	; 0x03
     cae:	b9 01       	movw	r22, r18
     cb0:	fd d0       	rcall	.+506    	; 0xeac <prvCopyDataFromQueue>
     cb2:	8a 81       	ldd	r24, Y+2	; 0x02
     cb4:	9b 81       	ldd	r25, Y+3	; 0x03
     cb6:	fc 01       	movw	r30, r24
     cb8:	82 8d       	ldd	r24, Z+26	; 0x1a
     cba:	2f ef       	ldi	r18, 0xFF	; 255
     cbc:	28 0f       	add	r18, r24
     cbe:	8a 81       	ldd	r24, Y+2	; 0x02
     cc0:	9b 81       	ldd	r25, Y+3	; 0x03
     cc2:	fc 01       	movw	r30, r24
     cc4:	22 8f       	std	Z+26, r18	; 0x1a
     cc6:	8a 81       	ldd	r24, Y+2	; 0x02
     cc8:	9b 81       	ldd	r25, Y+3	; 0x03
     cca:	fc 01       	movw	r30, r24
     ccc:	85 8d       	ldd	r24, Z+29	; 0x1d
     cce:	8f 3f       	cpi	r24, 0xFF	; 255
     cd0:	b1 f4       	brne	.+44     	; 0xcfe <xQueueReceiveFromISR+0x8e>
     cd2:	8a 81       	ldd	r24, Y+2	; 0x02
     cd4:	9b 81       	ldd	r25, Y+3	; 0x03
     cd6:	fc 01       	movw	r30, r24
     cd8:	80 85       	ldd	r24, Z+8	; 0x08
     cda:	88 23       	and	r24, r24
     cdc:	d1 f0       	breq	.+52     	; 0xd12 <xQueueReceiveFromISR+0xa2>
     cde:	8a 81       	ldd	r24, Y+2	; 0x02
     ce0:	9b 81       	ldd	r25, Y+3	; 0x03
     ce2:	08 96       	adiw	r24, 0x08	; 8
     ce4:	7a d5       	rcall	.+2804   	; 0x17da <xTaskRemoveFromEventList>
     ce6:	88 23       	and	r24, r24
     ce8:	a1 f0       	breq	.+40     	; 0xd12 <xQueueReceiveFromISR+0xa2>
     cea:	89 85       	ldd	r24, Y+9	; 0x09
     cec:	9a 85       	ldd	r25, Y+10	; 0x0a
     cee:	89 2b       	or	r24, r25
     cf0:	81 f0       	breq	.+32     	; 0xd12 <xQueueReceiveFromISR+0xa2>
     cf2:	89 85       	ldd	r24, Y+9	; 0x09
     cf4:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf6:	21 e0       	ldi	r18, 0x01	; 1
     cf8:	fc 01       	movw	r30, r24
     cfa:	20 83       	st	Z, r18
     cfc:	0a c0       	rjmp	.+20     	; 0xd12 <xQueueReceiveFromISR+0xa2>
     cfe:	8a 81       	ldd	r24, Y+2	; 0x02
     d00:	9b 81       	ldd	r25, Y+3	; 0x03
     d02:	fc 01       	movw	r30, r24
     d04:	85 8d       	ldd	r24, Z+29	; 0x1d
     d06:	8f 5f       	subi	r24, 0xFF	; 255
     d08:	28 2f       	mov	r18, r24
     d0a:	8a 81       	ldd	r24, Y+2	; 0x02
     d0c:	9b 81       	ldd	r25, Y+3	; 0x03
     d0e:	fc 01       	movw	r30, r24
     d10:	25 8f       	std	Z+29, r18	; 0x1d
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	89 83       	std	Y+1, r24	; 0x01
     d16:	01 c0       	rjmp	.+2      	; 0xd1a <xQueueReceiveFromISR+0xaa>
     d18:	19 82       	std	Y+1, r1	; 0x01
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	2a 96       	adiw	r28, 0x0a	; 10
     d1e:	0f b6       	in	r0, 0x3f	; 63
     d20:	f8 94       	cli
     d22:	de bf       	out	0x3e, r29	; 62
     d24:	0f be       	out	0x3f, r0	; 63
     d26:	cd bf       	out	0x3d, r28	; 61
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	08 95       	ret

00000d2e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     d2e:	cf 93       	push	r28
     d30:	df 93       	push	r29
     d32:	00 d0       	rcall	.+0      	; 0xd34 <prvCopyDataToQueue+0x6>
     d34:	00 d0       	rcall	.+0      	; 0xd36 <prvCopyDataToQueue+0x8>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	9b 83       	std	Y+3, r25	; 0x03
     d3c:	8a 83       	std	Y+2, r24	; 0x02
     d3e:	7d 83       	std	Y+5, r23	; 0x05
     d40:	6c 83       	std	Y+4, r22	; 0x04
     d42:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
     d44:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     d46:	8a 81       	ldd	r24, Y+2	; 0x02
     d48:	9b 81       	ldd	r25, Y+3	; 0x03
     d4a:	fc 01       	movw	r30, r24
     d4c:	84 8d       	ldd	r24, Z+28	; 0x1c
     d4e:	88 23       	and	r24, r24
     d50:	09 f4       	brne	.+2      	; 0xd54 <prvCopyDataToQueue+0x26>
     d52:	98 c0       	rjmp	.+304    	; 0xe84 <prvCopyDataToQueue+0x156>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     d54:	8e 81       	ldd	r24, Y+6	; 0x06
     d56:	88 23       	and	r24, r24
     d58:	d9 f5       	brne	.+118    	; 0xdd0 <prvCopyDataToQueue+0xa2>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     d5a:	8a 81       	ldd	r24, Y+2	; 0x02
     d5c:	9b 81       	ldd	r25, Y+3	; 0x03
     d5e:	fc 01       	movw	r30, r24
     d60:	84 8d       	ldd	r24, Z+28	; 0x1c
     d62:	48 2f       	mov	r20, r24
     d64:	50 e0       	ldi	r21, 0x00	; 0
     d66:	8a 81       	ldd	r24, Y+2	; 0x02
     d68:	9b 81       	ldd	r25, Y+3	; 0x03
     d6a:	fc 01       	movw	r30, r24
     d6c:	84 81       	ldd	r24, Z+4	; 0x04
     d6e:	95 81       	ldd	r25, Z+5	; 0x05
     d70:	2c 81       	ldd	r18, Y+4	; 0x04
     d72:	3d 81       	ldd	r19, Y+5	; 0x05
     d74:	b9 01       	movw	r22, r18
     d76:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	9b 81       	ldd	r25, Y+3	; 0x03
     d7e:	fc 01       	movw	r30, r24
     d80:	24 81       	ldd	r18, Z+4	; 0x04
     d82:	35 81       	ldd	r19, Z+5	; 0x05
     d84:	8a 81       	ldd	r24, Y+2	; 0x02
     d86:	9b 81       	ldd	r25, Y+3	; 0x03
     d88:	fc 01       	movw	r30, r24
     d8a:	84 8d       	ldd	r24, Z+28	; 0x1c
     d8c:	88 2f       	mov	r24, r24
     d8e:	90 e0       	ldi	r25, 0x00	; 0
     d90:	28 0f       	add	r18, r24
     d92:	39 1f       	adc	r19, r25
     d94:	8a 81       	ldd	r24, Y+2	; 0x02
     d96:	9b 81       	ldd	r25, Y+3	; 0x03
     d98:	fc 01       	movw	r30, r24
     d9a:	35 83       	std	Z+5, r19	; 0x05
     d9c:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	24 81       	ldd	r18, Z+4	; 0x04
     da6:	35 81       	ldd	r19, Z+5	; 0x05
     da8:	8a 81       	ldd	r24, Y+2	; 0x02
     daa:	9b 81       	ldd	r25, Y+3	; 0x03
     dac:	fc 01       	movw	r30, r24
     dae:	82 81       	ldd	r24, Z+2	; 0x02
     db0:	93 81       	ldd	r25, Z+3	; 0x03
     db2:	28 17       	cp	r18, r24
     db4:	39 07       	cpc	r19, r25
     db6:	08 f4       	brcc	.+2      	; 0xdba <prvCopyDataToQueue+0x8c>
     db8:	65 c0       	rjmp	.+202    	; 0xe84 <prvCopyDataToQueue+0x156>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     dba:	8a 81       	ldd	r24, Y+2	; 0x02
     dbc:	9b 81       	ldd	r25, Y+3	; 0x03
     dbe:	fc 01       	movw	r30, r24
     dc0:	20 81       	ld	r18, Z
     dc2:	31 81       	ldd	r19, Z+1	; 0x01
     dc4:	8a 81       	ldd	r24, Y+2	; 0x02
     dc6:	9b 81       	ldd	r25, Y+3	; 0x03
     dc8:	fc 01       	movw	r30, r24
     dca:	35 83       	std	Z+5, r19	; 0x05
     dcc:	24 83       	std	Z+4, r18	; 0x04
     dce:	5a c0       	rjmp	.+180    	; 0xe84 <prvCopyDataToQueue+0x156>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dd0:	8a 81       	ldd	r24, Y+2	; 0x02
     dd2:	9b 81       	ldd	r25, Y+3	; 0x03
     dd4:	fc 01       	movw	r30, r24
     dd6:	84 8d       	ldd	r24, Z+28	; 0x1c
     dd8:	48 2f       	mov	r20, r24
     dda:	50 e0       	ldi	r21, 0x00	; 0
     ddc:	8a 81       	ldd	r24, Y+2	; 0x02
     dde:	9b 81       	ldd	r25, Y+3	; 0x03
     de0:	fc 01       	movw	r30, r24
     de2:	86 81       	ldd	r24, Z+6	; 0x06
     de4:	97 81       	ldd	r25, Z+7	; 0x07
     de6:	2c 81       	ldd	r18, Y+4	; 0x04
     de8:	3d 81       	ldd	r19, Y+5	; 0x05
     dea:	b9 01       	movw	r22, r18
     dec:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     df0:	8a 81       	ldd	r24, Y+2	; 0x02
     df2:	9b 81       	ldd	r25, Y+3	; 0x03
     df4:	fc 01       	movw	r30, r24
     df6:	26 81       	ldd	r18, Z+6	; 0x06
     df8:	37 81       	ldd	r19, Z+7	; 0x07
     dfa:	8a 81       	ldd	r24, Y+2	; 0x02
     dfc:	9b 81       	ldd	r25, Y+3	; 0x03
     dfe:	fc 01       	movw	r30, r24
     e00:	84 8d       	ldd	r24, Z+28	; 0x1c
     e02:	88 2f       	mov	r24, r24
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	91 95       	neg	r25
     e08:	81 95       	neg	r24
     e0a:	91 09       	sbc	r25, r1
     e0c:	28 0f       	add	r18, r24
     e0e:	39 1f       	adc	r19, r25
     e10:	8a 81       	ldd	r24, Y+2	; 0x02
     e12:	9b 81       	ldd	r25, Y+3	; 0x03
     e14:	fc 01       	movw	r30, r24
     e16:	37 83       	std	Z+7, r19	; 0x07
     e18:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e1a:	8a 81       	ldd	r24, Y+2	; 0x02
     e1c:	9b 81       	ldd	r25, Y+3	; 0x03
     e1e:	fc 01       	movw	r30, r24
     e20:	26 81       	ldd	r18, Z+6	; 0x06
     e22:	37 81       	ldd	r19, Z+7	; 0x07
     e24:	8a 81       	ldd	r24, Y+2	; 0x02
     e26:	9b 81       	ldd	r25, Y+3	; 0x03
     e28:	fc 01       	movw	r30, r24
     e2a:	80 81       	ld	r24, Z
     e2c:	91 81       	ldd	r25, Z+1	; 0x01
     e2e:	28 17       	cp	r18, r24
     e30:	39 07       	cpc	r19, r25
     e32:	a8 f4       	brcc	.+42     	; 0xe5e <prvCopyDataToQueue+0x130>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	9b 81       	ldd	r25, Y+3	; 0x03
     e38:	fc 01       	movw	r30, r24
     e3a:	22 81       	ldd	r18, Z+2	; 0x02
     e3c:	33 81       	ldd	r19, Z+3	; 0x03
     e3e:	8a 81       	ldd	r24, Y+2	; 0x02
     e40:	9b 81       	ldd	r25, Y+3	; 0x03
     e42:	fc 01       	movw	r30, r24
     e44:	84 8d       	ldd	r24, Z+28	; 0x1c
     e46:	88 2f       	mov	r24, r24
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	91 95       	neg	r25
     e4c:	81 95       	neg	r24
     e4e:	91 09       	sbc	r25, r1
     e50:	28 0f       	add	r18, r24
     e52:	39 1f       	adc	r19, r25
     e54:	8a 81       	ldd	r24, Y+2	; 0x02
     e56:	9b 81       	ldd	r25, Y+3	; 0x03
     e58:	fc 01       	movw	r30, r24
     e5a:	37 83       	std	Z+7, r19	; 0x07
     e5c:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     e5e:	8e 81       	ldd	r24, Y+6	; 0x06
     e60:	82 30       	cpi	r24, 0x02	; 2
     e62:	81 f4       	brne	.+32     	; 0xe84 <prvCopyDataToQueue+0x156>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     e64:	8a 81       	ldd	r24, Y+2	; 0x02
     e66:	9b 81       	ldd	r25, Y+3	; 0x03
     e68:	fc 01       	movw	r30, r24
     e6a:	82 8d       	ldd	r24, Z+26	; 0x1a
     e6c:	88 23       	and	r24, r24
     e6e:	51 f0       	breq	.+20     	; 0xe84 <prvCopyDataToQueue+0x156>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     e70:	8a 81       	ldd	r24, Y+2	; 0x02
     e72:	9b 81       	ldd	r25, Y+3	; 0x03
     e74:	fc 01       	movw	r30, r24
     e76:	82 8d       	ldd	r24, Z+26	; 0x1a
     e78:	2f ef       	ldi	r18, 0xFF	; 255
     e7a:	28 0f       	add	r18, r24
     e7c:	8a 81       	ldd	r24, Y+2	; 0x02
     e7e:	9b 81       	ldd	r25, Y+3	; 0x03
     e80:	fc 01       	movw	r30, r24
     e82:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     e84:	8a 81       	ldd	r24, Y+2	; 0x02
     e86:	9b 81       	ldd	r25, Y+3	; 0x03
     e88:	fc 01       	movw	r30, r24
     e8a:	82 8d       	ldd	r24, Z+26	; 0x1a
     e8c:	21 e0       	ldi	r18, 0x01	; 1
     e8e:	28 0f       	add	r18, r24
     e90:	8a 81       	ldd	r24, Y+2	; 0x02
     e92:	9b 81       	ldd	r25, Y+3	; 0x03
     e94:	fc 01       	movw	r30, r24
     e96:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
     e98:	89 81       	ldd	r24, Y+1	; 0x01
}
     e9a:	26 96       	adiw	r28, 0x06	; 6
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	f8 94       	cli
     ea0:	de bf       	out	0x3e, r29	; 62
     ea2:	0f be       	out	0x3f, r0	; 63
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	df 91       	pop	r29
     ea8:	cf 91       	pop	r28
     eaa:	08 95       	ret

00000eac <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <prvCopyDataFromQueue+0x6>
     eb2:	1f 92       	push	r1
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	9a 83       	std	Y+2, r25	; 0x02
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	7c 83       	std	Y+4, r23	; 0x04
     ebe:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     ec0:	89 81       	ldd	r24, Y+1	; 0x01
     ec2:	9a 81       	ldd	r25, Y+2	; 0x02
     ec4:	fc 01       	movw	r30, r24
     ec6:	84 8d       	ldd	r24, Z+28	; 0x1c
     ec8:	88 23       	and	r24, r24
     eca:	c9 f1       	breq	.+114    	; 0xf3e <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     ecc:	89 81       	ldd	r24, Y+1	; 0x01
     ece:	9a 81       	ldd	r25, Y+2	; 0x02
     ed0:	fc 01       	movw	r30, r24
     ed2:	26 81       	ldd	r18, Z+6	; 0x06
     ed4:	37 81       	ldd	r19, Z+7	; 0x07
     ed6:	89 81       	ldd	r24, Y+1	; 0x01
     ed8:	9a 81       	ldd	r25, Y+2	; 0x02
     eda:	fc 01       	movw	r30, r24
     edc:	84 8d       	ldd	r24, Z+28	; 0x1c
     ede:	88 2f       	mov	r24, r24
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	28 0f       	add	r18, r24
     ee4:	39 1f       	adc	r19, r25
     ee6:	89 81       	ldd	r24, Y+1	; 0x01
     ee8:	9a 81       	ldd	r25, Y+2	; 0x02
     eea:	fc 01       	movw	r30, r24
     eec:	37 83       	std	Z+7, r19	; 0x07
     eee:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     ef0:	89 81       	ldd	r24, Y+1	; 0x01
     ef2:	9a 81       	ldd	r25, Y+2	; 0x02
     ef4:	fc 01       	movw	r30, r24
     ef6:	26 81       	ldd	r18, Z+6	; 0x06
     ef8:	37 81       	ldd	r19, Z+7	; 0x07
     efa:	89 81       	ldd	r24, Y+1	; 0x01
     efc:	9a 81       	ldd	r25, Y+2	; 0x02
     efe:	fc 01       	movw	r30, r24
     f00:	82 81       	ldd	r24, Z+2	; 0x02
     f02:	93 81       	ldd	r25, Z+3	; 0x03
     f04:	28 17       	cp	r18, r24
     f06:	39 07       	cpc	r19, r25
     f08:	50 f0       	brcs	.+20     	; 0xf1e <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     f0a:	89 81       	ldd	r24, Y+1	; 0x01
     f0c:	9a 81       	ldd	r25, Y+2	; 0x02
     f0e:	fc 01       	movw	r30, r24
     f10:	20 81       	ld	r18, Z
     f12:	31 81       	ldd	r19, Z+1	; 0x01
     f14:	89 81       	ldd	r24, Y+1	; 0x01
     f16:	9a 81       	ldd	r25, Y+2	; 0x02
     f18:	fc 01       	movw	r30, r24
     f1a:	37 83       	std	Z+7, r19	; 0x07
     f1c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	9a 81       	ldd	r25, Y+2	; 0x02
     f22:	fc 01       	movw	r30, r24
     f24:	84 8d       	ldd	r24, Z+28	; 0x1c
     f26:	48 2f       	mov	r20, r24
     f28:	50 e0       	ldi	r21, 0x00	; 0
     f2a:	89 81       	ldd	r24, Y+1	; 0x01
     f2c:	9a 81       	ldd	r25, Y+2	; 0x02
     f2e:	fc 01       	movw	r30, r24
     f30:	26 81       	ldd	r18, Z+6	; 0x06
     f32:	37 81       	ldd	r19, Z+7	; 0x07
     f34:	8b 81       	ldd	r24, Y+3	; 0x03
     f36:	9c 81       	ldd	r25, Y+4	; 0x04
     f38:	b9 01       	movw	r22, r18
     f3a:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>
	}
}
     f3e:	0f 90       	pop	r0
     f40:	0f 90       	pop	r0
     f42:	0f 90       	pop	r0
     f44:	0f 90       	pop	r0
     f46:	df 91       	pop	r29
     f48:	cf 91       	pop	r28
     f4a:	08 95       	ret

00000f4c <xTaskGenericCreate>:
     f4c:	af 92       	push	r10
     f4e:	bf 92       	push	r11
     f50:	cf 92       	push	r12
     f52:	df 92       	push	r13
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	cf 93       	push	r28
     f5e:	df 93       	push	r29
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	64 97       	sbiw	r28, 0x14	; 20
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	de bf       	out	0x3e, r29	; 62
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	cd bf       	out	0x3d, r28	; 61
     f70:	9f 83       	std	Y+7, r25	; 0x07
     f72:	8e 83       	std	Y+6, r24	; 0x06
     f74:	79 87       	std	Y+9, r23	; 0x09
     f76:	68 87       	std	Y+8, r22	; 0x08
     f78:	5b 87       	std	Y+11, r21	; 0x0b
     f7a:	4a 87       	std	Y+10, r20	; 0x0a
     f7c:	3d 87       	std	Y+13, r19	; 0x0d
     f7e:	2c 87       	std	Y+12, r18	; 0x0c
     f80:	0e 87       	std	Y+14, r16	; 0x0e
     f82:	f8 8a       	std	Y+16, r15	; 0x10
     f84:	ef 86       	std	Y+15, r14	; 0x0f
     f86:	da 8a       	std	Y+18, r13	; 0x12
     f88:	c9 8a       	std	Y+17, r12	; 0x11
     f8a:	bc 8a       	std	Y+20, r11	; 0x14
     f8c:	ab 8a       	std	Y+19, r10	; 0x13
     f8e:	29 89       	ldd	r18, Y+17	; 0x11
     f90:	3a 89       	ldd	r19, Y+18	; 0x12
     f92:	8a 85       	ldd	r24, Y+10	; 0x0a
     f94:	9b 85       	ldd	r25, Y+11	; 0x0b
     f96:	b9 01       	movw	r22, r18
     f98:	d9 d5       	rcall	.+2994   	; 0x1b4c <prvAllocateTCBAndStack>
     f9a:	9b 83       	std	Y+3, r25	; 0x03
     f9c:	8a 83       	std	Y+2, r24	; 0x02
     f9e:	8a 81       	ldd	r24, Y+2	; 0x02
     fa0:	9b 81       	ldd	r25, Y+3	; 0x03
     fa2:	89 2b       	or	r24, r25
     fa4:	09 f4       	brne	.+2      	; 0xfa8 <xTaskGenericCreate+0x5c>
     fa6:	8d c0       	rjmp	.+282    	; 0x10c2 <xTaskGenericCreate+0x176>
     fa8:	8a 81       	ldd	r24, Y+2	; 0x02
     faa:	9b 81       	ldd	r25, Y+3	; 0x03
     fac:	fc 01       	movw	r30, r24
     fae:	27 89       	ldd	r18, Z+23	; 0x17
     fb0:	30 8d       	ldd	r19, Z+24	; 0x18
     fb2:	8a 85       	ldd	r24, Y+10	; 0x0a
     fb4:	9b 85       	ldd	r25, Y+11	; 0x0b
     fb6:	01 97       	sbiw	r24, 0x01	; 1
     fb8:	82 0f       	add	r24, r18
     fba:	93 1f       	adc	r25, r19
     fbc:	9d 83       	std	Y+5, r25	; 0x05
     fbe:	8c 83       	std	Y+4, r24	; 0x04
     fc0:	4a 85       	ldd	r20, Y+10	; 0x0a
     fc2:	5b 85       	ldd	r21, Y+11	; 0x0b
     fc4:	2b 89       	ldd	r18, Y+19	; 0x13
     fc6:	3c 89       	ldd	r19, Y+20	; 0x14
     fc8:	68 85       	ldd	r22, Y+8	; 0x08
     fca:	79 85       	ldd	r23, Y+9	; 0x09
     fcc:	8a 81       	ldd	r24, Y+2	; 0x02
     fce:	9b 81       	ldd	r25, Y+3	; 0x03
     fd0:	8a 01       	movw	r16, r20
     fd2:	4e 85       	ldd	r20, Y+14	; 0x0e
     fd4:	6f d4       	rcall	.+2270   	; 0x18b4 <prvInitialiseTCBVariables>
     fd6:	4c 85       	ldd	r20, Y+12	; 0x0c
     fd8:	5d 85       	ldd	r21, Y+13	; 0x0d
     fda:	2e 81       	ldd	r18, Y+6	; 0x06
     fdc:	3f 81       	ldd	r19, Y+7	; 0x07
     fde:	8c 81       	ldd	r24, Y+4	; 0x04
     fe0:	9d 81       	ldd	r25, Y+5	; 0x05
     fe2:	b9 01       	movw	r22, r18
     fe4:	17 da       	rcall	.-3026   	; 0x414 <pxPortInitialiseStack>
     fe6:	9c 01       	movw	r18, r24
     fe8:	8a 81       	ldd	r24, Y+2	; 0x02
     fea:	9b 81       	ldd	r25, Y+3	; 0x03
     fec:	fc 01       	movw	r30, r24
     fee:	31 83       	std	Z+1, r19	; 0x01
     ff0:	20 83       	st	Z, r18
     ff2:	8f 85       	ldd	r24, Y+15	; 0x0f
     ff4:	98 89       	ldd	r25, Y+16	; 0x10
     ff6:	89 2b       	or	r24, r25
     ff8:	39 f0       	breq	.+14     	; 0x1008 <xTaskGenericCreate+0xbc>
     ffa:	8f 85       	ldd	r24, Y+15	; 0x0f
     ffc:	98 89       	ldd	r25, Y+16	; 0x10
     ffe:	2a 81       	ldd	r18, Y+2	; 0x02
    1000:	3b 81       	ldd	r19, Y+3	; 0x03
    1002:	fc 01       	movw	r30, r24
    1004:	31 83       	std	Z+1, r19	; 0x01
    1006:	20 83       	st	Z, r18
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	0f 92       	push	r0
    100e:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <uxCurrentNumberOfTasks>
    1012:	8f 5f       	subi	r24, 0xFF	; 255
    1014:	80 93 40 0c 	sts	0x0C40, r24	; 0x800c40 <uxCurrentNumberOfTasks>
    1018:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    101c:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1020:	89 2b       	or	r24, r25
    1022:	61 f4       	brne	.+24     	; 0x103c <xTaskGenericCreate+0xf0>
    1024:	8a 81       	ldd	r24, Y+2	; 0x02
    1026:	9b 81       	ldd	r25, Y+3	; 0x03
    1028:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <pxCurrentTCB+0x1>
    102c:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <pxCurrentTCB>
    1030:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <uxCurrentNumberOfTasks>
    1034:	81 30       	cpi	r24, 0x01	; 1
    1036:	a9 f4       	brne	.+42     	; 0x1062 <xTaskGenericCreate+0x116>
    1038:	c1 d4       	rcall	.+2434   	; 0x19bc <prvInitialiseTaskLists>
    103a:	13 c0       	rjmp	.+38     	; 0x1062 <xTaskGenericCreate+0x116>
    103c:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <xSchedulerRunning>
    1040:	88 23       	and	r24, r24
    1042:	79 f4       	brne	.+30     	; 0x1062 <xTaskGenericCreate+0x116>
    1044:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1048:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    104c:	fc 01       	movw	r30, r24
    104e:	96 89       	ldd	r25, Z+22	; 0x16
    1050:	8e 85       	ldd	r24, Y+14	; 0x0e
    1052:	89 17       	cp	r24, r25
    1054:	30 f0       	brcs	.+12     	; 0x1062 <xTaskGenericCreate+0x116>
    1056:	8a 81       	ldd	r24, Y+2	; 0x02
    1058:	9b 81       	ldd	r25, Y+3	; 0x03
    105a:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <pxCurrentTCB+0x1>
    105e:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <pxCurrentTCB>
    1062:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <uxTaskNumber>
    1066:	8f 5f       	subi	r24, 0xFF	; 255
    1068:	80 93 48 0c 	sts	0x0C48, r24	; 0x800c48 <uxTaskNumber>
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	9b 81       	ldd	r25, Y+3	; 0x03
    1070:	fc 01       	movw	r30, r24
    1072:	96 89       	ldd	r25, Z+22	; 0x16
    1074:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1078:	89 17       	cp	r24, r25
    107a:	30 f4       	brcc	.+12     	; 0x1088 <xTaskGenericCreate+0x13c>
    107c:	8a 81       	ldd	r24, Y+2	; 0x02
    107e:	9b 81       	ldd	r25, Y+3	; 0x03
    1080:	fc 01       	movw	r30, r24
    1082:	86 89       	ldd	r24, Z+22	; 0x16
    1084:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    1088:	8a 81       	ldd	r24, Y+2	; 0x02
    108a:	9b 81       	ldd	r25, Y+3	; 0x03
    108c:	ac 01       	movw	r20, r24
    108e:	4e 5f       	subi	r20, 0xFE	; 254
    1090:	5f 4f       	sbci	r21, 0xFF	; 255
    1092:	8a 81       	ldd	r24, Y+2	; 0x02
    1094:	9b 81       	ldd	r25, Y+3	; 0x03
    1096:	fc 01       	movw	r30, r24
    1098:	86 89       	ldd	r24, Z+22	; 0x16
    109a:	28 2f       	mov	r18, r24
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	c9 01       	movw	r24, r18
    10a0:	88 0f       	add	r24, r24
    10a2:	99 1f       	adc	r25, r25
    10a4:	88 0f       	add	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	88 0f       	add	r24, r24
    10aa:	99 1f       	adc	r25, r25
    10ac:	82 0f       	add	r24, r18
    10ae:	93 1f       	adc	r25, r19
    10b0:	86 51       	subi	r24, 0x16	; 22
    10b2:	94 4f       	sbci	r25, 0xF4	; 244
    10b4:	ba 01       	movw	r22, r20
    10b6:	93 d8       	rcall	.-3802   	; 0x1de <vListInsertEnd>
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	89 83       	std	Y+1, r24	; 0x01
    10bc:	0f 90       	pop	r0
    10be:	0f be       	out	0x3f, r0	; 63
    10c0:	02 c0       	rjmp	.+4      	; 0x10c6 <xTaskGenericCreate+0x17a>
    10c2:	8f ef       	ldi	r24, 0xFF	; 255
    10c4:	89 83       	std	Y+1, r24	; 0x01
    10c6:	89 81       	ldd	r24, Y+1	; 0x01
    10c8:	81 30       	cpi	r24, 0x01	; 1
    10ca:	71 f4       	brne	.+28     	; 0x10e8 <xTaskGenericCreate+0x19c>
    10cc:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <xSchedulerRunning>
    10d0:	88 23       	and	r24, r24
    10d2:	51 f0       	breq	.+20     	; 0x10e8 <xTaskGenericCreate+0x19c>
    10d4:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    10d8:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    10dc:	fc 01       	movw	r30, r24
    10de:	96 89       	ldd	r25, Z+22	; 0x16
    10e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    10e2:	98 17       	cp	r25, r24
    10e4:	08 f4       	brcc	.+2      	; 0x10e8 <xTaskGenericCreate+0x19c>
    10e6:	92 db       	rcall	.-2268   	; 0x80c <vPortYield>
    10e8:	89 81       	ldd	r24, Y+1	; 0x01
    10ea:	64 96       	adiw	r28, 0x14	; 20
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	f8 94       	cli
    10f0:	de bf       	out	0x3e, r29	; 62
    10f2:	0f be       	out	0x3f, r0	; 63
    10f4:	cd bf       	out	0x3d, r28	; 61
    10f6:	df 91       	pop	r29
    10f8:	cf 91       	pop	r28
    10fa:	1f 91       	pop	r17
    10fc:	0f 91       	pop	r16
    10fe:	ff 90       	pop	r15
    1100:	ef 90       	pop	r14
    1102:	df 90       	pop	r13
    1104:	cf 90       	pop	r12
    1106:	bf 90       	pop	r11
    1108:	af 90       	pop	r10
    110a:	08 95       	ret

0000110c <vTaskDelay>:
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
    1110:	00 d0       	rcall	.+0      	; 0x1112 <vTaskDelay+0x6>
    1112:	1f 92       	push	r1
    1114:	1f 92       	push	r1
    1116:	cd b7       	in	r28, 0x3d	; 61
    1118:	de b7       	in	r29, 0x3e	; 62
    111a:	9d 83       	std	Y+5, r25	; 0x05
    111c:	8c 83       	std	Y+4, r24	; 0x04
    111e:	19 82       	std	Y+1, r1	; 0x01
    1120:	8c 81       	ldd	r24, Y+4	; 0x04
    1122:	9d 81       	ldd	r25, Y+5	; 0x05
    1124:	89 2b       	or	r24, r25
    1126:	b1 f0       	breq	.+44     	; 0x1154 <vTaskDelay+0x48>
    1128:	46 d1       	rcall	.+652    	; 0x13b6 <vTaskSuspendAll>
    112a:	20 91 41 0c 	lds	r18, 0x0C41	; 0x800c41 <xTickCount>
    112e:	30 91 42 0c 	lds	r19, 0x0C42	; 0x800c42 <xTickCount+0x1>
    1132:	8c 81       	ldd	r24, Y+4	; 0x04
    1134:	9d 81       	ldd	r25, Y+5	; 0x05
    1136:	82 0f       	add	r24, r18
    1138:	93 1f       	adc	r25, r19
    113a:	9b 83       	std	Y+3, r25	; 0x03
    113c:	8a 83       	std	Y+2, r24	; 0x02
    113e:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1142:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1146:	02 96       	adiw	r24, 0x02	; 2
    1148:	0e d9       	rcall	.-3556   	; 0x366 <uxListRemove>
    114a:	8a 81       	ldd	r24, Y+2	; 0x02
    114c:	9b 81       	ldd	r25, Y+3	; 0x03
    114e:	b3 d4       	rcall	.+2406   	; 0x1ab6 <prvAddCurrentTaskToDelayedList>
    1150:	3e d1       	rcall	.+636    	; 0x13ce <xTaskResumeAll>
    1152:	89 83       	std	Y+1, r24	; 0x01
    1154:	89 81       	ldd	r24, Y+1	; 0x01
    1156:	88 23       	and	r24, r24
    1158:	09 f4       	brne	.+2      	; 0x115c <vTaskDelay+0x50>
    115a:	58 db       	rcall	.-2384   	; 0x80c <vPortYield>
    115c:	0f 90       	pop	r0
    115e:	0f 90       	pop	r0
    1160:	0f 90       	pop	r0
    1162:	0f 90       	pop	r0
    1164:	0f 90       	pop	r0
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <vTaskSuspend>:
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	00 d0       	rcall	.+0      	; 0x1172 <vTaskSuspend+0x6>
    1172:	1f 92       	push	r1
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	9c 83       	std	Y+4, r25	; 0x04
    117a:	8b 83       	std	Y+3, r24	; 0x03
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	0f 92       	push	r0
    1182:	8b 81       	ldd	r24, Y+3	; 0x03
    1184:	9c 81       	ldd	r25, Y+4	; 0x04
    1186:	89 2b       	or	r24, r25
    1188:	29 f4       	brne	.+10     	; 0x1194 <vTaskSuspend+0x28>
    118a:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    118e:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1192:	02 c0       	rjmp	.+4      	; 0x1198 <vTaskSuspend+0x2c>
    1194:	8b 81       	ldd	r24, Y+3	; 0x03
    1196:	9c 81       	ldd	r25, Y+4	; 0x04
    1198:	9a 83       	std	Y+2, r25	; 0x02
    119a:	89 83       	std	Y+1, r24	; 0x01
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	02 96       	adiw	r24, 0x02	; 2
    11a2:	e1 d8       	rcall	.-3646   	; 0x366 <uxListRemove>
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
    11a6:	9a 81       	ldd	r25, Y+2	; 0x02
    11a8:	fc 01       	movw	r30, r24
    11aa:	84 89       	ldd	r24, Z+20	; 0x14
    11ac:	95 89       	ldd	r25, Z+21	; 0x15
    11ae:	89 2b       	or	r24, r25
    11b0:	21 f0       	breq	.+8      	; 0x11ba <vTaskSuspend+0x4e>
    11b2:	89 81       	ldd	r24, Y+1	; 0x01
    11b4:	9a 81       	ldd	r25, Y+2	; 0x02
    11b6:	0c 96       	adiw	r24, 0x0c	; 12
    11b8:	d6 d8       	rcall	.-3668   	; 0x366 <uxListRemove>
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	9a 81       	ldd	r25, Y+2	; 0x02
    11be:	02 96       	adiw	r24, 0x02	; 2
    11c0:	bc 01       	movw	r22, r24
    11c2:	87 e3       	ldi	r24, 0x37	; 55
    11c4:	9c e0       	ldi	r25, 0x0C	; 12
    11c6:	0b d8       	rcall	.-4074   	; 0x1de <vListInsertEnd>
    11c8:	0f 90       	pop	r0
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    11d0:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    11d4:	29 81       	ldd	r18, Y+1	; 0x01
    11d6:	3a 81       	ldd	r19, Y+2	; 0x02
    11d8:	28 17       	cp	r18, r24
    11da:	39 07       	cpc	r19, r25
    11dc:	99 f4       	brne	.+38     	; 0x1204 <vTaskSuspend+0x98>
    11de:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <xSchedulerRunning>
    11e2:	88 23       	and	r24, r24
    11e4:	11 f0       	breq	.+4      	; 0x11ea <vTaskSuspend+0x7e>
    11e6:	12 db       	rcall	.-2524   	; 0x80c <vPortYield>
    11e8:	17 c0       	rjmp	.+46     	; 0x1218 <vTaskSuspend+0xac>
    11ea:	90 91 37 0c 	lds	r25, 0x0C37	; 0x800c37 <xSuspendedTaskList>
    11ee:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <uxCurrentNumberOfTasks>
    11f2:	98 17       	cp	r25, r24
    11f4:	29 f4       	brne	.+10     	; 0x1200 <vTaskSuspend+0x94>
    11f6:	10 92 e9 0b 	sts	0x0BE9, r1	; 0x800be9 <pxCurrentTCB+0x1>
    11fa:	10 92 e8 0b 	sts	0x0BE8, r1	; 0x800be8 <pxCurrentTCB>
    11fe:	0c c0       	rjmp	.+24     	; 0x1218 <vTaskSuspend+0xac>
    1200:	5e d2       	rcall	.+1212   	; 0x16be <vTaskSwitchContext>
    1202:	0a c0       	rjmp	.+20     	; 0x1218 <vTaskSuspend+0xac>
    1204:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <xSchedulerRunning>
    1208:	88 23       	and	r24, r24
    120a:	31 f0       	breq	.+12     	; 0x1218 <vTaskSuspend+0xac>
    120c:	0f b6       	in	r0, 0x3f	; 63
    120e:	f8 94       	cli
    1210:	0f 92       	push	r0
    1212:	f7 d4       	rcall	.+2542   	; 0x1c02 <prvResetNextTaskUnblockTime>
    1214:	0f 90       	pop	r0
    1216:	0f be       	out	0x3f, r0	; 63
    1218:	0f 90       	pop	r0
    121a:	0f 90       	pop	r0
    121c:	0f 90       	pop	r0
    121e:	0f 90       	pop	r0
    1220:	df 91       	pop	r29
    1222:	cf 91       	pop	r28
    1224:	08 95       	ret

00001226 <prvTaskIsTaskSuspended>:
    1226:	cf 93       	push	r28
    1228:	df 93       	push	r29
    122a:	00 d0       	rcall	.+0      	; 0x122c <prvTaskIsTaskSuspended+0x6>
    122c:	1f 92       	push	r1
    122e:	1f 92       	push	r1
    1230:	cd b7       	in	r28, 0x3d	; 61
    1232:	de b7       	in	r29, 0x3e	; 62
    1234:	9d 83       	std	Y+5, r25	; 0x05
    1236:	8c 83       	std	Y+4, r24	; 0x04
    1238:	19 82       	std	Y+1, r1	; 0x01
    123a:	8c 81       	ldd	r24, Y+4	; 0x04
    123c:	9d 81       	ldd	r25, Y+5	; 0x05
    123e:	9b 83       	std	Y+3, r25	; 0x03
    1240:	8a 83       	std	Y+2, r24	; 0x02
    1242:	8a 81       	ldd	r24, Y+2	; 0x02
    1244:	9b 81       	ldd	r25, Y+3	; 0x03
    1246:	fc 01       	movw	r30, r24
    1248:	82 85       	ldd	r24, Z+10	; 0x0a
    124a:	93 85       	ldd	r25, Z+11	; 0x0b
    124c:	87 53       	subi	r24, 0x37	; 55
    124e:	9c 40       	sbci	r25, 0x0C	; 12
    1250:	89 f4       	brne	.+34     	; 0x1274 <prvTaskIsTaskSuspended+0x4e>
    1252:	8a 81       	ldd	r24, Y+2	; 0x02
    1254:	9b 81       	ldd	r25, Y+3	; 0x03
    1256:	fc 01       	movw	r30, r24
    1258:	84 89       	ldd	r24, Z+20	; 0x14
    125a:	95 89       	ldd	r25, Z+21	; 0x15
    125c:	84 52       	subi	r24, 0x24	; 36
    125e:	9c 40       	sbci	r25, 0x0C	; 12
    1260:	49 f0       	breq	.+18     	; 0x1274 <prvTaskIsTaskSuspended+0x4e>
    1262:	8a 81       	ldd	r24, Y+2	; 0x02
    1264:	9b 81       	ldd	r25, Y+3	; 0x03
    1266:	fc 01       	movw	r30, r24
    1268:	84 89       	ldd	r24, Z+20	; 0x14
    126a:	95 89       	ldd	r25, Z+21	; 0x15
    126c:	89 2b       	or	r24, r25
    126e:	11 f4       	brne	.+4      	; 0x1274 <prvTaskIsTaskSuspended+0x4e>
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	89 83       	std	Y+1, r24	; 0x01
    1274:	89 81       	ldd	r24, Y+1	; 0x01
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	0f 90       	pop	r0
    127c:	0f 90       	pop	r0
    127e:	0f 90       	pop	r0
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	08 95       	ret

00001286 <vTaskResume>:
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	00 d0       	rcall	.+0      	; 0x128c <vTaskResume+0x6>
    128c:	1f 92       	push	r1
    128e:	cd b7       	in	r28, 0x3d	; 61
    1290:	de b7       	in	r29, 0x3e	; 62
    1292:	9c 83       	std	Y+4, r25	; 0x04
    1294:	8b 83       	std	Y+3, r24	; 0x03
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	9c 81       	ldd	r25, Y+4	; 0x04
    129a:	9a 83       	std	Y+2, r25	; 0x02
    129c:	89 83       	std	Y+1, r24	; 0x01
    129e:	89 81       	ldd	r24, Y+1	; 0x01
    12a0:	9a 81       	ldd	r25, Y+2	; 0x02
    12a2:	89 2b       	or	r24, r25
    12a4:	09 f4       	brne	.+2      	; 0x12a8 <vTaskResume+0x22>
    12a6:	4c c0       	rjmp	.+152    	; 0x1340 <vTaskResume+0xba>
    12a8:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    12ac:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    12b0:	29 81       	ldd	r18, Y+1	; 0x01
    12b2:	3a 81       	ldd	r19, Y+2	; 0x02
    12b4:	28 17       	cp	r18, r24
    12b6:	39 07       	cpc	r19, r25
    12b8:	09 f4       	brne	.+2      	; 0x12bc <vTaskResume+0x36>
    12ba:	42 c0       	rjmp	.+132    	; 0x1340 <vTaskResume+0xba>
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	0f 92       	push	r0
    12c2:	89 81       	ldd	r24, Y+1	; 0x01
    12c4:	9a 81       	ldd	r25, Y+2	; 0x02
    12c6:	af df       	rcall	.-162    	; 0x1226 <prvTaskIsTaskSuspended>
    12c8:	81 30       	cpi	r24, 0x01	; 1
    12ca:	c1 f5       	brne	.+112    	; 0x133c <vTaskResume+0xb6>
    12cc:	89 81       	ldd	r24, Y+1	; 0x01
    12ce:	9a 81       	ldd	r25, Y+2	; 0x02
    12d0:	02 96       	adiw	r24, 0x02	; 2
    12d2:	49 d8       	rcall	.-3950   	; 0x366 <uxListRemove>
    12d4:	89 81       	ldd	r24, Y+1	; 0x01
    12d6:	9a 81       	ldd	r25, Y+2	; 0x02
    12d8:	fc 01       	movw	r30, r24
    12da:	96 89       	ldd	r25, Z+22	; 0x16
    12dc:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    12e0:	89 17       	cp	r24, r25
    12e2:	30 f4       	brcc	.+12     	; 0x12f0 <vTaskResume+0x6a>
    12e4:	89 81       	ldd	r24, Y+1	; 0x01
    12e6:	9a 81       	ldd	r25, Y+2	; 0x02
    12e8:	fc 01       	movw	r30, r24
    12ea:	86 89       	ldd	r24, Z+22	; 0x16
    12ec:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    12f0:	89 81       	ldd	r24, Y+1	; 0x01
    12f2:	9a 81       	ldd	r25, Y+2	; 0x02
    12f4:	ac 01       	movw	r20, r24
    12f6:	4e 5f       	subi	r20, 0xFE	; 254
    12f8:	5f 4f       	sbci	r21, 0xFF	; 255
    12fa:	89 81       	ldd	r24, Y+1	; 0x01
    12fc:	9a 81       	ldd	r25, Y+2	; 0x02
    12fe:	fc 01       	movw	r30, r24
    1300:	86 89       	ldd	r24, Z+22	; 0x16
    1302:	28 2f       	mov	r18, r24
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	c9 01       	movw	r24, r18
    1308:	88 0f       	add	r24, r24
    130a:	99 1f       	adc	r25, r25
    130c:	88 0f       	add	r24, r24
    130e:	99 1f       	adc	r25, r25
    1310:	88 0f       	add	r24, r24
    1312:	99 1f       	adc	r25, r25
    1314:	82 0f       	add	r24, r18
    1316:	93 1f       	adc	r25, r19
    1318:	86 51       	subi	r24, 0x16	; 22
    131a:	94 4f       	sbci	r25, 0xF4	; 244
    131c:	ba 01       	movw	r22, r20
    131e:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    1322:	89 81       	ldd	r24, Y+1	; 0x01
    1324:	9a 81       	ldd	r25, Y+2	; 0x02
    1326:	fc 01       	movw	r30, r24
    1328:	26 89       	ldd	r18, Z+22	; 0x16
    132a:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    132e:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1332:	fc 01       	movw	r30, r24
    1334:	86 89       	ldd	r24, Z+22	; 0x16
    1336:	28 17       	cp	r18, r24
    1338:	08 f0       	brcs	.+2      	; 0x133c <vTaskResume+0xb6>
    133a:	68 da       	rcall	.-2864   	; 0x80c <vPortYield>
    133c:	0f 90       	pop	r0
    133e:	0f be       	out	0x3f, r0	; 63
    1340:	0f 90       	pop	r0
    1342:	0f 90       	pop	r0
    1344:	0f 90       	pop	r0
    1346:	0f 90       	pop	r0
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	08 95       	ret

0000134e <vTaskStartScheduler>:
    134e:	af 92       	push	r10
    1350:	bf 92       	push	r11
    1352:	cf 92       	push	r12
    1354:	df 92       	push	r13
    1356:	ef 92       	push	r14
    1358:	ff 92       	push	r15
    135a:	0f 93       	push	r16
    135c:	cf 93       	push	r28
    135e:	df 93       	push	r29
    1360:	1f 92       	push	r1
    1362:	cd b7       	in	r28, 0x3d	; 61
    1364:	de b7       	in	r29, 0x3e	; 62
    1366:	a1 2c       	mov	r10, r1
    1368:	b1 2c       	mov	r11, r1
    136a:	c1 2c       	mov	r12, r1
    136c:	d1 2c       	mov	r13, r1
    136e:	e1 2c       	mov	r14, r1
    1370:	f1 2c       	mov	r15, r1
    1372:	00 e0       	ldi	r16, 0x00	; 0
    1374:	20 e0       	ldi	r18, 0x00	; 0
    1376:	30 e0       	ldi	r19, 0x00	; 0
    1378:	49 eb       	ldi	r20, 0xB9	; 185
    137a:	50 e0       	ldi	r21, 0x00	; 0
    137c:	62 e0       	ldi	r22, 0x02	; 2
    137e:	72 e0       	ldi	r23, 0x02	; 2
    1380:	82 e7       	ldi	r24, 0x72	; 114
    1382:	90 e0       	ldi	r25, 0x00	; 0
    1384:	e3 dd       	rcall	.-1082   	; 0xf4c <xTaskGenericCreate>
    1386:	89 83       	std	Y+1, r24	; 0x01
    1388:	89 81       	ldd	r24, Y+1	; 0x01
    138a:	81 30       	cpi	r24, 0x01	; 1
    138c:	49 f4       	brne	.+18     	; 0x13a0 <vTaskStartScheduler+0x52>
    138e:	f8 94       	cli
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <xSchedulerRunning>
    1396:	10 92 42 0c 	sts	0x0C42, r1	; 0x800c42 <xTickCount+0x1>
    139a:	10 92 41 0c 	sts	0x0C41, r1	; 0x800c41 <xTickCount>
    139e:	fe d9       	rcall	.-3076   	; 0x79c <xPortStartScheduler>
    13a0:	0f 90       	pop	r0
    13a2:	df 91       	pop	r29
    13a4:	cf 91       	pop	r28
    13a6:	0f 91       	pop	r16
    13a8:	ff 90       	pop	r15
    13aa:	ef 90       	pop	r14
    13ac:	df 90       	pop	r13
    13ae:	cf 90       	pop	r12
    13b0:	bf 90       	pop	r11
    13b2:	af 90       	pop	r10
    13b4:	08 95       	ret

000013b6 <vTaskSuspendAll>:
    13b6:	cf 93       	push	r28
    13b8:	df 93       	push	r29
    13ba:	cd b7       	in	r28, 0x3d	; 61
    13bc:	de b7       	in	r29, 0x3e	; 62
    13be:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    13c2:	8f 5f       	subi	r24, 0xFF	; 255
    13c4:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <uxSchedulerSuspended>
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	08 95       	ret

000013ce <xTaskResumeAll>:
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
    13d2:	00 d0       	rcall	.+0      	; 0x13d4 <xTaskResumeAll+0x6>
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
    13d8:	19 82       	std	Y+1, r1	; 0x01
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
    13e0:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    13e4:	81 50       	subi	r24, 0x01	; 1
    13e6:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <uxSchedulerSuspended>
    13ea:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    13ee:	88 23       	and	r24, r24
    13f0:	09 f0       	breq	.+2      	; 0x13f4 <xTaskResumeAll+0x26>
    13f2:	6f c0       	rjmp	.+222    	; 0x14d2 <xTaskResumeAll+0x104>
    13f4:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <uxCurrentNumberOfTasks>
    13f8:	88 23       	and	r24, r24
    13fa:	09 f4       	brne	.+2      	; 0x13fe <xTaskResumeAll+0x30>
    13fc:	6a c0       	rjmp	.+212    	; 0x14d2 <xTaskResumeAll+0x104>
    13fe:	49 c0       	rjmp	.+146    	; 0x1492 <xTaskResumeAll+0xc4>
    1400:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <xPendingReadyList+0x5>
    1404:	90 91 2a 0c 	lds	r25, 0x0C2A	; 0x800c2a <xPendingReadyList+0x6>
    1408:	fc 01       	movw	r30, r24
    140a:	86 81       	ldd	r24, Z+6	; 0x06
    140c:	97 81       	ldd	r25, Z+7	; 0x07
    140e:	9b 83       	std	Y+3, r25	; 0x03
    1410:	8a 83       	std	Y+2, r24	; 0x02
    1412:	8a 81       	ldd	r24, Y+2	; 0x02
    1414:	9b 81       	ldd	r25, Y+3	; 0x03
    1416:	0c 96       	adiw	r24, 0x0c	; 12
    1418:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	9b 81       	ldd	r25, Y+3	; 0x03
    1420:	02 96       	adiw	r24, 0x02	; 2
    1422:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	9b 81       	ldd	r25, Y+3	; 0x03
    142a:	fc 01       	movw	r30, r24
    142c:	96 89       	ldd	r25, Z+22	; 0x16
    142e:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1432:	89 17       	cp	r24, r25
    1434:	30 f4       	brcc	.+12     	; 0x1442 <xTaskResumeAll+0x74>
    1436:	8a 81       	ldd	r24, Y+2	; 0x02
    1438:	9b 81       	ldd	r25, Y+3	; 0x03
    143a:	fc 01       	movw	r30, r24
    143c:	86 89       	ldd	r24, Z+22	; 0x16
    143e:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    1442:	8a 81       	ldd	r24, Y+2	; 0x02
    1444:	9b 81       	ldd	r25, Y+3	; 0x03
    1446:	ac 01       	movw	r20, r24
    1448:	4e 5f       	subi	r20, 0xFE	; 254
    144a:	5f 4f       	sbci	r21, 0xFF	; 255
    144c:	8a 81       	ldd	r24, Y+2	; 0x02
    144e:	9b 81       	ldd	r25, Y+3	; 0x03
    1450:	fc 01       	movw	r30, r24
    1452:	86 89       	ldd	r24, Z+22	; 0x16
    1454:	28 2f       	mov	r18, r24
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	c9 01       	movw	r24, r18
    145a:	88 0f       	add	r24, r24
    145c:	99 1f       	adc	r25, r25
    145e:	88 0f       	add	r24, r24
    1460:	99 1f       	adc	r25, r25
    1462:	88 0f       	add	r24, r24
    1464:	99 1f       	adc	r25, r25
    1466:	82 0f       	add	r24, r18
    1468:	93 1f       	adc	r25, r19
    146a:	86 51       	subi	r24, 0x16	; 22
    146c:	94 4f       	sbci	r25, 0xF4	; 244
    146e:	ba 01       	movw	r22, r20
    1470:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    1474:	8a 81       	ldd	r24, Y+2	; 0x02
    1476:	9b 81       	ldd	r25, Y+3	; 0x03
    1478:	fc 01       	movw	r30, r24
    147a:	26 89       	ldd	r18, Z+22	; 0x16
    147c:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1480:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1484:	fc 01       	movw	r30, r24
    1486:	86 89       	ldd	r24, Z+22	; 0x16
    1488:	28 17       	cp	r18, r24
    148a:	18 f0       	brcs	.+6      	; 0x1492 <xTaskResumeAll+0xc4>
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xYieldPending>
    1492:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <xPendingReadyList>
    1496:	88 23       	and	r24, r24
    1498:	09 f0       	breq	.+2      	; 0x149c <xTaskResumeAll+0xce>
    149a:	b2 cf       	rjmp	.-156    	; 0x1400 <xTaskResumeAll+0x32>
    149c:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxPendedTicks>
    14a0:	88 23       	and	r24, r24
    14a2:	81 f0       	breq	.+32     	; 0x14c4 <xTaskResumeAll+0xf6>
    14a4:	0b c0       	rjmp	.+22     	; 0x14bc <xTaskResumeAll+0xee>
    14a6:	1e d0       	rcall	.+60     	; 0x14e4 <xTaskIncrementTick>
    14a8:	88 23       	and	r24, r24
    14aa:	19 f0       	breq	.+6      	; 0x14b2 <xTaskResumeAll+0xe4>
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xYieldPending>
    14b2:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxPendedTicks>
    14b6:	81 50       	subi	r24, 0x01	; 1
    14b8:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <uxPendedTicks>
    14bc:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxPendedTicks>
    14c0:	88 23       	and	r24, r24
    14c2:	89 f7       	brne	.-30     	; 0x14a6 <xTaskResumeAll+0xd8>
    14c4:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <xYieldPending>
    14c8:	81 30       	cpi	r24, 0x01	; 1
    14ca:	19 f4       	brne	.+6      	; 0x14d2 <xTaskResumeAll+0x104>
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	89 83       	std	Y+1, r24	; 0x01
    14d0:	9d d9       	rcall	.-3270   	; 0x80c <vPortYield>
    14d2:	0f 90       	pop	r0
    14d4:	0f be       	out	0x3f, r0	; 63
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	0f 90       	pop	r0
    14da:	0f 90       	pop	r0
    14dc:	0f 90       	pop	r0
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	08 95       	ret

000014e4 <xTaskIncrementTick>:
    14e4:	cf 93       	push	r28
    14e6:	df 93       	push	r29
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
    14ec:	29 97       	sbiw	r28, 0x09	; 9
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	de bf       	out	0x3e, r29	; 62
    14f4:	0f be       	out	0x3f, r0	; 63
    14f6:	cd bf       	out	0x3d, r28	; 61
    14f8:	19 82       	std	Y+1, r1	; 0x01
    14fa:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    14fe:	88 23       	and	r24, r24
    1500:	09 f0       	breq	.+2      	; 0x1504 <xTaskIncrementTick+0x20>
    1502:	c8 c0       	rjmp	.+400    	; 0x1694 <xTaskIncrementTick+0x1b0>
    1504:	80 91 41 0c 	lds	r24, 0x0C41	; 0x800c41 <xTickCount>
    1508:	90 91 42 0c 	lds	r25, 0x0C42	; 0x800c42 <xTickCount+0x1>
    150c:	01 96       	adiw	r24, 0x01	; 1
    150e:	90 93 42 0c 	sts	0x0C42, r25	; 0x800c42 <xTickCount+0x1>
    1512:	80 93 41 0c 	sts	0x0C41, r24	; 0x800c41 <xTickCount>
    1516:	80 91 41 0c 	lds	r24, 0x0C41	; 0x800c41 <xTickCount>
    151a:	90 91 42 0c 	lds	r25, 0x0C42	; 0x800c42 <xTickCount+0x1>
    151e:	9b 83       	std	Y+3, r25	; 0x03
    1520:	8a 83       	std	Y+2, r24	; 0x02
    1522:	8a 81       	ldd	r24, Y+2	; 0x02
    1524:	9b 81       	ldd	r25, Y+3	; 0x03
    1526:	89 2b       	or	r24, r25
    1528:	d1 f4       	brne	.+52     	; 0x155e <xTaskIncrementTick+0x7a>
    152a:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    152e:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    1532:	9d 83       	std	Y+5, r25	; 0x05
    1534:	8c 83       	std	Y+4, r24	; 0x04
    1536:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <pxOverflowDelayedTaskList>
    153a:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <pxOverflowDelayedTaskList+0x1>
    153e:	90 93 21 0c 	sts	0x0C21, r25	; 0x800c21 <pxDelayedTaskList+0x1>
    1542:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <pxDelayedTaskList>
    1546:	8c 81       	ldd	r24, Y+4	; 0x04
    1548:	9d 81       	ldd	r25, Y+5	; 0x05
    154a:	90 93 23 0c 	sts	0x0C23, r25	; 0x800c23 <pxOverflowDelayedTaskList+0x1>
    154e:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <pxOverflowDelayedTaskList>
    1552:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <xNumOfOverflows>
    1556:	8f 5f       	subi	r24, 0xFF	; 255
    1558:	80 93 47 0c 	sts	0x0C47, r24	; 0x800c47 <xNumOfOverflows>
    155c:	52 d3       	rcall	.+1700   	; 0x1c02 <prvResetNextTaskUnblockTime>
    155e:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    1562:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    1566:	2a 81       	ldd	r18, Y+2	; 0x02
    1568:	3b 81       	ldd	r19, Y+3	; 0x03
    156a:	28 17       	cp	r18, r24
    156c:	39 07       	cpc	r19, r25
    156e:	08 f4       	brcc	.+2      	; 0x1572 <xTaskIncrementTick+0x8e>
    1570:	77 c0       	rjmp	.+238    	; 0x1660 <xTaskIncrementTick+0x17c>
    1572:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    1576:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    157a:	fc 01       	movw	r30, r24
    157c:	80 81       	ld	r24, Z
    157e:	88 23       	and	r24, r24
    1580:	39 f4       	brne	.+14     	; 0x1590 <xTaskIncrementTick+0xac>
    1582:	8f ef       	ldi	r24, 0xFF	; 255
    1584:	9f ef       	ldi	r25, 0xFF	; 255
    1586:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    158a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    158e:	68 c0       	rjmp	.+208    	; 0x1660 <xTaskIncrementTick+0x17c>
    1590:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    1594:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    1598:	fc 01       	movw	r30, r24
    159a:	85 81       	ldd	r24, Z+5	; 0x05
    159c:	96 81       	ldd	r25, Z+6	; 0x06
    159e:	fc 01       	movw	r30, r24
    15a0:	86 81       	ldd	r24, Z+6	; 0x06
    15a2:	97 81       	ldd	r25, Z+7	; 0x07
    15a4:	9f 83       	std	Y+7, r25	; 0x07
    15a6:	8e 83       	std	Y+6, r24	; 0x06
    15a8:	8e 81       	ldd	r24, Y+6	; 0x06
    15aa:	9f 81       	ldd	r25, Y+7	; 0x07
    15ac:	fc 01       	movw	r30, r24
    15ae:	82 81       	ldd	r24, Z+2	; 0x02
    15b0:	93 81       	ldd	r25, Z+3	; 0x03
    15b2:	99 87       	std	Y+9, r25	; 0x09
    15b4:	88 87       	std	Y+8, r24	; 0x08
    15b6:	2a 81       	ldd	r18, Y+2	; 0x02
    15b8:	3b 81       	ldd	r19, Y+3	; 0x03
    15ba:	88 85       	ldd	r24, Y+8	; 0x08
    15bc:	99 85       	ldd	r25, Y+9	; 0x09
    15be:	28 17       	cp	r18, r24
    15c0:	39 07       	cpc	r19, r25
    15c2:	38 f4       	brcc	.+14     	; 0x15d2 <xTaskIncrementTick+0xee>
    15c4:	88 85       	ldd	r24, Y+8	; 0x08
    15c6:	99 85       	ldd	r25, Y+9	; 0x09
    15c8:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    15cc:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    15d0:	47 c0       	rjmp	.+142    	; 0x1660 <xTaskIncrementTick+0x17c>
    15d2:	8e 81       	ldd	r24, Y+6	; 0x06
    15d4:	9f 81       	ldd	r25, Y+7	; 0x07
    15d6:	02 96       	adiw	r24, 0x02	; 2
    15d8:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    15dc:	8e 81       	ldd	r24, Y+6	; 0x06
    15de:	9f 81       	ldd	r25, Y+7	; 0x07
    15e0:	fc 01       	movw	r30, r24
    15e2:	84 89       	ldd	r24, Z+20	; 0x14
    15e4:	95 89       	ldd	r25, Z+21	; 0x15
    15e6:	89 2b       	or	r24, r25
    15e8:	29 f0       	breq	.+10     	; 0x15f4 <xTaskIncrementTick+0x110>
    15ea:	8e 81       	ldd	r24, Y+6	; 0x06
    15ec:	9f 81       	ldd	r25, Y+7	; 0x07
    15ee:	0c 96       	adiw	r24, 0x0c	; 12
    15f0:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    15f4:	8e 81       	ldd	r24, Y+6	; 0x06
    15f6:	9f 81       	ldd	r25, Y+7	; 0x07
    15f8:	fc 01       	movw	r30, r24
    15fa:	96 89       	ldd	r25, Z+22	; 0x16
    15fc:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1600:	89 17       	cp	r24, r25
    1602:	30 f4       	brcc	.+12     	; 0x1610 <xTaskIncrementTick+0x12c>
    1604:	8e 81       	ldd	r24, Y+6	; 0x06
    1606:	9f 81       	ldd	r25, Y+7	; 0x07
    1608:	fc 01       	movw	r30, r24
    160a:	86 89       	ldd	r24, Z+22	; 0x16
    160c:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    1610:	8e 81       	ldd	r24, Y+6	; 0x06
    1612:	9f 81       	ldd	r25, Y+7	; 0x07
    1614:	ac 01       	movw	r20, r24
    1616:	4e 5f       	subi	r20, 0xFE	; 254
    1618:	5f 4f       	sbci	r21, 0xFF	; 255
    161a:	8e 81       	ldd	r24, Y+6	; 0x06
    161c:	9f 81       	ldd	r25, Y+7	; 0x07
    161e:	fc 01       	movw	r30, r24
    1620:	86 89       	ldd	r24, Z+22	; 0x16
    1622:	28 2f       	mov	r18, r24
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	c9 01       	movw	r24, r18
    1628:	88 0f       	add	r24, r24
    162a:	99 1f       	adc	r25, r25
    162c:	88 0f       	add	r24, r24
    162e:	99 1f       	adc	r25, r25
    1630:	88 0f       	add	r24, r24
    1632:	99 1f       	adc	r25, r25
    1634:	82 0f       	add	r24, r18
    1636:	93 1f       	adc	r25, r19
    1638:	86 51       	subi	r24, 0x16	; 22
    163a:	94 4f       	sbci	r25, 0xF4	; 244
    163c:	ba 01       	movw	r22, r20
    163e:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    1642:	8e 81       	ldd	r24, Y+6	; 0x06
    1644:	9f 81       	ldd	r25, Y+7	; 0x07
    1646:	fc 01       	movw	r30, r24
    1648:	26 89       	ldd	r18, Z+22	; 0x16
    164a:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    164e:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1652:	fc 01       	movw	r30, r24
    1654:	86 89       	ldd	r24, Z+22	; 0x16
    1656:	28 17       	cp	r18, r24
    1658:	10 f0       	brcs	.+4      	; 0x165e <xTaskIncrementTick+0x17a>
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	89 83       	std	Y+1, r24	; 0x01
    165e:	89 cf       	rjmp	.-238    	; 0x1572 <xTaskIncrementTick+0x8e>
    1660:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1664:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1668:	fc 01       	movw	r30, r24
    166a:	86 89       	ldd	r24, Z+22	; 0x16
    166c:	28 2f       	mov	r18, r24
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	c9 01       	movw	r24, r18
    1672:	88 0f       	add	r24, r24
    1674:	99 1f       	adc	r25, r25
    1676:	88 0f       	add	r24, r24
    1678:	99 1f       	adc	r25, r25
    167a:	88 0f       	add	r24, r24
    167c:	99 1f       	adc	r25, r25
    167e:	82 0f       	add	r24, r18
    1680:	93 1f       	adc	r25, r19
    1682:	86 51       	subi	r24, 0x16	; 22
    1684:	94 4f       	sbci	r25, 0xF4	; 244
    1686:	fc 01       	movw	r30, r24
    1688:	80 81       	ld	r24, Z
    168a:	82 30       	cpi	r24, 0x02	; 2
    168c:	40 f0       	brcs	.+16     	; 0x169e <xTaskIncrementTick+0x1ba>
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	89 83       	std	Y+1, r24	; 0x01
    1692:	05 c0       	rjmp	.+10     	; 0x169e <xTaskIncrementTick+0x1ba>
    1694:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxPendedTicks>
    1698:	8f 5f       	subi	r24, 0xFF	; 255
    169a:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <uxPendedTicks>
    169e:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <xYieldPending>
    16a2:	88 23       	and	r24, r24
    16a4:	11 f0       	breq	.+4      	; 0x16aa <xTaskIncrementTick+0x1c6>
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	89 83       	std	Y+1, r24	; 0x01
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	29 96       	adiw	r28, 0x09	; 9
    16ae:	0f b6       	in	r0, 0x3f	; 63
    16b0:	f8 94       	cli
    16b2:	de bf       	out	0x3e, r29	; 62
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	cd bf       	out	0x3d, r28	; 61
    16b8:	df 91       	pop	r29
    16ba:	cf 91       	pop	r28
    16bc:	08 95       	ret

000016be <vTaskSwitchContext>:
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	1f 92       	push	r1
    16c4:	1f 92       	push	r1
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
    16ca:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    16ce:	88 23       	and	r24, r24
    16d0:	21 f0       	breq	.+8      	; 0x16da <vTaskSwitchContext+0x1c>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xYieldPending>
    16d8:	7b c0       	rjmp	.+246    	; 0x17d0 <vTaskSwitchContext+0x112>
    16da:	10 92 46 0c 	sts	0x0C46, r1	; 0x800c46 <xYieldPending>
    16de:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    16e2:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    16e6:	fc 01       	movw	r30, r24
    16e8:	20 81       	ld	r18, Z
    16ea:	31 81       	ldd	r19, Z+1	; 0x01
    16ec:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    16f0:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    16f4:	fc 01       	movw	r30, r24
    16f6:	87 89       	ldd	r24, Z+23	; 0x17
    16f8:	90 8d       	ldd	r25, Z+24	; 0x18
    16fa:	82 17       	cp	r24, r18
    16fc:	93 07       	cpc	r25, r19
    16fe:	68 f0       	brcs	.+26     	; 0x171a <vTaskSwitchContext+0x5c>
    1700:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1704:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1708:	9c 01       	movw	r18, r24
    170a:	27 5e       	subi	r18, 0xE7	; 231
    170c:	3f 4f       	sbci	r19, 0xFF	; 255
    170e:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1712:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1716:	b9 01       	movw	r22, r18
    1718:	80 d3       	rcall	.+1792   	; 0x1e1a <vApplicationStackOverflowHook>
    171a:	05 c0       	rjmp	.+10     	; 0x1726 <vTaskSwitchContext+0x68>
    171c:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1720:	81 50       	subi	r24, 0x01	; 1
    1722:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    1726:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    172a:	28 2f       	mov	r18, r24
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	c9 01       	movw	r24, r18
    1730:	88 0f       	add	r24, r24
    1732:	99 1f       	adc	r25, r25
    1734:	88 0f       	add	r24, r24
    1736:	99 1f       	adc	r25, r25
    1738:	88 0f       	add	r24, r24
    173a:	99 1f       	adc	r25, r25
    173c:	82 0f       	add	r24, r18
    173e:	93 1f       	adc	r25, r19
    1740:	86 51       	subi	r24, 0x16	; 22
    1742:	94 4f       	sbci	r25, 0xF4	; 244
    1744:	fc 01       	movw	r30, r24
    1746:	80 81       	ld	r24, Z
    1748:	88 23       	and	r24, r24
    174a:	41 f3       	breq	.-48     	; 0x171c <vTaskSwitchContext+0x5e>
    174c:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1750:	28 2f       	mov	r18, r24
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	c9 01       	movw	r24, r18
    1756:	88 0f       	add	r24, r24
    1758:	99 1f       	adc	r25, r25
    175a:	88 0f       	add	r24, r24
    175c:	99 1f       	adc	r25, r25
    175e:	88 0f       	add	r24, r24
    1760:	99 1f       	adc	r25, r25
    1762:	82 0f       	add	r24, r18
    1764:	93 1f       	adc	r25, r19
    1766:	86 51       	subi	r24, 0x16	; 22
    1768:	94 4f       	sbci	r25, 0xF4	; 244
    176a:	9a 83       	std	Y+2, r25	; 0x02
    176c:	89 83       	std	Y+1, r24	; 0x01
    176e:	89 81       	ldd	r24, Y+1	; 0x01
    1770:	9a 81       	ldd	r25, Y+2	; 0x02
    1772:	fc 01       	movw	r30, r24
    1774:	81 81       	ldd	r24, Z+1	; 0x01
    1776:	92 81       	ldd	r25, Z+2	; 0x02
    1778:	fc 01       	movw	r30, r24
    177a:	22 81       	ldd	r18, Z+2	; 0x02
    177c:	33 81       	ldd	r19, Z+3	; 0x03
    177e:	89 81       	ldd	r24, Y+1	; 0x01
    1780:	9a 81       	ldd	r25, Y+2	; 0x02
    1782:	fc 01       	movw	r30, r24
    1784:	32 83       	std	Z+2, r19	; 0x02
    1786:	21 83       	std	Z+1, r18	; 0x01
    1788:	89 81       	ldd	r24, Y+1	; 0x01
    178a:	9a 81       	ldd	r25, Y+2	; 0x02
    178c:	fc 01       	movw	r30, r24
    178e:	21 81       	ldd	r18, Z+1	; 0x01
    1790:	32 81       	ldd	r19, Z+2	; 0x02
    1792:	89 81       	ldd	r24, Y+1	; 0x01
    1794:	9a 81       	ldd	r25, Y+2	; 0x02
    1796:	03 96       	adiw	r24, 0x03	; 3
    1798:	28 17       	cp	r18, r24
    179a:	39 07       	cpc	r19, r25
    179c:	69 f4       	brne	.+26     	; 0x17b8 <vTaskSwitchContext+0xfa>
    179e:	89 81       	ldd	r24, Y+1	; 0x01
    17a0:	9a 81       	ldd	r25, Y+2	; 0x02
    17a2:	fc 01       	movw	r30, r24
    17a4:	81 81       	ldd	r24, Z+1	; 0x01
    17a6:	92 81       	ldd	r25, Z+2	; 0x02
    17a8:	fc 01       	movw	r30, r24
    17aa:	22 81       	ldd	r18, Z+2	; 0x02
    17ac:	33 81       	ldd	r19, Z+3	; 0x03
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	fc 01       	movw	r30, r24
    17b4:	32 83       	std	Z+2, r19	; 0x02
    17b6:	21 83       	std	Z+1, r18	; 0x01
    17b8:	89 81       	ldd	r24, Y+1	; 0x01
    17ba:	9a 81       	ldd	r25, Y+2	; 0x02
    17bc:	fc 01       	movw	r30, r24
    17be:	81 81       	ldd	r24, Z+1	; 0x01
    17c0:	92 81       	ldd	r25, Z+2	; 0x02
    17c2:	fc 01       	movw	r30, r24
    17c4:	86 81       	ldd	r24, Z+6	; 0x06
    17c6:	97 81       	ldd	r25, Z+7	; 0x07
    17c8:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <pxCurrentTCB+0x1>
    17cc:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <pxCurrentTCB>
    17d0:	0f 90       	pop	r0
    17d2:	0f 90       	pop	r0
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	08 95       	ret

000017da <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    17da:	cf 93       	push	r28
    17dc:	df 93       	push	r29
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <xTaskRemoveFromEventList+0x6>
    17e0:	1f 92       	push	r1
    17e2:	1f 92       	push	r1
    17e4:	cd b7       	in	r28, 0x3d	; 61
    17e6:	de b7       	in	r29, 0x3e	; 62
    17e8:	9d 83       	std	Y+5, r25	; 0x05
    17ea:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    17ec:	8c 81       	ldd	r24, Y+4	; 0x04
    17ee:	9d 81       	ldd	r25, Y+5	; 0x05
    17f0:	fc 01       	movw	r30, r24
    17f2:	85 81       	ldd	r24, Z+5	; 0x05
    17f4:	96 81       	ldd	r25, Z+6	; 0x06
    17f6:	fc 01       	movw	r30, r24
    17f8:	86 81       	ldd	r24, Z+6	; 0x06
    17fa:	97 81       	ldd	r25, Z+7	; 0x07
    17fc:	9b 83       	std	Y+3, r25	; 0x03
    17fe:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1800:	8a 81       	ldd	r24, Y+2	; 0x02
    1802:	9b 81       	ldd	r25, Y+3	; 0x03
    1804:	0c 96       	adiw	r24, 0x0c	; 12
    1806:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    180a:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <uxSchedulerSuspended>
    180e:	88 23       	and	r24, r24
    1810:	69 f5       	brne	.+90     	; 0x186c <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1812:	8a 81       	ldd	r24, Y+2	; 0x02
    1814:	9b 81       	ldd	r25, Y+3	; 0x03
    1816:	02 96       	adiw	r24, 0x02	; 2
    1818:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    181c:	8a 81       	ldd	r24, Y+2	; 0x02
    181e:	9b 81       	ldd	r25, Y+3	; 0x03
    1820:	fc 01       	movw	r30, r24
    1822:	96 89       	ldd	r25, Z+22	; 0x16
    1824:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <uxTopReadyPriority>
    1828:	89 17       	cp	r24, r25
    182a:	30 f4       	brcc	.+12     	; 0x1838 <xTaskRemoveFromEventList+0x5e>
    182c:	8a 81       	ldd	r24, Y+2	; 0x02
    182e:	9b 81       	ldd	r25, Y+3	; 0x03
    1830:	fc 01       	movw	r30, r24
    1832:	86 89       	ldd	r24, Z+22	; 0x16
    1834:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <uxTopReadyPriority>
    1838:	8a 81       	ldd	r24, Y+2	; 0x02
    183a:	9b 81       	ldd	r25, Y+3	; 0x03
    183c:	ac 01       	movw	r20, r24
    183e:	4e 5f       	subi	r20, 0xFE	; 254
    1840:	5f 4f       	sbci	r21, 0xFF	; 255
    1842:	8a 81       	ldd	r24, Y+2	; 0x02
    1844:	9b 81       	ldd	r25, Y+3	; 0x03
    1846:	fc 01       	movw	r30, r24
    1848:	86 89       	ldd	r24, Z+22	; 0x16
    184a:	28 2f       	mov	r18, r24
    184c:	30 e0       	ldi	r19, 0x00	; 0
    184e:	c9 01       	movw	r24, r18
    1850:	88 0f       	add	r24, r24
    1852:	99 1f       	adc	r25, r25
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	88 0f       	add	r24, r24
    185a:	99 1f       	adc	r25, r25
    185c:	82 0f       	add	r24, r18
    185e:	93 1f       	adc	r25, r19
    1860:	86 51       	subi	r24, 0x16	; 22
    1862:	94 4f       	sbci	r25, 0xF4	; 244
    1864:	ba 01       	movw	r22, r20
    1866:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    186a:	08 c0       	rjmp	.+16     	; 0x187c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    186c:	8a 81       	ldd	r24, Y+2	; 0x02
    186e:	9b 81       	ldd	r25, Y+3	; 0x03
    1870:	0c 96       	adiw	r24, 0x0c	; 12
    1872:	bc 01       	movw	r22, r24
    1874:	84 e2       	ldi	r24, 0x24	; 36
    1876:	9c e0       	ldi	r25, 0x0C	; 12
    1878:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    187c:	8a 81       	ldd	r24, Y+2	; 0x02
    187e:	9b 81       	ldd	r25, Y+3	; 0x03
    1880:	fc 01       	movw	r30, r24
    1882:	26 89       	ldd	r18, Z+22	; 0x16
    1884:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1888:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    188c:	fc 01       	movw	r30, r24
    188e:	86 89       	ldd	r24, Z+22	; 0x16
    1890:	82 17       	cp	r24, r18
    1892:	30 f4       	brcc	.+12     	; 0x18a0 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xYieldPending>
    189e:	01 c0       	rjmp	.+2      	; 0x18a2 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    18a0:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    18a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    18a4:	0f 90       	pop	r0
    18a6:	0f 90       	pop	r0
    18a8:	0f 90       	pop	r0
    18aa:	0f 90       	pop	r0
    18ac:	0f 90       	pop	r0
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	08 95       	ret

000018b4 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    18b4:	0f 93       	push	r16
    18b6:	1f 93       	push	r17
    18b8:	cf 93       	push	r28
    18ba:	df 93       	push	r29
    18bc:	cd b7       	in	r28, 0x3d	; 61
    18be:	de b7       	in	r29, 0x3e	; 62
    18c0:	2a 97       	sbiw	r28, 0x0a	; 10
    18c2:	0f b6       	in	r0, 0x3f	; 63
    18c4:	f8 94       	cli
    18c6:	de bf       	out	0x3e, r29	; 62
    18c8:	0f be       	out	0x3f, r0	; 63
    18ca:	cd bf       	out	0x3d, r28	; 61
    18cc:	9b 83       	std	Y+3, r25	; 0x03
    18ce:	8a 83       	std	Y+2, r24	; 0x02
    18d0:	7d 83       	std	Y+5, r23	; 0x05
    18d2:	6c 83       	std	Y+4, r22	; 0x04
    18d4:	4e 83       	std	Y+6, r20	; 0x06
    18d6:	38 87       	std	Y+8, r19	; 0x08
    18d8:	2f 83       	std	Y+7, r18	; 0x07
    18da:	1a 87       	std	Y+10, r17	; 0x0a
    18dc:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    18de:	19 82       	std	Y+1, r1	; 0x01
    18e0:	22 c0       	rjmp	.+68     	; 0x1926 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    18e2:	89 81       	ldd	r24, Y+1	; 0x01
    18e4:	88 2f       	mov	r24, r24
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	29 81       	ldd	r18, Y+1	; 0x01
    18ea:	22 2f       	mov	r18, r18
    18ec:	30 e0       	ldi	r19, 0x00	; 0
    18ee:	4c 81       	ldd	r20, Y+4	; 0x04
    18f0:	5d 81       	ldd	r21, Y+5	; 0x05
    18f2:	24 0f       	add	r18, r20
    18f4:	35 1f       	adc	r19, r21
    18f6:	f9 01       	movw	r30, r18
    18f8:	40 81       	ld	r20, Z
    18fa:	2a 81       	ldd	r18, Y+2	; 0x02
    18fc:	3b 81       	ldd	r19, Y+3	; 0x03
    18fe:	82 0f       	add	r24, r18
    1900:	93 1f       	adc	r25, r19
    1902:	49 96       	adiw	r24, 0x19	; 25
    1904:	fc 01       	movw	r30, r24
    1906:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	88 2f       	mov	r24, r24
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	2c 81       	ldd	r18, Y+4	; 0x04
    1910:	3d 81       	ldd	r19, Y+5	; 0x05
    1912:	82 0f       	add	r24, r18
    1914:	93 1f       	adc	r25, r19
    1916:	fc 01       	movw	r30, r24
    1918:	80 81       	ld	r24, Z
    191a:	88 23       	and	r24, r24
    191c:	09 f4       	brne	.+2      	; 0x1920 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    191e:	06 c0       	rjmp	.+12     	; 0x192c <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	8f 5f       	subi	r24, 0xFF	; 255
    1924:	89 83       	std	Y+1, r24	; 0x01
    1926:	89 81       	ldd	r24, Y+1	; 0x01
    1928:	88 30       	cpi	r24, 0x08	; 8
    192a:	d8 f2       	brcs	.-74     	; 0x18e2 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    192c:	8a 81       	ldd	r24, Y+2	; 0x02
    192e:	9b 81       	ldd	r25, Y+3	; 0x03
    1930:	fc 01       	movw	r30, r24
    1932:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1934:	8e 81       	ldd	r24, Y+6	; 0x06
    1936:	84 30       	cpi	r24, 0x04	; 4
    1938:	10 f0       	brcs	.+4      	; 0x193e <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    193a:	83 e0       	ldi	r24, 0x03	; 3
    193c:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    193e:	8a 81       	ldd	r24, Y+2	; 0x02
    1940:	9b 81       	ldd	r25, Y+3	; 0x03
    1942:	2e 81       	ldd	r18, Y+6	; 0x06
    1944:	fc 01       	movw	r30, r24
    1946:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1948:	8a 81       	ldd	r24, Y+2	; 0x02
    194a:	9b 81       	ldd	r25, Y+3	; 0x03
    194c:	02 96       	adiw	r24, 0x02	; 2
    194e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1952:	8a 81       	ldd	r24, Y+2	; 0x02
    1954:	9b 81       	ldd	r25, Y+3	; 0x03
    1956:	0c 96       	adiw	r24, 0x0c	; 12
    1958:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    195c:	8a 81       	ldd	r24, Y+2	; 0x02
    195e:	9b 81       	ldd	r25, Y+3	; 0x03
    1960:	2a 81       	ldd	r18, Y+2	; 0x02
    1962:	3b 81       	ldd	r19, Y+3	; 0x03
    1964:	fc 01       	movw	r30, r24
    1966:	31 87       	std	Z+9, r19	; 0x09
    1968:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    196a:	8e 81       	ldd	r24, Y+6	; 0x06
    196c:	88 2f       	mov	r24, r24
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	24 e0       	ldi	r18, 0x04	; 4
    1972:	30 e0       	ldi	r19, 0x00	; 0
    1974:	28 1b       	sub	r18, r24
    1976:	39 0b       	sbc	r19, r25
    1978:	8a 81       	ldd	r24, Y+2	; 0x02
    197a:	9b 81       	ldd	r25, Y+3	; 0x03
    197c:	fc 01       	movw	r30, r24
    197e:	35 87       	std	Z+13, r19	; 0x0d
    1980:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1982:	8a 81       	ldd	r24, Y+2	; 0x02
    1984:	9b 81       	ldd	r25, Y+3	; 0x03
    1986:	2a 81       	ldd	r18, Y+2	; 0x02
    1988:	3b 81       	ldd	r19, Y+3	; 0x03
    198a:	fc 01       	movw	r30, r24
    198c:	33 8b       	std	Z+19, r19	; 0x13
    198e:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1990:	8a 81       	ldd	r24, Y+2	; 0x02
    1992:	9b 81       	ldd	r25, Y+3	; 0x03
    1994:	fc 01       	movw	r30, r24
    1996:	11 a2       	std	Z+33, r1	; 0x21
    1998:	12 a2       	std	Z+34, r1	; 0x22
    199a:	13 a2       	std	Z+35, r1	; 0x23
    199c:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    199e:	8a 81       	ldd	r24, Y+2	; 0x02
    19a0:	9b 81       	ldd	r25, Y+3	; 0x03
    19a2:	fc 01       	movw	r30, r24
    19a4:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    19a6:	2a 96       	adiw	r28, 0x0a	; 10
    19a8:	0f b6       	in	r0, 0x3f	; 63
    19aa:	f8 94       	cli
    19ac:	de bf       	out	0x3e, r29	; 62
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	cd bf       	out	0x3d, r28	; 61
    19b2:	df 91       	pop	r29
    19b4:	cf 91       	pop	r28
    19b6:	1f 91       	pop	r17
    19b8:	0f 91       	pop	r16
    19ba:	08 95       	ret

000019bc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    19bc:	cf 93       	push	r28
    19be:	df 93       	push	r29
    19c0:	1f 92       	push	r1
    19c2:	cd b7       	in	r28, 0x3d	; 61
    19c4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    19c6:	19 82       	std	Y+1, r1	; 0x01
    19c8:	13 c0       	rjmp	.+38     	; 0x19f0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	28 2f       	mov	r18, r24
    19ce:	30 e0       	ldi	r19, 0x00	; 0
    19d0:	c9 01       	movw	r24, r18
    19d2:	88 0f       	add	r24, r24
    19d4:	99 1f       	adc	r25, r25
    19d6:	88 0f       	add	r24, r24
    19d8:	99 1f       	adc	r25, r25
    19da:	88 0f       	add	r24, r24
    19dc:	99 1f       	adc	r25, r25
    19de:	82 0f       	add	r24, r18
    19e0:	93 1f       	adc	r25, r19
    19e2:	86 51       	subi	r24, 0x16	; 22
    19e4:	94 4f       	sbci	r25, 0xF4	; 244
    19e6:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	8f 5f       	subi	r24, 0xFF	; 255
    19ee:	89 83       	std	Y+1, r24	; 0x01
    19f0:	89 81       	ldd	r24, Y+1	; 0x01
    19f2:	84 30       	cpi	r24, 0x04	; 4
    19f4:	50 f3       	brcs	.-44     	; 0x19ca <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    19f6:	8e e0       	ldi	r24, 0x0E	; 14
    19f8:	9c e0       	ldi	r25, 0x0C	; 12
    19fa:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    19fe:	87 e1       	ldi	r24, 0x17	; 23
    1a00:	9c e0       	ldi	r25, 0x0C	; 12
    1a02:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1a06:	84 e2       	ldi	r24, 0x24	; 36
    1a08:	9c e0       	ldi	r25, 0x0C	; 12
    1a0a:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1a0e:	8d e2       	ldi	r24, 0x2D	; 45
    1a10:	9c e0       	ldi	r25, 0x0C	; 12
    1a12:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1a16:	87 e3       	ldi	r24, 0x37	; 55
    1a18:	9c e0       	ldi	r25, 0x0C	; 12
    1a1a:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1a1e:	8e e0       	ldi	r24, 0x0E	; 14
    1a20:	9c e0       	ldi	r25, 0x0C	; 12
    1a22:	90 93 21 0c 	sts	0x0C21, r25	; 0x800c21 <pxDelayedTaskList+0x1>
    1a26:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1a2a:	87 e1       	ldi	r24, 0x17	; 23
    1a2c:	9c e0       	ldi	r25, 0x0C	; 12
    1a2e:	90 93 23 0c 	sts	0x0C23, r25	; 0x800c23 <pxOverflowDelayedTaskList+0x1>
    1a32:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <pxOverflowDelayedTaskList>
}
    1a36:	0f 90       	pop	r0
    1a38:	df 91       	pop	r29
    1a3a:	cf 91       	pop	r28
    1a3c:	08 95       	ret

00001a3e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <prvCheckTasksWaitingTermination+0x6>
    1a44:	cd b7       	in	r28, 0x3d	; 61
    1a46:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1a48:	2c c0       	rjmp	.+88     	; 0x1aa2 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
    1a4a:	b5 dc       	rcall	.-1686   	; 0x13b6 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a4c:	90 91 2d 0c 	lds	r25, 0x0C2D	; 0x800c2d <xTasksWaitingTermination>
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	99 23       	and	r25, r25
    1a54:	09 f0       	breq	.+2      	; 0x1a58 <prvCheckTasksWaitingTermination+0x1a>
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    1a5a:	b9 dc       	rcall	.-1678   	; 0x13ce <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	88 23       	and	r24, r24
    1a60:	01 f5       	brne	.+64     	; 0x1aa2 <prvCheckTasksWaitingTermination+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1a62:	0f b6       	in	r0, 0x3f	; 63
    1a64:	f8 94       	cli
    1a66:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1a68:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <xTasksWaitingTermination+0x5>
    1a6c:	90 91 33 0c 	lds	r25, 0x0C33	; 0x800c33 <xTasksWaitingTermination+0x6>
    1a70:	fc 01       	movw	r30, r24
    1a72:	86 81       	ldd	r24, Z+6	; 0x06
    1a74:	97 81       	ldd	r25, Z+7	; 0x07
    1a76:	9b 83       	std	Y+3, r25	; 0x03
    1a78:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a7e:	02 96       	adiw	r24, 0x02	; 2
    1a80:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1a84:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <uxCurrentNumberOfTasks>
    1a88:	81 50       	subi	r24, 0x01	; 1
    1a8a:	80 93 40 0c 	sts	0x0C40, r24	; 0x800c40 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1a8e:	80 91 36 0c 	lds	r24, 0x0C36	; 0x800c36 <uxTasksDeleted>
    1a92:	81 50       	subi	r24, 0x01	; 1
    1a94:	80 93 36 0c 	sts	0x0C36, r24	; 0x800c36 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1a98:	0f 90       	pop	r0
    1a9a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9e:	9b 81       	ldd	r25, Y+3	; 0x03
    1aa0:	98 d0       	rcall	.+304    	; 0x1bd2 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1aa2:	80 91 36 0c 	lds	r24, 0x0C36	; 0x800c36 <uxTasksDeleted>
    1aa6:	88 23       	and	r24, r24
    1aa8:	81 f6       	brne	.-96     	; 0x1a4a <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    1aaa:	0f 90       	pop	r0
    1aac:	0f 90       	pop	r0
    1aae:	0f 90       	pop	r0
    1ab0:	df 91       	pop	r29
    1ab2:	cf 91       	pop	r28
    1ab4:	08 95       	ret

00001ab6 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1ab6:	cf 93       	push	r28
    1ab8:	df 93       	push	r29
    1aba:	1f 92       	push	r1
    1abc:	1f 92       	push	r1
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
    1ac2:	9a 83       	std	Y+2, r25	; 0x02
    1ac4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1ac6:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1aca:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1ace:	29 81       	ldd	r18, Y+1	; 0x01
    1ad0:	3a 81       	ldd	r19, Y+2	; 0x02
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	33 83       	std	Z+3, r19	; 0x03
    1ad6:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1ad8:	80 91 41 0c 	lds	r24, 0x0C41	; 0x800c41 <xTickCount>
    1adc:	90 91 42 0c 	lds	r25, 0x0C42	; 0x800c42 <xTickCount+0x1>
    1ae0:	29 81       	ldd	r18, Y+1	; 0x01
    1ae2:	3a 81       	ldd	r19, Y+2	; 0x02
    1ae4:	28 17       	cp	r18, r24
    1ae6:	39 07       	cpc	r19, r25
    1ae8:	78 f4       	brcc	.+30     	; 0x1b08 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1aea:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1aee:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1af2:	9c 01       	movw	r18, r24
    1af4:	2e 5f       	subi	r18, 0xFE	; 254
    1af6:	3f 4f       	sbci	r19, 0xFF	; 255
    1af8:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <pxOverflowDelayedTaskList>
    1afc:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <pxOverflowDelayedTaskList+0x1>
    1b00:	b9 01       	movw	r22, r18
    1b02:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsert>
    1b06:	1d c0       	rjmp	.+58     	; 0x1b42 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1b08:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    1b0c:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    1b10:	9c 01       	movw	r18, r24
    1b12:	2e 5f       	subi	r18, 0xFE	; 254
    1b14:	3f 4f       	sbci	r19, 0xFF	; 255
    1b16:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    1b1a:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    1b1e:	b9 01       	movw	r22, r18
    1b20:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1b24:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    1b28:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    1b2c:	29 81       	ldd	r18, Y+1	; 0x01
    1b2e:	3a 81       	ldd	r19, Y+2	; 0x02
    1b30:	28 17       	cp	r18, r24
    1b32:	39 07       	cpc	r19, r25
    1b34:	30 f4       	brcc	.+12     	; 0x1b42 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1b36:	89 81       	ldd	r24, Y+1	; 0x01
    1b38:	9a 81       	ldd	r25, Y+2	; 0x02
    1b3a:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    1b3e:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1b42:	0f 90       	pop	r0
    1b44:	0f 90       	pop	r0
    1b46:	df 91       	pop	r29
    1b48:	cf 91       	pop	r28
    1b4a:	08 95       	ret

00001b4c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	cd b7       	in	r28, 0x3d	; 61
    1b52:	de b7       	in	r29, 0x3e	; 62
    1b54:	28 97       	sbiw	r28, 0x08	; 8
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	f8 94       	cli
    1b5a:	de bf       	out	0x3e, r29	; 62
    1b5c:	0f be       	out	0x3f, r0	; 63
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	9e 83       	std	Y+6, r25	; 0x06
    1b62:	8d 83       	std	Y+5, r24	; 0x05
    1b64:	78 87       	std	Y+8, r23	; 0x08
    1b66:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b68:	8f 81       	ldd	r24, Y+7	; 0x07
    1b6a:	98 85       	ldd	r25, Y+8	; 0x08
    1b6c:	89 2b       	or	r24, r25
    1b6e:	29 f4       	brne	.+10     	; 0x1b7a <prvAllocateTCBAndStack+0x2e>
    1b70:	8d 81       	ldd	r24, Y+5	; 0x05
    1b72:	9e 81       	ldd	r25, Y+6	; 0x06
    1b74:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <pvPortMalloc>
    1b78:	02 c0       	rjmp	.+4      	; 0x1b7e <prvAllocateTCBAndStack+0x32>
    1b7a:	8f 81       	ldd	r24, Y+7	; 0x07
    1b7c:	98 85       	ldd	r25, Y+8	; 0x08
    1b7e:	9c 83       	std	Y+4, r25	; 0x04
    1b80:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    1b82:	8b 81       	ldd	r24, Y+3	; 0x03
    1b84:	9c 81       	ldd	r25, Y+4	; 0x04
    1b86:	89 2b       	or	r24, r25
    1b88:	b9 f0       	breq	.+46     	; 0x1bb8 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1b8a:	86 e2       	ldi	r24, 0x26	; 38
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <pvPortMalloc>
    1b92:	9a 83       	std	Y+2, r25	; 0x02
    1b94:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    1b96:	89 81       	ldd	r24, Y+1	; 0x01
    1b98:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9a:	89 2b       	or	r24, r25
    1b9c:	41 f0       	breq	.+16     	; 0x1bae <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1b9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba2:	2b 81       	ldd	r18, Y+3	; 0x03
    1ba4:	3c 81       	ldd	r19, Y+4	; 0x04
    1ba6:	fc 01       	movw	r30, r24
    1ba8:	30 8f       	std	Z+24, r19	; 0x18
    1baa:	27 8b       	std	Z+23, r18	; 0x17
    1bac:	07 c0       	rjmp	.+14     	; 0x1bbc <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vPortFree>
    1bb6:	02 c0       	rjmp	.+4      	; 0x1bbc <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    1bb8:	1a 82       	std	Y+2, r1	; 0x02
    1bba:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1bc0:	28 96       	adiw	r28, 0x08	; 8
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	08 95       	ret

00001bd2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1bd2:	cf 93       	push	r28
    1bd4:	df 93       	push	r29
    1bd6:	1f 92       	push	r1
    1bd8:	1f 92       	push	r1
    1bda:	cd b7       	in	r28, 0x3d	; 61
    1bdc:	de b7       	in	r29, 0x3e	; 62
    1bde:	9a 83       	std	Y+2, r25	; 0x02
    1be0:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    1be2:	89 81       	ldd	r24, Y+1	; 0x01
    1be4:	9a 81       	ldd	r25, Y+2	; 0x02
    1be6:	fc 01       	movw	r30, r24
    1be8:	87 89       	ldd	r24, Z+23	; 0x17
    1bea:	90 8d       	ldd	r25, Z+24	; 0x18
    1bec:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    1bf0:	89 81       	ldd	r24, Y+1	; 0x01
    1bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf4:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vPortFree>
	}
    1bf8:	0f 90       	pop	r0
    1bfa:	0f 90       	pop	r0
    1bfc:	df 91       	pop	r29
    1bfe:	cf 91       	pop	r28
    1c00:	08 95       	ret

00001c02 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1c02:	cf 93       	push	r28
    1c04:	df 93       	push	r29
    1c06:	1f 92       	push	r1
    1c08:	1f 92       	push	r1
    1c0a:	cd b7       	in	r28, 0x3d	; 61
    1c0c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1c0e:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    1c12:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    1c16:	fc 01       	movw	r30, r24
    1c18:	80 81       	ld	r24, Z
    1c1a:	88 23       	and	r24, r24
    1c1c:	39 f4       	brne	.+14     	; 0x1c2c <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1c1e:	8f ef       	ldi	r24, 0xFF	; 255
    1c20:	9f ef       	ldi	r25, 0xFF	; 255
    1c22:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    1c26:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    1c2a:	15 c0       	rjmp	.+42     	; 0x1c56 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1c2c:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <pxDelayedTaskList>
    1c30:	90 91 21 0c 	lds	r25, 0x0C21	; 0x800c21 <pxDelayedTaskList+0x1>
    1c34:	fc 01       	movw	r30, r24
    1c36:	85 81       	ldd	r24, Z+5	; 0x05
    1c38:	96 81       	ldd	r25, Z+6	; 0x06
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	86 81       	ldd	r24, Z+6	; 0x06
    1c3e:	97 81       	ldd	r25, Z+7	; 0x07
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	9a 81       	ldd	r25, Y+2	; 0x02
    1c48:	fc 01       	movw	r30, r24
    1c4a:	82 81       	ldd	r24, Z+2	; 0x02
    1c4c:	93 81       	ldd	r25, Z+3	; 0x03
    1c4e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
    1c52:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
	}
}
    1c56:	0f 90       	pop	r0
    1c58:	0f 90       	pop	r0
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	08 95       	ret

00001c60 <vTask1>:
SemaphoreHandle_t xSemaphore;
QueueHandle_t xQueue1;
TaskHandle_t x1Handle;
TaskHandle_t x2Handle;

void vTask1(void *pvParameters) {
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	1f 92       	push	r1
    1c66:	1f 92       	push	r1
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	9a 83       	std	Y+2, r25	; 0x02
    1c6e:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	
	while (1) {
		PORTB = 0xfd;
    1c70:	85 e2       	ldi	r24, 0x25	; 37
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	2d ef       	ldi	r18, 0xFD	; 253
    1c76:	fc 01       	movw	r30, r24
    1c78:	20 83       	st	Z, r18
		vTaskSuspend(x1Handle);		
    1c7a:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <x1Handle>
    1c7e:	90 91 51 0c 	lds	r25, 0x0C51	; 0x800c51 <x1Handle+0x1>
    1c82:	74 da       	rcall	.-2840   	; 0x116c <vTaskSuspend>
	}
    1c84:	f5 cf       	rjmp	.-22     	; 0x1c70 <vTask1+0x10>

00001c86 <vTask2>:
	vTaskDelete(NULL);
}

void vTask2(void *pvParameters) {
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	1f 92       	push	r1
    1c8c:	1f 92       	push	r1
    1c8e:	cd b7       	in	r28, 0x3d	; 61
    1c90:	de b7       	in	r29, 0x3e	; 62
    1c92:	9a 83       	std	Y+2, r25	; 0x02
    1c94:	89 83       	std	Y+1, r24	; 0x01
	// Remove compiler warnings.
	(void) pvParameters;
	//vTaskDelay(1000);
	while (1) {
		PORTB = 0xff;
    1c96:	85 e2       	ldi	r24, 0x25	; 37
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	2f ef       	ldi	r18, 0xFF	; 255
    1c9c:	fc 01       	movw	r30, r24
    1c9e:	20 83       	st	Z, r18
		vTaskResume(x2Handle);
    1ca0:	80 91 52 0c 	lds	r24, 0x0C52	; 0x800c52 <x2Handle>
    1ca4:	90 91 53 0c 	lds	r25, 0x0C53	; 0x800c53 <x2Handle+0x1>
    1ca8:	ee da       	rcall	.-2596   	; 0x1286 <vTaskResume>
		//vTaskDelay(2000);
	}
    1caa:	f5 cf       	rjmp	.-22     	; 0x1c96 <vTask2+0x10>

00001cac <vTask3>:
	vTaskDelete(NULL);
}

void vTask3(void *pvParameters)
{
    1cac:	af 92       	push	r10
    1cae:	bf 92       	push	r11
    1cb0:	cf 92       	push	r12
    1cb2:	df 92       	push	r13
    1cb4:	ef 92       	push	r14
    1cb6:	ff 92       	push	r15
    1cb8:	0f 93       	push	r16
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	1f 92       	push	r1
    1cc0:	1f 92       	push	r1
    1cc2:	cd b7       	in	r28, 0x3d	; 61
    1cc4:	de b7       	in	r29, 0x3e	; 62
    1cc6:	9a 83       	std	Y+2, r25	; 0x02
    1cc8:	89 83       	std	Y+1, r24	; 0x01
	vTaskDelay(200);
    1cca:	88 ec       	ldi	r24, 0xC8	; 200
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	1e da       	rcall	.-3012   	; 0x110c <vTaskDelay>
	xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL,
    1cd0:	a1 2c       	mov	r10, r1
    1cd2:	b1 2c       	mov	r11, r1
    1cd4:	c1 2c       	mov	r12, r1
    1cd6:	d1 2c       	mov	r13, r1
    1cd8:	e1 2c       	mov	r14, r1
    1cda:	f1 2c       	mov	r15, r1
    1cdc:	05 e0       	ldi	r16, 0x05	; 5
    1cde:	20 e0       	ldi	r18, 0x00	; 0
    1ce0:	30 e0       	ldi	r19, 0x00	; 0
    1ce2:	49 eb       	ldi	r20, 0xB9	; 185
    1ce4:	50 e0       	ldi	r21, 0x00	; 0
    1ce6:	67 e0       	ldi	r22, 0x07	; 7
    1ce8:	72 e0       	ldi	r23, 0x02	; 2
    1cea:	80 e3       	ldi	r24, 0x30	; 48
    1cec:	9e e0       	ldi	r25, 0x0E	; 14
    1cee:	2e d9       	rcall	.-3492   	; 0xf4c <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);
	vTaskDelay(100);
    1cf0:	84 e6       	ldi	r24, 0x64	; 100
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	0b da       	rcall	.-3050   	; 0x110c <vTaskDelay>
	vTaskResume(x1Handle);
    1cf6:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <x1Handle>
    1cfa:	90 91 51 0c 	lds	r25, 0x0C51	; 0x800c51 <x1Handle+0x1>
    1cfe:	c3 da       	rcall	.-2682   	; 0x1286 <vTaskResume>
	vTaskDelay(200);
    1d00:	88 ec       	ldi	r24, 0xC8	; 200
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	03 da       	rcall	.-3066   	; 0x110c <vTaskDelay>
	xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL,
    1d06:	a1 2c       	mov	r10, r1
    1d08:	b1 2c       	mov	r11, r1
    1d0a:	c1 2c       	mov	r12, r1
    1d0c:	d1 2c       	mov	r13, r1
    1d0e:	e1 2c       	mov	r14, r1
    1d10:	f1 2c       	mov	r15, r1
    1d12:	05 e0       	ldi	r16, 0x05	; 5
    1d14:	20 e0       	ldi	r18, 0x00	; 0
    1d16:	30 e0       	ldi	r19, 0x00	; 0
    1d18:	49 eb       	ldi	r20, 0xB9	; 185
    1d1a:	50 e0       	ldi	r21, 0x00	; 0
    1d1c:	6e e0       	ldi	r22, 0x0E	; 14
    1d1e:	72 e0       	ldi	r23, 0x02	; 2
    1d20:	83 e4       	ldi	r24, 0x43	; 67
    1d22:	9e e0       	ldi	r25, 0x0E	; 14
    1d24:	13 d9       	rcall	.-3546   	; 0xf4c <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);
	vTaskDelay(100);
    1d26:	84 e6       	ldi	r24, 0x64	; 100
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	f0 d9       	rcall	.-3104   	; 0x110c <vTaskDelay>
	vTaskResume(x2Handle);
    1d2c:	80 91 52 0c 	lds	r24, 0x0C52	; 0x800c52 <x2Handle>
    1d30:	90 91 53 0c 	lds	r25, 0x0C53	; 0x800c53 <x2Handle+0x1>
    1d34:	a8 da       	rcall	.-2736   	; 0x1286 <vTaskResume>
}
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	0f 91       	pop	r16
    1d40:	ff 90       	pop	r15
    1d42:	ef 90       	pop	r14
    1d44:	df 90       	pop	r13
    1d46:	cf 90       	pop	r12
    1d48:	bf 90       	pop	r11
    1d4a:	af 90       	pop	r10
    1d4c:	08 95       	ret

00001d4e <main>:

int main( void )
{
    1d4e:	af 92       	push	r10
    1d50:	bf 92       	push	r11
    1d52:	cf 92       	push	r12
    1d54:	df 92       	push	r13
    1d56:	ef 92       	push	r14
    1d58:	ff 92       	push	r15
    1d5a:	0f 93       	push	r16
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
	DDRB = 0xff;
    1d64:	84 e2       	ldi	r24, 0x24	; 36
    1d66:	90 e0       	ldi	r25, 0x00	; 0
    1d68:	2f ef       	ldi	r18, 0xFF	; 255
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	20 83       	st	Z, r18
	PORTB = 0xfd;
    1d6e:	85 e2       	ldi	r24, 0x25	; 37
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	2d ef       	ldi	r18, 0xFD	; 253
    1d74:	fc 01       	movw	r30, r24
    1d76:	20 83       	st	Z, r18
	
	xTaskCreate(vTask3, "Task 3", configMINIMAL_STACK_SIZE, NULL,
    1d78:	a1 2c       	mov	r10, r1
    1d7a:	b1 2c       	mov	r11, r1
    1d7c:	c1 2c       	mov	r12, r1
    1d7e:	d1 2c       	mov	r13, r1
    1d80:	e1 2c       	mov	r14, r1
    1d82:	f1 2c       	mov	r15, r1
    1d84:	05 e0       	ldi	r16, 0x05	; 5
    1d86:	20 e0       	ldi	r18, 0x00	; 0
    1d88:	30 e0       	ldi	r19, 0x00	; 0
    1d8a:	49 eb       	ldi	r20, 0xB9	; 185
    1d8c:	50 e0       	ldi	r21, 0x00	; 0
    1d8e:	65 e1       	ldi	r22, 0x15	; 21
    1d90:	72 e0       	ldi	r23, 0x02	; 2
    1d92:	86 e5       	ldi	r24, 0x56	; 86
    1d94:	9e e0       	ldi	r25, 0x0E	; 14
    1d96:	da d8       	rcall	.-3660   	; 0xf4c <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);
	xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL,
	task2_TASK_PRIORITY, NULL);
	*/
	
	vTaskStartScheduler();
    1d98:	da da       	rcall	.-2636   	; 0x134e <vTaskStartScheduler>

	return 0;
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
}
    1d9e:	df 91       	pop	r29
    1da0:	cf 91       	pop	r28
    1da2:	0f 91       	pop	r16
    1da4:	ff 90       	pop	r15
    1da6:	ef 90       	pop	r14
    1da8:	df 90       	pop	r13
    1daa:	cf 90       	pop	r12
    1dac:	bf 90       	pop	r11
    1dae:	af 90       	pop	r10
    1db0:	08 95       	ret

00001db2 <vApplicationIdleHook>:


/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
    1db2:	cf 93       	push	r28
    1db4:	df 93       	push	r29
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
	//vCoRoutineSchedule();
}
    1dba:	df 91       	pop	r29
    1dbc:	cf 91       	pop	r28
    1dbe:	08 95       	ret

00001dc0 <__vector_default>:

ISR(BADISR_vect)
{
    1dc0:	1f 92       	push	r1
    1dc2:	0f 92       	push	r0
    1dc4:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1dc8:	0f 92       	push	r0
    1dca:	11 24       	eor	r1, r1
    1dcc:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1dd0:	0f 92       	push	r0
    1dd2:	2f 93       	push	r18
    1dd4:	3f 93       	push	r19
    1dd6:	8f 93       	push	r24
    1dd8:	9f 93       	push	r25
    1dda:	ef 93       	push	r30
    1ddc:	ff 93       	push	r31
    1dde:	cf 93       	push	r28
    1de0:	df 93       	push	r29
    1de2:	cd b7       	in	r28, 0x3d	; 61
    1de4:	de b7       	in	r29, 0x3e	; 62
	PORTA &= ~_BV(PA1);
    1de6:	82 e2       	ldi	r24, 0x22	; 34
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	22 e2       	ldi	r18, 0x22	; 34
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	f9 01       	movw	r30, r18
    1df0:	20 81       	ld	r18, Z
    1df2:	2d 7f       	andi	r18, 0xFD	; 253
    1df4:	fc 01       	movw	r30, r24
    1df6:	20 83       	st	Z, r18
}
    1df8:	df 91       	pop	r29
    1dfa:	cf 91       	pop	r28
    1dfc:	ff 91       	pop	r31
    1dfe:	ef 91       	pop	r30
    1e00:	9f 91       	pop	r25
    1e02:	8f 91       	pop	r24
    1e04:	3f 91       	pop	r19
    1e06:	2f 91       	pop	r18
    1e08:	0f 90       	pop	r0
    1e0a:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1e0e:	0f 90       	pop	r0
    1e10:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1e14:	0f 90       	pop	r0
    1e16:	1f 90       	pop	r1
    1e18:	18 95       	reti

00001e1a <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    1e1a:	cf 93       	push	r28
    1e1c:	df 93       	push	r29
    1e1e:	00 d0       	rcall	.+0      	; 0x1e20 <vApplicationStackOverflowHook+0x6>
    1e20:	1f 92       	push	r1
    1e22:	cd b7       	in	r28, 0x3d	; 61
    1e24:	de b7       	in	r29, 0x3e	; 62
    1e26:	9a 83       	std	Y+2, r25	; 0x02
    1e28:	89 83       	std	Y+1, r24	; 0x01
    1e2a:	7c 83       	std	Y+4, r23	; 0x04
    1e2c:	6b 83       	std	Y+3, r22	; 0x03
	PORTA |= _BV(PA7);
    1e2e:	82 e2       	ldi	r24, 0x22	; 34
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	22 e2       	ldi	r18, 0x22	; 34
    1e34:	30 e0       	ldi	r19, 0x00	; 0
    1e36:	f9 01       	movw	r30, r18
    1e38:	20 81       	ld	r18, Z
    1e3a:	20 68       	ori	r18, 0x80	; 128
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	20 83       	st	Z, r18
    1e40:	0f 90       	pop	r0
    1e42:	0f 90       	pop	r0
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	df 91       	pop	r29
    1e4a:	cf 91       	pop	r28
    1e4c:	08 95       	ret

00001e4e <__vector_25>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
ISR(USART0_RX_vect)
{
    1e4e:	1f 92       	push	r1
    1e50:	0f 92       	push	r0
    1e52:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1e56:	0f 92       	push	r0
    1e58:	11 24       	eor	r1, r1
    1e5a:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1e5e:	0f 92       	push	r0
    1e60:	2f 93       	push	r18
    1e62:	3f 93       	push	r19
    1e64:	4f 93       	push	r20
    1e66:	5f 93       	push	r21
    1e68:	6f 93       	push	r22
    1e6a:	7f 93       	push	r23
    1e6c:	8f 93       	push	r24
    1e6e:	9f 93       	push	r25
    1e70:	af 93       	push	r26
    1e72:	bf 93       	push	r27
    1e74:	ef 93       	push	r30
    1e76:	ff 93       	push	r31
    1e78:	cf 93       	push	r28
    1e7a:	df 93       	push	r29
    1e7c:	1f 92       	push	r1
    1e7e:	1f 92       	push	r1
    1e80:	cd b7       	in	r28, 0x3d	; 61
    1e82:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    1e84:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    1e86:	86 ec       	ldi	r24, 0xC6	; 198
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	fc 01       	movw	r30, r24
    1e8c:	80 81       	ld	r24, Z
    1e8e:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    1e90:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <xRxedChars>
    1e94:	90 91 4b 0c 	lds	r25, 0x0C4B	; 0x800c4b <xRxedChars+0x1>
    1e98:	ae 01       	movw	r20, r28
    1e9a:	4e 5f       	subi	r20, 0xFE	; 254
    1e9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e9e:	20 e0       	ldi	r18, 0x00	; 0
    1ea0:	be 01       	movw	r22, r28
    1ea2:	6f 5f       	subi	r22, 0xFF	; 255
    1ea4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea6:	0e 94 da 05 	call	0xbb4	; 0xbb4 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    1eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    1eac:	88 23       	and	r24, r24
    1eae:	11 f0       	breq	.+4      	; 0x1eb4 <__vector_25+0x66>
	{
		taskYIELD();
    1eb0:	0e 94 06 04 	call	0x80c	; 0x80c <vPortYield>
	}
}
    1eb4:	0f 90       	pop	r0
    1eb6:	0f 90       	pop	r0
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	ff 91       	pop	r31
    1ebe:	ef 91       	pop	r30
    1ec0:	bf 91       	pop	r27
    1ec2:	af 91       	pop	r26
    1ec4:	9f 91       	pop	r25
    1ec6:	8f 91       	pop	r24
    1ec8:	7f 91       	pop	r23
    1eca:	6f 91       	pop	r22
    1ecc:	5f 91       	pop	r21
    1ece:	4f 91       	pop	r20
    1ed0:	3f 91       	pop	r19
    1ed2:	2f 91       	pop	r18
    1ed4:	0f 90       	pop	r0
    1ed6:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1eda:	0f 90       	pop	r0
    1edc:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1ee0:	0f 90       	pop	r0
    1ee2:	1f 90       	pop	r1
    1ee4:	18 95       	reti

00001ee6 <__vector_26>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
ISR(USART0_UDRE_vect)
{
    1ee6:	1f 92       	push	r1
    1ee8:	0f 92       	push	r0
    1eea:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1eee:	0f 92       	push	r0
    1ef0:	11 24       	eor	r1, r1
    1ef2:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1ef6:	0f 92       	push	r0
    1ef8:	2f 93       	push	r18
    1efa:	3f 93       	push	r19
    1efc:	4f 93       	push	r20
    1efe:	5f 93       	push	r21
    1f00:	6f 93       	push	r22
    1f02:	7f 93       	push	r23
    1f04:	8f 93       	push	r24
    1f06:	9f 93       	push	r25
    1f08:	af 93       	push	r26
    1f0a:	bf 93       	push	r27
    1f0c:	ef 93       	push	r30
    1f0e:	ff 93       	push	r31
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	00 d0       	rcall	.+0      	; 0x1f16 <__vector_26+0x30>
    1f16:	cd b7       	in	r28, 0x3d	; 61
    1f18:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    1f1a:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <xCharsForTx>
    1f1e:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <xCharsForTx+0x1>
    1f22:	ae 01       	movw	r20, r28
    1f24:	4d 5f       	subi	r20, 0xFD	; 253
    1f26:	5f 4f       	sbci	r21, 0xFF	; 255
    1f28:	9e 01       	movw	r18, r28
    1f2a:	2e 5f       	subi	r18, 0xFE	; 254
    1f2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2e:	b9 01       	movw	r22, r18
    1f30:	0e 94 38 06 	call	0xc70	; 0xc70 <xQueueReceiveFromISR>
    1f34:	81 30       	cpi	r24, 0x01	; 1
    1f36:	31 f4       	brne	.+12     	; 0x1f44 <__vector_26+0x5e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    1f38:	86 ec       	ldi	r24, 0xC6	; 198
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	2a 81       	ldd	r18, Y+2	; 0x02
    1f3e:	fc 01       	movw	r30, r24
    1f40:	20 83       	st	Z, r18
    1f42:	0d c0       	rjmp	.+26     	; 0x1f5e <__vector_26+0x78>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    1f44:	81 ec       	ldi	r24, 0xC1	; 193
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	fc 01       	movw	r30, r24
    1f4a:	80 81       	ld	r24, Z
    1f4c:	89 83       	std	Y+1, r24	; 0x01
    1f4e:	89 81       	ldd	r24, Y+1	; 0x01
    1f50:	8f 7d       	andi	r24, 0xDF	; 223
    1f52:	89 83       	std	Y+1, r24	; 0x01
    1f54:	81 ec       	ldi	r24, 0xC1	; 193
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	29 81       	ldd	r18, Y+1	; 0x01
    1f5a:	fc 01       	movw	r30, r24
    1f5c:	20 83       	st	Z, r18
	}
}
    1f5e:	0f 90       	pop	r0
    1f60:	0f 90       	pop	r0
    1f62:	0f 90       	pop	r0
    1f64:	df 91       	pop	r29
    1f66:	cf 91       	pop	r28
    1f68:	ff 91       	pop	r31
    1f6a:	ef 91       	pop	r30
    1f6c:	bf 91       	pop	r27
    1f6e:	af 91       	pop	r26
    1f70:	9f 91       	pop	r25
    1f72:	8f 91       	pop	r24
    1f74:	7f 91       	pop	r23
    1f76:	6f 91       	pop	r22
    1f78:	5f 91       	pop	r21
    1f7a:	4f 91       	pop	r20
    1f7c:	3f 91       	pop	r19
    1f7e:	2f 91       	pop	r18
    1f80:	0f 90       	pop	r0
    1f82:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
    1f86:	0f 90       	pop	r0
    1f88:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x70005f>
    1f8c:	0f 90       	pop	r0
    1f8e:	1f 90       	pop	r1
    1f90:	18 95       	reti

00001f92 <__udivmodsi4>:
    1f92:	a1 e2       	ldi	r26, 0x21	; 33
    1f94:	1a 2e       	mov	r1, r26
    1f96:	aa 1b       	sub	r26, r26
    1f98:	bb 1b       	sub	r27, r27
    1f9a:	fd 01       	movw	r30, r26
    1f9c:	0d c0       	rjmp	.+26     	; 0x1fb8 <__udivmodsi4_ep>

00001f9e <__udivmodsi4_loop>:
    1f9e:	aa 1f       	adc	r26, r26
    1fa0:	bb 1f       	adc	r27, r27
    1fa2:	ee 1f       	adc	r30, r30
    1fa4:	ff 1f       	adc	r31, r31
    1fa6:	a2 17       	cp	r26, r18
    1fa8:	b3 07       	cpc	r27, r19
    1faa:	e4 07       	cpc	r30, r20
    1fac:	f5 07       	cpc	r31, r21
    1fae:	20 f0       	brcs	.+8      	; 0x1fb8 <__udivmodsi4_ep>
    1fb0:	a2 1b       	sub	r26, r18
    1fb2:	b3 0b       	sbc	r27, r19
    1fb4:	e4 0b       	sbc	r30, r20
    1fb6:	f5 0b       	sbc	r31, r21

00001fb8 <__udivmodsi4_ep>:
    1fb8:	66 1f       	adc	r22, r22
    1fba:	77 1f       	adc	r23, r23
    1fbc:	88 1f       	adc	r24, r24
    1fbe:	99 1f       	adc	r25, r25
    1fc0:	1a 94       	dec	r1
    1fc2:	69 f7       	brne	.-38     	; 0x1f9e <__udivmodsi4_loop>
    1fc4:	60 95       	com	r22
    1fc6:	70 95       	com	r23
    1fc8:	80 95       	com	r24
    1fca:	90 95       	com	r25
    1fcc:	9b 01       	movw	r18, r22
    1fce:	ac 01       	movw	r20, r24
    1fd0:	bd 01       	movw	r22, r26
    1fd2:	cf 01       	movw	r24, r30
    1fd4:	08 95       	ret

00001fd6 <memcpy>:
    1fd6:	fb 01       	movw	r30, r22
    1fd8:	dc 01       	movw	r26, r24
    1fda:	02 c0       	rjmp	.+4      	; 0x1fe0 <memcpy+0xa>
    1fdc:	01 90       	ld	r0, Z+
    1fde:	0d 92       	st	X+, r0
    1fe0:	41 50       	subi	r20, 0x01	; 1
    1fe2:	50 40       	sbci	r21, 0x00	; 0
    1fe4:	d8 f7       	brcc	.-10     	; 0x1fdc <memcpy+0x6>
    1fe6:	08 95       	ret

00001fe8 <_exit>:
    1fe8:	f8 94       	cli

00001fea <__stop_program>:
    1fea:	ff cf       	rjmp	.-2      	; 0x1fea <__stop_program>
