
FreeRTOS-Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800100  00001b5a  00001bee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000028c  00800148  00800148  00001c36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001c36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000428  00000000  00000000  00001ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004dbf  00000000  00000000  000020d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010c8  00000000  00000000  00006e8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002b59  00000000  00000000  00007f57  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000da4  00000000  00000000  0000aab0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000017b2  00000000  00000000  0000b854  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004fb2  00000000  00000000  0000d006  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004a0  00000000  00000000  00011fb8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 fb 03 	jmp	0x7f6	; 0x7f6 <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 f1 04 	jmp	0x9e2	; 0x9e2 <__vector_20>
      54:	0c 94 2f 05 	jmp	0xa5e	; 0xa5e <__vector_21>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 77 05 	jmp	0xaee	; 0xaee <__vector_28>
      74:	0c 94 b5 05 	jmp	0xb6a	; 0xb6a <__vector_29>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ea e5       	ldi	r30, 0x5A	; 90
      90:	fb e1       	ldi	r31, 0x1B	; 27
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a8 34       	cpi	r26, 0x48	; 72
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	23 e0       	ldi	r18, 0x03	; 3
      a0:	a8 e4       	ldi	r26, 0x48	; 72
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a4 3d       	cpi	r26, 0xD4	; 212
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <main>
      b2:	0c 94 ab 0d 	jmp	0x1b56	; 0x1b56 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <handle_display>:
	}
	
}

void game_task(void *pvParameters)
{
      ba:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <__data_end>
      be:	81 11       	cpse	r24, r1
      c0:	01 c0       	rjmp	.+2      	; 0xc4 <handle_display+0xa>
      c2:	5a 9a       	sbi	0x0b, 2	; 11
      c4:	5d 9a       	sbi	0x0b, 5	; 11
      c6:	5d 98       	cbi	0x0b, 5	; 11
      c8:	5c 9a       	sbi	0x0b, 4	; 11
      ca:	5c 98       	cbi	0x0b, 4	; 11
      cc:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <__data_end>
      d0:	f0 e0       	ldi	r31, 0x00	; 0
      d2:	ee 0f       	add	r30, r30
      d4:	ff 1f       	adc	r31, r31
      d6:	ea 5f       	subi	r30, 0xFA	; 250
      d8:	fe 4f       	sbci	r31, 0xFE	; 254
      da:	80 81       	ld	r24, Z
      dc:	80 95       	com	r24
      de:	82 b9       	out	0x02, r24	; 2
      e0:	85 b1       	in	r24, 0x05	; 5
      e2:	83 60       	ori	r24, 0x03	; 3
      e4:	85 b9       	out	0x05, r24	; 5
      e6:	95 b1       	in	r25, 0x05	; 5
      e8:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <__data_end>
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	ee 0f       	add	r30, r30
      f0:	ff 1f       	adc	r31, r31
      f2:	ea 5f       	subi	r30, 0xFA	; 250
      f4:	fe 4f       	sbci	r31, 0xFE	; 254
      f6:	81 81       	ldd	r24, Z+1	; 0x01
      f8:	83 70       	andi	r24, 0x03	; 3
      fa:	80 95       	com	r24
      fc:	89 23       	and	r24, r25
      fe:	85 b9       	out	0x05, r24	; 5
     100:	5a 98       	cbi	0x0b, 2	; 11
     102:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <__data_end>
     106:	8f 5f       	subi	r24, 0xFF	; 255
     108:	8e 30       	cpi	r24, 0x0E	; 14
     10a:	18 f4       	brcc	.+6      	; 0x112 <handle_display+0x58>
     10c:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <__data_end>
     110:	08 95       	ret
     112:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__data_end>
     116:	08 95       	ret

00000118 <startup_task>:
     118:	61 e0       	ldi	r22, 0x01	; 1
     11a:	70 e0       	ldi	r23, 0x00	; 0
     11c:	80 e0       	ldi	r24, 0x00	; 0
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	0e 94 2d 0b 	call	0x165a	; 0x165a <vTaskSetApplicationTaskTag>
     124:	6f e0       	ldi	r22, 0x0F	; 15
     126:	86 e2       	ldi	r24, 0x26	; 38
     128:	91 e0       	ldi	r25, 0x01	; 1
     12a:	0e 94 7e 01 	call	0x2fc	; 0x2fc <com_send_bytes>
     12e:	61 e0       	ldi	r22, 0x01	; 1
     130:	8f ef       	ldi	r24, 0xFF	; 255
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	0e 94 7e 01 	call	0x2fc	; 0x2fc <com_send_bytes>
     138:	ff cf       	rjmp	.-2      	; 0x138 <startup_task+0x20>

0000013a <echo_task>:
     13a:	cf 93       	push	r28
     13c:	df 93       	push	r29
     13e:	1f 92       	push	r1
     140:	cd b7       	in	r28, 0x3d	; 61
     142:	de b7       	in	r29, 0x3e	; 62
     144:	06 e0       	ldi	r16, 0x06	; 6
     146:	11 e0       	ldi	r17, 0x01	; 1
     148:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <_x_com_received_chars_queue>
     14c:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <_x_com_received_chars_queue+0x1>
     150:	00 97       	sbiw	r24, 0x00	; 0
     152:	f1 f3       	breq	.-4      	; 0x150 <echo_task+0x16>
     154:	20 e0       	ldi	r18, 0x00	; 0
     156:	4a e0       	ldi	r20, 0x0A	; 10
     158:	50 e0       	ldi	r21, 0x00	; 0
     15a:	be 01       	movw	r22, r28
     15c:	6f 5f       	subi	r22, 0xFF	; 255
     15e:	7f 4f       	sbci	r23, 0xFF	; 255
     160:	0e 94 57 07 	call	0xeae	; 0xeae <xQueueGenericReceive>
     164:	89 81       	ldd	r24, Y+1	; 0x01
     166:	81 36       	cpi	r24, 0x61	; 97
     168:	79 f7       	brne	.-34     	; 0x148 <echo_task+0xe>
     16a:	20 e0       	ldi	r18, 0x00	; 0
     16c:	4a e0       	ldi	r20, 0x0A	; 10
     16e:	50 e0       	ldi	r21, 0x00	; 0
     170:	be 01       	movw	r22, r28
     172:	6f 5f       	subi	r22, 0xFF	; 255
     174:	7f 4f       	sbci	r23, 0xFF	; 255
     176:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <_x_com_received_chars_queue>
     17a:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <_x_com_received_chars_queue+0x1>
     17e:	0e 94 57 07 	call	0xeae	; 0xeae <xQueueGenericReceive>
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	81 36       	cpi	r24, 0x61	; 97
     186:	01 f3       	breq	.-64     	; 0x148 <echo_task+0xe>
     188:	81 34       	cpi	r24, 0x41	; 65
     18a:	61 f4       	brne	.+24     	; 0x1a4 <echo_task+0x6a>
     18c:	20 e0       	ldi	r18, 0x00	; 0
     18e:	4a e0       	ldi	r20, 0x0A	; 10
     190:	50 e0       	ldi	r21, 0x00	; 0
     192:	be 01       	movw	r22, r28
     194:	6f 5f       	subi	r22, 0xFF	; 255
     196:	7f 4f       	sbci	r23, 0xFF	; 255
     198:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <_x_com_received_chars_queue>
     19c:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <_x_com_received_chars_queue+0x1>
     1a0:	0e 94 57 07 	call	0xeae	; 0xeae <xQueueGenericReceive>
     1a4:	61 e0       	ldi	r22, 0x01	; 1
     1a6:	ce 01       	movw	r24, r28
     1a8:	01 96       	adiw	r24, 0x01	; 1
     1aa:	0e 94 7e 01 	call	0x2fc	; 0x2fc <com_send_bytes>
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	82 36       	cpi	r24, 0x62	; 98
     1b2:	39 f4       	brne	.+14     	; 0x1c2 <echo_task+0x88>
     1b4:	f8 01       	movw	r30, r16
     1b6:	80 81       	ld	r24, Z
     1b8:	91 81       	ldd	r25, Z+1	; 0x01
     1ba:	96 95       	lsr	r25
     1bc:	87 95       	ror	r24
     1be:	91 83       	std	Z+1, r25	; 0x01
     1c0:	80 83       	st	Z, r24
     1c2:	20 e0       	ldi	r18, 0x00	; 0
     1c4:	4a e0       	ldi	r20, 0x0A	; 10
     1c6:	50 e0       	ldi	r21, 0x00	; 0
     1c8:	be 01       	movw	r22, r28
     1ca:	6f 5f       	subi	r22, 0xFF	; 255
     1cc:	7f 4f       	sbci	r23, 0xFF	; 255
     1ce:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <_x_com_received_chars_queue>
     1d2:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <_x_com_received_chars_queue+0x1>
     1d6:	0e 94 57 07 	call	0xeae	; 0xeae <xQueueGenericReceive>
     1da:	89 81       	ldd	r24, Y+1	; 0x01
     1dc:	81 36       	cpi	r24, 0x61	; 97
     1de:	a1 f6       	brne	.-88     	; 0x188 <echo_task+0x4e>
     1e0:	b3 cf       	rjmp	.-154    	; 0x148 <echo_task+0xe>

000001e2 <vApplicationIdleHook>:

}

//-----------------------------------------
void vApplicationIdleHook( void )
{
     1e2:	08 95       	ret

000001e4 <main>:

//-----------------------------------------
int main(void)
{
	
	init_board();
     1e4:	0e 94 87 01 	call	0x30e	; 0x30e <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     1e8:	5e 98       	cbi	0x0b, 6	; 11

	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
     1ea:	40 e0       	ldi	r20, 0x00	; 0
     1ec:	61 e0       	ldi	r22, 0x01	; 1
     1ee:	8e e1       	ldi	r24, 0x1E	; 30
     1f0:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xQueueGenericCreate>
     1f4:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <_x_com_received_chars_queue+0x1>
     1f8:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <_x_com_received_chars_queue>
	init_com(_x_com_received_chars_queue);
     1fc:	0e 94 3e 01 	call	0x27c	; 0x27c <init_com>

	
	
	//Create task to blink gpio
	xTaskCreate(startup_task, (const char *)"Startup", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     200:	e1 2c       	mov	r14, r1
     202:	f1 2c       	mov	r15, r1
     204:	00 e0       	ldi	r16, 0x00	; 0
     206:	20 e0       	ldi	r18, 0x00	; 0
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	45 e5       	ldi	r20, 0x55	; 85
     20c:	50 e0       	ldi	r21, 0x00	; 0
     20e:	66 e3       	ldi	r22, 0x36	; 54
     210:	71 e0       	ldi	r23, 0x01	; 1
     212:	8c e8       	ldi	r24, 0x8C	; 140
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskCreate>
	xTaskCreate(echo_task,(const char *)"echo", configMINIMAL_STACK_SIZE, (void *)NULL, task1_prio, NULL);
     21a:	04 e0       	ldi	r16, 0x04	; 4
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	45 e5       	ldi	r20, 0x55	; 85
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	6e e3       	ldi	r22, 0x3E	; 62
     226:	71 e0       	ldi	r23, 0x01	; 1
     228:	8d e9       	ldi	r24, 0x9D	; 157
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskCreate>
	//xTaskCreate(game_task,(const char *)"game", configMINIMAL_STACK_SIZE, (void *)NULL, task2_prio, NULL);
	
	// Start the display handler timer
	init_display_timer(handle_display);
     230:	8d e5       	ldi	r24, 0x5D	; 93
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	0e 94 43 01 	call	0x286	; 0x286 <init_display_timer>
	
	//Start the scheduler
	vTaskStartScheduler();
     238:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskStartScheduler>
	
	//Should never reach here
	while (1)
	{
	}
     23c:	ff cf       	rjmp	.-2      	; 0x23c <main+0x58>

0000023e <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     23e:	cf 93       	push	r28
     240:	df 93       	push	r29
     242:	00 d0       	rcall	.+0      	; 0x244 <_com_call_back+0x6>
     244:	cd b7       	in	r28, 0x3d	; 61
     246:	de b7       	in	r29, 0x3e	; 62
     248:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     24a:	80 91 73 01 	lds	r24, 0x0173	; 0x800173 <_x_rx_com_queue>
     24e:	90 91 74 01 	lds	r25, 0x0174	; 0x800174 <_x_rx_com_queue+0x1>
     252:	00 97       	sbiw	r24, 0x00	; 0
     254:	71 f0       	breq	.+28     	; 0x272 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     256:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     258:	20 e0       	ldi	r18, 0x00	; 0
     25a:	ae 01       	movw	r20, r28
     25c:	4f 5f       	subi	r20, 0xFF	; 255
     25e:	5f 4f       	sbci	r21, 0xFF	; 255
     260:	be 01       	movw	r22, r28
     262:	6e 5f       	subi	r22, 0xFE	; 254
     264:	7f 4f       	sbci	r23, 0xFF	; 255
     266:	0e 94 1d 07 	call	0xe3a	; 0xe3a <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     26a:	89 81       	ldd	r24, Y+1	; 0x01
     26c:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     26e:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
		}
	}
}
     272:	0f 90       	pop	r0
     274:	0f 90       	pop	r0
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	08 95       	ret

0000027c <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     27c:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <_x_rx_com_queue+0x1>
     280:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <_x_rx_com_queue>
     284:	08 95       	ret

00000286 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     286:	90 93 72 01 	sts	0x0172, r25	; 0x800172 <cb_ptr+0x1>
     28a:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     28e:	8a e0       	ldi	r24, 0x0A	; 10
     290:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     292:	84 b5       	in	r24, 0x24	; 36
     294:	82 60       	ori	r24, 0x02	; 2
     296:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     298:	ee e6       	ldi	r30, 0x6E	; 110
     29a:	f0 e0       	ldi	r31, 0x00	; 0
     29c:	80 81       	ld	r24, Z
     29e:	82 60       	ori	r24, 0x02	; 2
     2a0:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     2a2:	85 b5       	in	r24, 0x25	; 37
     2a4:	85 60       	ori	r24, 0x05	; 5
     2a6:	85 bd       	out	0x25, r24	; 37
     2a8:	08 95       	ret

000002aa <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     2aa:	1f 92       	push	r1
     2ac:	0f 92       	push	r0
     2ae:	0f b6       	in	r0, 0x3f	; 63
     2b0:	0f 92       	push	r0
     2b2:	11 24       	eor	r1, r1
     2b4:	2f 93       	push	r18
     2b6:	3f 93       	push	r19
     2b8:	4f 93       	push	r20
     2ba:	5f 93       	push	r21
     2bc:	6f 93       	push	r22
     2be:	7f 93       	push	r23
     2c0:	8f 93       	push	r24
     2c2:	9f 93       	push	r25
     2c4:	af 93       	push	r26
     2c6:	bf 93       	push	r27
     2c8:	ef 93       	push	r30
     2ca:	ff 93       	push	r31
	if (cb_ptr)
     2cc:	e0 91 71 01 	lds	r30, 0x0171	; 0x800171 <cb_ptr>
     2d0:	f0 91 72 01 	lds	r31, 0x0172	; 0x800172 <cb_ptr+0x1>
     2d4:	30 97       	sbiw	r30, 0x00	; 0
     2d6:	09 f0       	breq	.+2      	; 0x2da <__vector_16+0x30>
	{
		cb_ptr();
     2d8:	09 95       	icall
	}
}
     2da:	ff 91       	pop	r31
     2dc:	ef 91       	pop	r30
     2de:	bf 91       	pop	r27
     2e0:	af 91       	pop	r26
     2e2:	9f 91       	pop	r25
     2e4:	8f 91       	pop	r24
     2e6:	7f 91       	pop	r23
     2e8:	6f 91       	pop	r22
     2ea:	5f 91       	pop	r21
     2ec:	4f 91       	pop	r20
     2ee:	3f 91       	pop	r19
     2f0:	2f 91       	pop	r18
     2f2:	0f 90       	pop	r0
     2f4:	0f be       	out	0x3f, r0	; 63
     2f6:	0f 90       	pop	r0
     2f8:	1f 90       	pop	r1
     2fa:	18 95       	reti

000002fc <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     2fc:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     2fe:	bc 01       	movw	r22, r24
     300:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <_com_serial_instance>
     304:	90 91 76 01 	lds	r25, 0x0176	; 0x800176 <_com_serial_instance+0x1>
     308:	0e 94 ae 04 	call	0x95c	; 0x95c <serial_send_bytes>
     30c:	08 95       	ret

0000030e <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     30e:	8f 92       	push	r8
     310:	9f 92       	push	r9
     312:	af 92       	push	r10
     314:	bf 92       	push	r11
     316:	cf 92       	push	r12
     318:	df 92       	push	r13
     31a:	ef 92       	push	r14
     31c:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     31e:	8e e5       	ldi	r24, 0x5E	; 94
     320:	91 e0       	ldi	r25, 0x01	; 1
     322:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <buffer_init>
	buffer_init(&_com_tx_buffer);
     326:	8b e4       	ldi	r24, 0x4B	; 75
     328:	91 e0       	ldi	r25, 0x01	; 1
     32a:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     32e:	0f 2e       	mov	r0, r31
     330:	ff e1       	ldi	r31, 0x1F	; 31
     332:	8f 2e       	mov	r8, r31
     334:	f1 e0       	ldi	r31, 0x01	; 1
     336:	9f 2e       	mov	r9, r31
     338:	f0 2d       	mov	r31, r0
     33a:	0f 2e       	mov	r0, r31
     33c:	fb e4       	ldi	r31, 0x4B	; 75
     33e:	af 2e       	mov	r10, r31
     340:	f1 e0       	ldi	r31, 0x01	; 1
     342:	bf 2e       	mov	r11, r31
     344:	f0 2d       	mov	r31, r0
     346:	0f 2e       	mov	r0, r31
     348:	fe e5       	ldi	r31, 0x5E	; 94
     34a:	cf 2e       	mov	r12, r31
     34c:	f1 e0       	ldi	r31, 0x01	; 1
     34e:	df 2e       	mov	r13, r31
     350:	f0 2d       	mov	r31, r0
     352:	e1 2c       	mov	r14, r1
     354:	00 e0       	ldi	r16, 0x00	; 0
     356:	23 e0       	ldi	r18, 0x03	; 3
     358:	40 e0       	ldi	r20, 0x00	; 0
     35a:	52 ec       	ldi	r21, 0xC2	; 194
     35c:	61 e0       	ldi	r22, 0x01	; 1
     35e:	70 e0       	ldi	r23, 0x00	; 0
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	0e 94 34 04 	call	0x868	; 0x868 <serial_new_instance>
     366:	90 93 76 01 	sts	0x0176, r25	; 0x800176 <_com_serial_instance+0x1>
     36a:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     36e:	88 b1       	in	r24, 0x08	; 8
     370:	83 6c       	ori	r24, 0xC3	; 195
     372:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     374:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     376:	8a b1       	in	r24, 0x0a	; 10
     378:	84 67       	ori	r24, 0x74	; 116
     37a:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     37c:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     37e:	81 b1       	in	r24, 0x01	; 1
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     384:	84 b1       	in	r24, 0x04	; 4
     386:	83 60       	ori	r24, 0x03	; 3
     388:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     38a:	84 b1       	in	r24, 0x04	; 4
     38c:	8c 63       	ori	r24, 0x3C	; 60
     38e:	84 b9       	out	0x04, r24	; 4
}
     390:	0f 91       	pop	r16
     392:	ef 90       	pop	r14
     394:	df 90       	pop	r13
     396:	cf 90       	pop	r12
     398:	bf 90       	pop	r11
     39a:	af 90       	pop	r10
     39c:	9f 90       	pop	r9
     39e:	8f 90       	pop	r8
     3a0:	08 95       	ret

000003a2 <switch_in>:
	 @brief Set PORTB bit 2-5, to the task switched into running by the operating system.
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
     3a2:	08 95       	ret

000003a4 <switch_out>:
	 @brief Set PORTB bit 2-5, to zero when a task is switched out of running by the operating system.
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
     3a4:	08 95       	ret

000003a6 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     3a6:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     3a8:	10 8a       	std	Z+16, r1	; 0x10
	buffer->out_i = 0;
     3aa:	11 8a       	std	Z+17, r1	; 0x11
	buffer->no_in_buffer = 0;
     3ac:	12 8a       	std	Z+18, r1	; 0x12
     3ae:	08 95       	ret

000003b0 <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     3b0:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     3b2:	82 89       	ldd	r24, Z+18	; 0x12
     3b4:	88 23       	and	r24, r24
     3b6:	d9 f0       	breq	.+54     	; 0x3ee <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     3b8:	81 89       	ldd	r24, Z+17	; 0x11
     3ba:	df 01       	movw	r26, r30
     3bc:	a8 0f       	add	r26, r24
     3be:	b1 1d       	adc	r27, r1
     3c0:	8c 91       	ld	r24, X
     3c2:	db 01       	movw	r26, r22
     3c4:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     3c6:	21 89       	ldd	r18, Z+17	; 0x11
     3c8:	30 e0       	ldi	r19, 0x00	; 0
     3ca:	2f 5f       	subi	r18, 0xFF	; 255
     3cc:	3f 4f       	sbci	r19, 0xFF	; 255
     3ce:	2f 70       	andi	r18, 0x0F	; 15
     3d0:	30 78       	andi	r19, 0x80	; 128
     3d2:	33 23       	and	r19, r19
     3d4:	34 f4       	brge	.+12     	; 0x3e2 <buffer_get_item+0x32>
     3d6:	21 50       	subi	r18, 0x01	; 1
     3d8:	31 09       	sbc	r19, r1
     3da:	20 6f       	ori	r18, 0xF0	; 240
     3dc:	3f 6f       	ori	r19, 0xFF	; 255
     3de:	2f 5f       	subi	r18, 0xFF	; 255
     3e0:	3f 4f       	sbci	r19, 0xFF	; 255
     3e2:	21 8b       	std	Z+17, r18	; 0x11
		buffer->no_in_buffer--;
     3e4:	82 89       	ldd	r24, Z+18	; 0x12
     3e6:	81 50       	subi	r24, 0x01	; 1
     3e8:	82 8b       	std	Z+18, r24	; 0x12
		return BUFFER_OK;
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	08 95       	ret
	}
	return BUFFER_EMPTY;
     3ee:	81 e0       	ldi	r24, 0x01	; 1
}
     3f0:	08 95       	ret

000003f2 <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     3f2:	fc 01       	movw	r30, r24
     3f4:	42 89       	ldd	r20, Z+18	; 0x12
     3f6:	40 31       	cpi	r20, 0x10	; 16
     3f8:	b8 f4       	brcc	.+46     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
		buffer->storage[buffer->in_i] = item;
     3fa:	20 89       	ldd	r18, Z+16	; 0x10
     3fc:	30 e0       	ldi	r19, 0x00	; 0
     3fe:	e2 0f       	add	r30, r18
     400:	f3 1f       	adc	r31, r19
     402:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     404:	2f 5f       	subi	r18, 0xFF	; 255
     406:	3f 4f       	sbci	r19, 0xFF	; 255
     408:	2f 70       	andi	r18, 0x0F	; 15
     40a:	30 78       	andi	r19, 0x80	; 128
     40c:	33 23       	and	r19, r19
     40e:	34 f4       	brge	.+12     	; 0x41c <__FUSE_REGION_LENGTH__+0x1c>
     410:	21 50       	subi	r18, 0x01	; 1
     412:	31 09       	sbc	r19, r1
     414:	20 6f       	ori	r18, 0xF0	; 240
     416:	3f 6f       	ori	r19, 0xFF	; 255
     418:	2f 5f       	subi	r18, 0xFF	; 255
     41a:	3f 4f       	sbci	r19, 0xFF	; 255
     41c:	fc 01       	movw	r30, r24
     41e:	20 8b       	std	Z+16, r18	; 0x10
		buffer->no_in_buffer++;
     420:	4f 5f       	subi	r20, 0xFF	; 255
     422:	42 8b       	std	Z+18, r20	; 0x12
		return BUFFER_OK;
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	08 95       	ret
	}
	return BUFFER_FULL;
     428:	82 e0       	ldi	r24, 0x02	; 2
}
     42a:	08 95       	ret

0000042c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     42c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     42e:	03 96       	adiw	r24, 0x03	; 3
     430:	92 83       	std	Z+2, r25	; 0x02
     432:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     434:	2f ef       	ldi	r18, 0xFF	; 255
     436:	3f ef       	ldi	r19, 0xFF	; 255
     438:	34 83       	std	Z+4, r19	; 0x04
     43a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     43c:	96 83       	std	Z+6, r25	; 0x06
     43e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     440:	90 87       	std	Z+8, r25	; 0x08
     442:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     444:	10 82       	st	Z, r1
     446:	08 95       	ret

00000448 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     448:	fc 01       	movw	r30, r24
     44a:	11 86       	std	Z+9, r1	; 0x09
     44c:	10 86       	std	Z+8, r1	; 0x08
     44e:	08 95       	ret

00000450 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	9c 01       	movw	r18, r24
     456:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     458:	dc 01       	movw	r26, r24
     45a:	11 96       	adiw	r26, 0x01	; 1
     45c:	cd 91       	ld	r28, X+
     45e:	dc 91       	ld	r29, X
     460:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     462:	d3 83       	std	Z+3, r29	; 0x03
     464:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     466:	8c 81       	ldd	r24, Y+4	; 0x04
     468:	9d 81       	ldd	r25, Y+5	; 0x05
     46a:	95 83       	std	Z+5, r25	; 0x05
     46c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     46e:	8c 81       	ldd	r24, Y+4	; 0x04
     470:	9d 81       	ldd	r25, Y+5	; 0x05
     472:	dc 01       	movw	r26, r24
     474:	13 96       	adiw	r26, 0x03	; 3
     476:	7c 93       	st	X, r23
     478:	6e 93       	st	-X, r22
     47a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     47c:	7d 83       	std	Y+5, r23	; 0x05
     47e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     480:	31 87       	std	Z+9, r19	; 0x09
     482:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     484:	f9 01       	movw	r30, r18
     486:	80 81       	ld	r24, Z
     488:	8f 5f       	subi	r24, 0xFF	; 255
     48a:	80 83       	st	Z, r24
}
     48c:	df 91       	pop	r29
     48e:	cf 91       	pop	r28
     490:	08 95       	ret

00000492 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
     496:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     498:	48 81       	ld	r20, Y
     49a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     49c:	4f 3f       	cpi	r20, 0xFF	; 255
     49e:	2f ef       	ldi	r18, 0xFF	; 255
     4a0:	52 07       	cpc	r21, r18
     4a2:	21 f4       	brne	.+8      	; 0x4ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4a4:	fc 01       	movw	r30, r24
     4a6:	a7 81       	ldd	r26, Z+7	; 0x07
     4a8:	b0 85       	ldd	r27, Z+8	; 0x08
     4aa:	0d c0       	rjmp	.+26     	; 0x4c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4ac:	dc 01       	movw	r26, r24
     4ae:	13 96       	adiw	r26, 0x03	; 3
     4b0:	01 c0       	rjmp	.+2      	; 0x4b4 <vListInsert+0x22>
     4b2:	df 01       	movw	r26, r30
     4b4:	12 96       	adiw	r26, 0x02	; 2
     4b6:	ed 91       	ld	r30, X+
     4b8:	fc 91       	ld	r31, X
     4ba:	13 97       	sbiw	r26, 0x03	; 3
     4bc:	20 81       	ld	r18, Z
     4be:	31 81       	ldd	r19, Z+1	; 0x01
     4c0:	42 17       	cp	r20, r18
     4c2:	53 07       	cpc	r21, r19
     4c4:	b0 f7       	brcc	.-20     	; 0x4b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4c6:	12 96       	adiw	r26, 0x02	; 2
     4c8:	ed 91       	ld	r30, X+
     4ca:	fc 91       	ld	r31, X
     4cc:	13 97       	sbiw	r26, 0x03	; 3
     4ce:	fb 83       	std	Y+3, r31	; 0x03
     4d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4d2:	d5 83       	std	Z+5, r29	; 0x05
     4d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4d6:	bd 83       	std	Y+5, r27	; 0x05
     4d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4da:	13 96       	adiw	r26, 0x03	; 3
     4dc:	dc 93       	st	X, r29
     4de:	ce 93       	st	-X, r28
     4e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4e2:	99 87       	std	Y+9, r25	; 0x09
     4e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4e6:	fc 01       	movw	r30, r24
     4e8:	20 81       	ld	r18, Z
     4ea:	2f 5f       	subi	r18, 0xFF	; 255
     4ec:	20 83       	st	Z, r18
}
     4ee:	df 91       	pop	r29
     4f0:	cf 91       	pop	r28
     4f2:	08 95       	ret

000004f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4fa:	a0 85       	ldd	r26, Z+8	; 0x08
     4fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4fe:	c2 81       	ldd	r28, Z+2	; 0x02
     500:	d3 81       	ldd	r29, Z+3	; 0x03
     502:	84 81       	ldd	r24, Z+4	; 0x04
     504:	95 81       	ldd	r25, Z+5	; 0x05
     506:	9d 83       	std	Y+5, r25	; 0x05
     508:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     50a:	c4 81       	ldd	r28, Z+4	; 0x04
     50c:	d5 81       	ldd	r29, Z+5	; 0x05
     50e:	82 81       	ldd	r24, Z+2	; 0x02
     510:	93 81       	ldd	r25, Z+3	; 0x03
     512:	9b 83       	std	Y+3, r25	; 0x03
     514:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     516:	11 96       	adiw	r26, 0x01	; 1
     518:	cd 91       	ld	r28, X+
     51a:	dc 91       	ld	r29, X
     51c:	12 97       	sbiw	r26, 0x02	; 2
     51e:	ce 17       	cp	r28, r30
     520:	df 07       	cpc	r29, r31
     522:	31 f4       	brne	.+12     	; 0x530 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	12 96       	adiw	r26, 0x02	; 2
     52a:	9c 93       	st	X, r25
     52c:	8e 93       	st	-X, r24
     52e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     530:	11 86       	std	Z+9, r1	; 0x09
     532:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     534:	8c 91       	ld	r24, X
     536:	81 50       	subi	r24, 0x01	; 1
     538:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     53a:	df 91       	pop	r29
     53c:	cf 91       	pop	r28
     53e:	08 95       	ret

00000540 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     540:	31 e1       	ldi	r19, 0x11	; 17
     542:	fc 01       	movw	r30, r24
     544:	30 83       	st	Z, r19
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	22 e2       	ldi	r18, 0x22	; 34
     54a:	20 83       	st	Z, r18
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	a3 e3       	ldi	r26, 0x33	; 51
     550:	a0 83       	st	Z, r26
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	60 83       	st	Z, r22
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	70 83       	st	Z, r23
     55a:	31 97       	sbiw	r30, 0x01	; 1
     55c:	10 82       	st	Z, r1
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	60 e8       	ldi	r22, 0x80	; 128
     562:	60 83       	st	Z, r22
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	10 82       	st	Z, r1
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	62 e0       	ldi	r22, 0x02	; 2
     56c:	60 83       	st	Z, r22
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	63 e0       	ldi	r22, 0x03	; 3
     572:	60 83       	st	Z, r22
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	64 e0       	ldi	r22, 0x04	; 4
     578:	60 83       	st	Z, r22
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	65 e0       	ldi	r22, 0x05	; 5
     57e:	60 83       	st	Z, r22
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	66 e0       	ldi	r22, 0x06	; 6
     584:	60 83       	st	Z, r22
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	67 e0       	ldi	r22, 0x07	; 7
     58a:	60 83       	st	Z, r22
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	68 e0       	ldi	r22, 0x08	; 8
     590:	60 83       	st	Z, r22
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	69 e0       	ldi	r22, 0x09	; 9
     596:	60 83       	st	Z, r22
     598:	31 97       	sbiw	r30, 0x01	; 1
     59a:	60 e1       	ldi	r22, 0x10	; 16
     59c:	60 83       	st	Z, r22
     59e:	31 97       	sbiw	r30, 0x01	; 1
     5a0:	30 83       	st	Z, r19
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	32 e1       	ldi	r19, 0x12	; 18
     5a6:	30 83       	st	Z, r19
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	33 e1       	ldi	r19, 0x13	; 19
     5ac:	30 83       	st	Z, r19
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	34 e1       	ldi	r19, 0x14	; 20
     5b2:	30 83       	st	Z, r19
     5b4:	31 97       	sbiw	r30, 0x01	; 1
     5b6:	35 e1       	ldi	r19, 0x15	; 21
     5b8:	30 83       	st	Z, r19
     5ba:	31 97       	sbiw	r30, 0x01	; 1
     5bc:	36 e1       	ldi	r19, 0x16	; 22
     5be:	30 83       	st	Z, r19
     5c0:	31 97       	sbiw	r30, 0x01	; 1
     5c2:	37 e1       	ldi	r19, 0x17	; 23
     5c4:	30 83       	st	Z, r19
     5c6:	31 97       	sbiw	r30, 0x01	; 1
     5c8:	38 e1       	ldi	r19, 0x18	; 24
     5ca:	30 83       	st	Z, r19
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	39 e1       	ldi	r19, 0x19	; 25
     5d0:	30 83       	st	Z, r19
     5d2:	31 97       	sbiw	r30, 0x01	; 1
     5d4:	30 e2       	ldi	r19, 0x20	; 32
     5d6:	30 83       	st	Z, r19
     5d8:	31 97       	sbiw	r30, 0x01	; 1
     5da:	31 e2       	ldi	r19, 0x21	; 33
     5dc:	30 83       	st	Z, r19
     5de:	31 97       	sbiw	r30, 0x01	; 1
     5e0:	20 83       	st	Z, r18
     5e2:	31 97       	sbiw	r30, 0x01	; 1
     5e4:	23 e2       	ldi	r18, 0x23	; 35
     5e6:	20 83       	st	Z, r18
     5e8:	31 97       	sbiw	r30, 0x01	; 1
     5ea:	40 83       	st	Z, r20
     5ec:	31 97       	sbiw	r30, 0x01	; 1
     5ee:	50 83       	st	Z, r21
     5f0:	31 97       	sbiw	r30, 0x01	; 1
     5f2:	26 e2       	ldi	r18, 0x26	; 38
     5f4:	20 83       	st	Z, r18
     5f6:	31 97       	sbiw	r30, 0x01	; 1
     5f8:	27 e2       	ldi	r18, 0x27	; 39
     5fa:	20 83       	st	Z, r18
     5fc:	31 97       	sbiw	r30, 0x01	; 1
     5fe:	28 e2       	ldi	r18, 0x28	; 40
     600:	20 83       	st	Z, r18
     602:	31 97       	sbiw	r30, 0x01	; 1
     604:	29 e2       	ldi	r18, 0x29	; 41
     606:	20 83       	st	Z, r18
     608:	31 97       	sbiw	r30, 0x01	; 1
     60a:	20 e3       	ldi	r18, 0x30	; 48
     60c:	20 83       	st	Z, r18
     60e:	31 97       	sbiw	r30, 0x01	; 1
     610:	21 e3       	ldi	r18, 0x31	; 49
     612:	20 83       	st	Z, r18
     614:	86 97       	sbiw	r24, 0x26	; 38
     616:	08 95       	ret

00000618 <xPortStartScheduler>:
     618:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     61c:	85 ee       	ldi	r24, 0xE5	; 229
     61e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     622:	8b e0       	ldi	r24, 0x0B	; 11
     624:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     628:	ef e6       	ldi	r30, 0x6F	; 111
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	82 60       	ori	r24, 0x02	; 2
     630:	80 83       	st	Z, r24
     632:	a0 91 ce 03 	lds	r26, 0x03CE	; 0x8003ce <pxCurrentTCB>
     636:	b0 91 cf 03 	lds	r27, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
     63a:	cd 91       	ld	r28, X+
     63c:	cd bf       	out	0x3d, r28	; 61
     63e:	dd 91       	ld	r29, X+
     640:	de bf       	out	0x3e, r29	; 62
     642:	ff 91       	pop	r31
     644:	ef 91       	pop	r30
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	bf 91       	pop	r27
     64c:	af 91       	pop	r26
     64e:	9f 91       	pop	r25
     650:	8f 91       	pop	r24
     652:	7f 91       	pop	r23
     654:	6f 91       	pop	r22
     656:	5f 91       	pop	r21
     658:	4f 91       	pop	r20
     65a:	3f 91       	pop	r19
     65c:	2f 91       	pop	r18
     65e:	1f 91       	pop	r17
     660:	0f 91       	pop	r16
     662:	ff 90       	pop	r15
     664:	ef 90       	pop	r14
     666:	df 90       	pop	r13
     668:	cf 90       	pop	r12
     66a:	bf 90       	pop	r11
     66c:	af 90       	pop	r10
     66e:	9f 90       	pop	r9
     670:	8f 90       	pop	r8
     672:	7f 90       	pop	r7
     674:	6f 90       	pop	r6
     676:	5f 90       	pop	r5
     678:	4f 90       	pop	r4
     67a:	3f 90       	pop	r3
     67c:	2f 90       	pop	r2
     67e:	1f 90       	pop	r1
     680:	0f 90       	pop	r0
     682:	0f be       	out	0x3f, r0	; 63
     684:	0f 90       	pop	r0
     686:	08 95       	ret
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	08 95       	ret

0000068c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     68c:	0f 92       	push	r0
     68e:	0f b6       	in	r0, 0x3f	; 63
     690:	f8 94       	cli
     692:	0f 92       	push	r0
     694:	1f 92       	push	r1
     696:	11 24       	eor	r1, r1
     698:	2f 92       	push	r2
     69a:	3f 92       	push	r3
     69c:	4f 92       	push	r4
     69e:	5f 92       	push	r5
     6a0:	6f 92       	push	r6
     6a2:	7f 92       	push	r7
     6a4:	8f 92       	push	r8
     6a6:	9f 92       	push	r9
     6a8:	af 92       	push	r10
     6aa:	bf 92       	push	r11
     6ac:	cf 92       	push	r12
     6ae:	df 92       	push	r13
     6b0:	ef 92       	push	r14
     6b2:	ff 92       	push	r15
     6b4:	0f 93       	push	r16
     6b6:	1f 93       	push	r17
     6b8:	2f 93       	push	r18
     6ba:	3f 93       	push	r19
     6bc:	4f 93       	push	r20
     6be:	5f 93       	push	r21
     6c0:	6f 93       	push	r22
     6c2:	7f 93       	push	r23
     6c4:	8f 93       	push	r24
     6c6:	9f 93       	push	r25
     6c8:	af 93       	push	r26
     6ca:	bf 93       	push	r27
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	ef 93       	push	r30
     6d2:	ff 93       	push	r31
     6d4:	a0 91 ce 03 	lds	r26, 0x03CE	; 0x8003ce <pxCurrentTCB>
     6d8:	b0 91 cf 03 	lds	r27, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
     6dc:	0d b6       	in	r0, 0x3d	; 61
     6de:	0d 92       	st	X+, r0
     6e0:	0e b6       	in	r0, 0x3e	; 62
     6e2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     6e4:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     6e8:	a0 91 ce 03 	lds	r26, 0x03CE	; 0x8003ce <pxCurrentTCB>
     6ec:	b0 91 cf 03 	lds	r27, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
     6f0:	cd 91       	ld	r28, X+
     6f2:	cd bf       	out	0x3d, r28	; 61
     6f4:	dd 91       	ld	r29, X+
     6f6:	de bf       	out	0x3e, r29	; 62
     6f8:	ff 91       	pop	r31
     6fa:	ef 91       	pop	r30
     6fc:	df 91       	pop	r29
     6fe:	cf 91       	pop	r28
     700:	bf 91       	pop	r27
     702:	af 91       	pop	r26
     704:	9f 91       	pop	r25
     706:	8f 91       	pop	r24
     708:	7f 91       	pop	r23
     70a:	6f 91       	pop	r22
     70c:	5f 91       	pop	r21
     70e:	4f 91       	pop	r20
     710:	3f 91       	pop	r19
     712:	2f 91       	pop	r18
     714:	1f 91       	pop	r17
     716:	0f 91       	pop	r16
     718:	ff 90       	pop	r15
     71a:	ef 90       	pop	r14
     71c:	df 90       	pop	r13
     71e:	cf 90       	pop	r12
     720:	bf 90       	pop	r11
     722:	af 90       	pop	r10
     724:	9f 90       	pop	r9
     726:	8f 90       	pop	r8
     728:	7f 90       	pop	r7
     72a:	6f 90       	pop	r6
     72c:	5f 90       	pop	r5
     72e:	4f 90       	pop	r4
     730:	3f 90       	pop	r3
     732:	2f 90       	pop	r2
     734:	1f 90       	pop	r1
     736:	0f 90       	pop	r0
     738:	0f be       	out	0x3f, r0	; 63
     73a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     73c:	08 95       	ret

0000073e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     73e:	0f 92       	push	r0
     740:	0f b6       	in	r0, 0x3f	; 63
     742:	f8 94       	cli
     744:	0f 92       	push	r0
     746:	1f 92       	push	r1
     748:	11 24       	eor	r1, r1
     74a:	2f 92       	push	r2
     74c:	3f 92       	push	r3
     74e:	4f 92       	push	r4
     750:	5f 92       	push	r5
     752:	6f 92       	push	r6
     754:	7f 92       	push	r7
     756:	8f 92       	push	r8
     758:	9f 92       	push	r9
     75a:	af 92       	push	r10
     75c:	bf 92       	push	r11
     75e:	cf 92       	push	r12
     760:	df 92       	push	r13
     762:	ef 92       	push	r14
     764:	ff 92       	push	r15
     766:	0f 93       	push	r16
     768:	1f 93       	push	r17
     76a:	2f 93       	push	r18
     76c:	3f 93       	push	r19
     76e:	4f 93       	push	r20
     770:	5f 93       	push	r21
     772:	6f 93       	push	r22
     774:	7f 93       	push	r23
     776:	8f 93       	push	r24
     778:	9f 93       	push	r25
     77a:	af 93       	push	r26
     77c:	bf 93       	push	r27
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ef 93       	push	r30
     784:	ff 93       	push	r31
     786:	a0 91 ce 03 	lds	r26, 0x03CE	; 0x8003ce <pxCurrentTCB>
     78a:	b0 91 cf 03 	lds	r27, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
     78e:	0d b6       	in	r0, 0x3d	; 61
     790:	0d 92       	st	X+, r0
     792:	0e b6       	in	r0, 0x3e	; 62
     794:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     796:	0e 94 b4 09 	call	0x1368	; 0x1368 <xTaskIncrementTick>
     79a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     79c:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     7a0:	a0 91 ce 03 	lds	r26, 0x03CE	; 0x8003ce <pxCurrentTCB>
     7a4:	b0 91 cf 03 	lds	r27, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
     7a8:	cd 91       	ld	r28, X+
     7aa:	cd bf       	out	0x3d, r28	; 61
     7ac:	dd 91       	ld	r29, X+
     7ae:	de bf       	out	0x3e, r29	; 62
     7b0:	ff 91       	pop	r31
     7b2:	ef 91       	pop	r30
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	bf 91       	pop	r27
     7ba:	af 91       	pop	r26
     7bc:	9f 91       	pop	r25
     7be:	8f 91       	pop	r24
     7c0:	7f 91       	pop	r23
     7c2:	6f 91       	pop	r22
     7c4:	5f 91       	pop	r21
     7c6:	4f 91       	pop	r20
     7c8:	3f 91       	pop	r19
     7ca:	2f 91       	pop	r18
     7cc:	1f 91       	pop	r17
     7ce:	0f 91       	pop	r16
     7d0:	ff 90       	pop	r15
     7d2:	ef 90       	pop	r14
     7d4:	df 90       	pop	r13
     7d6:	cf 90       	pop	r12
     7d8:	bf 90       	pop	r11
     7da:	af 90       	pop	r10
     7dc:	9f 90       	pop	r9
     7de:	8f 90       	pop	r8
     7e0:	7f 90       	pop	r7
     7e2:	6f 90       	pop	r6
     7e4:	5f 90       	pop	r5
     7e6:	4f 90       	pop	r4
     7e8:	3f 90       	pop	r3
     7ea:	2f 90       	pop	r2
     7ec:	1f 90       	pop	r1
     7ee:	0f 90       	pop	r0
     7f0:	0f be       	out	0x3f, r0	; 63
     7f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     7f4:	08 95       	ret

000007f6 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     7f6:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortYieldFromTick>
		asm volatile ( "reti" );
     7fa:	18 95       	reti

000007fc <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     802:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     806:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <pucAlignedHeap.1964>
     80a:	90 91 78 01 	lds	r25, 0x0178	; 0x800178 <pucAlignedHeap.1964+0x1>
     80e:	89 2b       	or	r24, r25
     810:	31 f4       	brne	.+12     	; 0x81e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     812:	8c e7       	ldi	r24, 0x7C	; 124
     814:	91 e0       	ldi	r25, 0x01	; 1
     816:	90 93 78 01 	sts	0x0178, r25	; 0x800178 <pucAlignedHeap.1964+0x1>
     81a:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <pucAlignedHeap.1964>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     81e:	20 91 79 01 	lds	r18, 0x0179	; 0x800179 <xNextFreeByte>
     822:	30 91 7a 01 	lds	r19, 0x017A	; 0x80017a <xNextFreeByte+0x1>
     826:	ce 01       	movw	r24, r28
     828:	82 0f       	add	r24, r18
     82a:	93 1f       	adc	r25, r19
     82c:	83 3f       	cpi	r24, 0xF3	; 243
     82e:	41 e0       	ldi	r20, 0x01	; 1
     830:	94 07       	cpc	r25, r20
     832:	70 f4       	brcc	.+28     	; 0x850 <pvPortMalloc+0x54>
     834:	28 17       	cp	r18, r24
     836:	39 07       	cpc	r19, r25
     838:	70 f4       	brcc	.+28     	; 0x856 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     83a:	c0 91 77 01 	lds	r28, 0x0177	; 0x800177 <pucAlignedHeap.1964>
     83e:	d0 91 78 01 	lds	r29, 0x0178	; 0x800178 <pucAlignedHeap.1964+0x1>
     842:	c2 0f       	add	r28, r18
     844:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     846:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <xNextFreeByte+0x1>
     84a:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <xNextFreeByte>
     84e:	05 c0       	rjmp	.+10     	; 0x85a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     850:	c0 e0       	ldi	r28, 0x00	; 0
     852:	d0 e0       	ldi	r29, 0x00	; 0
     854:	02 c0       	rjmp	.+4      	; 0x85a <pvPortMalloc+0x5e>
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     85a:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     85e:	ce 01       	movw	r24, r28
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	08 95       	ret

00000866 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     866:	08 95       	ret

00000868 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     868:	4f 92       	push	r4
     86a:	5f 92       	push	r5
     86c:	6f 92       	push	r6
     86e:	7f 92       	push	r7
     870:	8f 92       	push	r8
     872:	9f 92       	push	r9
     874:	af 92       	push	r10
     876:	bf 92       	push	r11
     878:	cf 92       	push	r12
     87a:	df 92       	push	r13
     87c:	ff 92       	push	r15
     87e:	0f 93       	push	r16
     880:	1f 93       	push	r17
     882:	cf 93       	push	r28
     884:	df 93       	push	r29
     886:	cd b7       	in	r28, 0x3d	; 61
     888:	de b7       	in	r29, 0x3e	; 62
     88a:	f8 2e       	mov	r15, r24
     88c:	2a 01       	movw	r4, r20
     88e:	3b 01       	movw	r6, r22
     890:	88 e0       	ldi	r24, 0x08	; 8
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <malloc>
     898:	8c 01       	movw	r16, r24
     89a:	8f 2d       	mov	r24, r15
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	88 0f       	add	r24, r24
     8a0:	99 1f       	adc	r25, r25
     8a2:	fc 01       	movw	r30, r24
     8a4:	e1 59       	subi	r30, 0x91	; 145
     8a6:	fc 4f       	sbci	r31, 0xFC	; 252
     8a8:	11 83       	std	Z+1, r17	; 0x01
     8aa:	00 83       	st	Z, r16
     8ac:	fc 01       	movw	r30, r24
     8ae:	ee 5d       	subi	r30, 0xDE	; 222
     8b0:	fe 4f       	sbci	r31, 0xFE	; 254
     8b2:	80 81       	ld	r24, Z
     8b4:	91 81       	ldd	r25, Z+1	; 0x01
     8b6:	d8 01       	movw	r26, r16
     8b8:	11 96       	adiw	r26, 0x01	; 1
     8ba:	9c 93       	st	X, r25
     8bc:	8e 93       	st	-X, r24
     8be:	13 96       	adiw	r26, 0x03	; 3
     8c0:	bc 92       	st	X, r11
     8c2:	ae 92       	st	-X, r10
     8c4:	12 97       	sbiw	r26, 0x02	; 2
     8c6:	15 96       	adiw	r26, 0x05	; 5
     8c8:	dc 92       	st	X, r13
     8ca:	ce 92       	st	-X, r12
     8cc:	14 97       	sbiw	r26, 0x04	; 4
     8ce:	17 96       	adiw	r26, 0x07	; 7
     8d0:	9c 92       	st	X, r9
     8d2:	8e 92       	st	-X, r8
     8d4:	16 97       	sbiw	r26, 0x06	; 6
     8d6:	ff b6       	in	r15, 0x3f	; 63
     8d8:	f8 94       	cli
     8da:	ed 91       	ld	r30, X+
     8dc:	fc 91       	ld	r31, X
     8de:	11 97       	sbiw	r26, 0x01	; 1
     8e0:	36 97       	sbiw	r30, 0x06	; 6
     8e2:	80 81       	ld	r24, Z
     8e4:	82 60       	ori	r24, 0x02	; 2
     8e6:	80 83       	st	Z, r24
     8e8:	cd 90       	ld	r12, X+
     8ea:	dc 90       	ld	r13, X
     8ec:	d3 01       	movw	r26, r6
     8ee:	c2 01       	movw	r24, r4
     8f0:	88 0f       	add	r24, r24
     8f2:	99 1f       	adc	r25, r25
     8f4:	aa 1f       	adc	r26, r26
     8f6:	bb 1f       	adc	r27, r27
     8f8:	88 0f       	add	r24, r24
     8fa:	99 1f       	adc	r25, r25
     8fc:	aa 1f       	adc	r26, r26
     8fe:	bb 1f       	adc	r27, r27
     900:	9c 01       	movw	r18, r24
     902:	ad 01       	movw	r20, r26
     904:	22 0f       	add	r18, r18
     906:	33 1f       	adc	r19, r19
     908:	44 1f       	adc	r20, r20
     90a:	55 1f       	adc	r21, r21
     90c:	60 e0       	ldi	r22, 0x00	; 0
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	81 ee       	ldi	r24, 0xE1	; 225
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	0e 94 4c 0c 	call	0x1898	; 0x1898 <__udivmodsi4>
     918:	21 50       	subi	r18, 0x01	; 1
     91a:	f6 01       	movw	r30, r12
     91c:	32 97       	sbiw	r30, 0x02	; 2
     91e:	20 83       	st	Z, r18
     920:	d8 01       	movw	r26, r16
     922:	ed 91       	ld	r30, X+
     924:	fc 91       	ld	r31, X
     926:	11 97       	sbiw	r26, 0x01	; 1
     928:	35 97       	sbiw	r30, 0x05	; 5
     92a:	88 e9       	ldi	r24, 0x98	; 152
     92c:	80 83       	st	Z, r24
     92e:	ed 91       	ld	r30, X+
     930:	fc 91       	ld	r31, X
     932:	34 97       	sbiw	r30, 0x04	; 4
     934:	86 e0       	ldi	r24, 0x06	; 6
     936:	80 83       	st	Z, r24
     938:	ff be       	out	0x3f, r15	; 63
     93a:	c8 01       	movw	r24, r16
     93c:	df 91       	pop	r29
     93e:	cf 91       	pop	r28
     940:	1f 91       	pop	r17
     942:	0f 91       	pop	r16
     944:	ff 90       	pop	r15
     946:	df 90       	pop	r13
     948:	cf 90       	pop	r12
     94a:	bf 90       	pop	r11
     94c:	af 90       	pop	r10
     94e:	9f 90       	pop	r9
     950:	8f 90       	pop	r8
     952:	7f 90       	pop	r7
     954:	6f 90       	pop	r6
     956:	5f 90       	pop	r5
     958:	4f 90       	pop	r4
     95a:	08 95       	ret

0000095c <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     95c:	ef 92       	push	r14
     95e:	ff 92       	push	r15
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     968:	fc 01       	movw	r30, r24
     96a:	a2 81       	ldd	r26, Z+2	; 0x02
     96c:	b3 81       	ldd	r27, Z+3	; 0x03
     96e:	10 97       	sbiw	r26, 0x00	; 0
     970:	79 f0       	breq	.+30     	; 0x990 <serial_send_bytes+0x34>
     972:	e4 2f       	mov	r30, r20
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	52 96       	adiw	r26, 0x12	; 18
     978:	5c 91       	ld	r21, X
     97a:	20 e1       	ldi	r18, 0x10	; 16
     97c:	30 e0       	ldi	r19, 0x00	; 0
     97e:	25 1b       	sub	r18, r21
     980:	31 09       	sbc	r19, r1
     982:	2e 17       	cp	r18, r30
     984:	3f 07       	cpc	r19, r31
     986:	1c f1       	brlt	.+70     	; 0x9ce <serial_send_bytes+0x72>
     988:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     98a:	41 11       	cpse	r20, r1
     98c:	04 c0       	rjmp	.+8      	; 0x996 <serial_send_bytes+0x3a>
     98e:	16 c0       	rjmp	.+44     	; 0x9bc <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     990:	42 30       	cpi	r20, 0x02	; 2
     992:	f8 f4       	brcc	.+62     	; 0x9d2 <serial_send_bytes+0x76>
     994:	f9 cf       	rjmp	.-14     	; 0x988 <serial_send_bytes+0x2c>
     996:	eb 01       	movw	r28, r22
     998:	41 50       	subi	r20, 0x01	; 1
     99a:	04 2f       	mov	r16, r20
     99c:	10 e0       	ldi	r17, 0x00	; 0
     99e:	0f 5f       	subi	r16, 0xFF	; 255
     9a0:	1f 4f       	sbci	r17, 0xFF	; 255
     9a2:	06 0f       	add	r16, r22
     9a4:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     9a6:	69 91       	ld	r22, Y+
     9a8:	d7 01       	movw	r26, r14
     9aa:	12 96       	adiw	r26, 0x02	; 2
     9ac:	8d 91       	ld	r24, X+
     9ae:	9c 91       	ld	r25, X
     9b0:	13 97       	sbiw	r26, 0x03	; 3
     9b2:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     9b6:	c0 17       	cp	r28, r16
     9b8:	d1 07       	cpc	r29, r17
     9ba:	a9 f7       	brne	.-22     	; 0x9a6 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     9bc:	d7 01       	movw	r26, r14
     9be:	ed 91       	ld	r30, X+
     9c0:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     9c2:	35 97       	sbiw	r30, 0x05	; 5
     9c4:	80 81       	ld	r24, Z
     9c6:	80 62       	ori	r24, 0x20	; 32
     9c8:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	03 c0       	rjmp	.+6      	; 0x9d4 <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     9ce:	82 e0       	ldi	r24, 0x02	; 2
     9d0:	01 c0       	rjmp	.+2      	; 0x9d4 <serial_send_bytes+0x78>
     9d2:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	1f 91       	pop	r17
     9da:	0f 91       	pop	r16
     9dc:	ff 90       	pop	r15
     9de:	ef 90       	pop	r14
     9e0:	08 95       	ret

000009e2 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     9e2:	1f 92       	push	r1
     9e4:	0f 92       	push	r0
     9e6:	0f b6       	in	r0, 0x3f	; 63
     9e8:	0f 92       	push	r0
     9ea:	11 24       	eor	r1, r1
     9ec:	2f 93       	push	r18
     9ee:	3f 93       	push	r19
     9f0:	4f 93       	push	r20
     9f2:	5f 93       	push	r21
     9f4:	6f 93       	push	r22
     9f6:	7f 93       	push	r23
     9f8:	8f 93       	push	r24
     9fa:	9f 93       	push	r25
     9fc:	af 93       	push	r26
     9fe:	bf 93       	push	r27
     a00:	cf 93       	push	r28
     a02:	ef 93       	push	r30
     a04:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     a06:	e0 91 6f 03 	lds	r30, 0x036F	; 0x80036f <_ser_handle>
     a0a:	f0 91 70 03 	lds	r31, 0x0370	; 0x800370 <_ser_handle+0x1>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	a1 f0       	breq	.+40     	; 0xa3a <__vector_20+0x58>
		item = UDR0;
     a12:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     a16:	6c 2f       	mov	r22, r28
     a18:	84 81       	ldd	r24, Z+4	; 0x04
     a1a:	95 81       	ldd	r25, Z+5	; 0x05
     a1c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     a20:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <_ser_handle>
     a24:	90 91 70 03 	lds	r25, 0x0370	; 0x800370 <_ser_handle+0x1>
     a28:	dc 01       	movw	r26, r24
     a2a:	16 96       	adiw	r26, 0x06	; 6
     a2c:	ed 91       	ld	r30, X+
     a2e:	fc 91       	ld	r31, X
     a30:	17 97       	sbiw	r26, 0x07	; 7
     a32:	30 97       	sbiw	r30, 0x00	; 0
     a34:	11 f0       	breq	.+4      	; 0xa3a <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     a36:	6c 2f       	mov	r22, r28
     a38:	09 95       	icall
		}
	}
}
     a3a:	ff 91       	pop	r31
     a3c:	ef 91       	pop	r30
     a3e:	cf 91       	pop	r28
     a40:	bf 91       	pop	r27
     a42:	af 91       	pop	r26
     a44:	9f 91       	pop	r25
     a46:	8f 91       	pop	r24
     a48:	7f 91       	pop	r23
     a4a:	6f 91       	pop	r22
     a4c:	5f 91       	pop	r21
     a4e:	4f 91       	pop	r20
     a50:	3f 91       	pop	r19
     a52:	2f 91       	pop	r18
     a54:	0f 90       	pop	r0
     a56:	0f be       	out	0x3f, r0	; 63
     a58:	0f 90       	pop	r0
     a5a:	1f 90       	pop	r1
     a5c:	18 95       	reti

00000a5e <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     a5e:	1f 92       	push	r1
     a60:	0f 92       	push	r0
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	0f 92       	push	r0
     a66:	11 24       	eor	r1, r1
     a68:	2f 93       	push	r18
     a6a:	3f 93       	push	r19
     a6c:	4f 93       	push	r20
     a6e:	5f 93       	push	r21
     a70:	6f 93       	push	r22
     a72:	7f 93       	push	r23
     a74:	8f 93       	push	r24
     a76:	9f 93       	push	r25
     a78:	af 93       	push	r26
     a7a:	bf 93       	push	r27
     a7c:	ef 93       	push	r30
     a7e:	ff 93       	push	r31
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	1f 92       	push	r1
     a86:	cd b7       	in	r28, 0x3d	; 61
     a88:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     a8a:	e0 91 6f 03 	lds	r30, 0x036F	; 0x80036f <_ser_handle>
     a8e:	f0 91 70 03 	lds	r31, 0x0370	; 0x800370 <_ser_handle+0x1>
     a92:	30 97       	sbiw	r30, 0x00	; 0
     a94:	99 f0       	breq	.+38     	; 0xabc <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     a96:	be 01       	movw	r22, r28
     a98:	6f 5f       	subi	r22, 0xFF	; 255
     a9a:	7f 4f       	sbci	r23, 0xFF	; 255
     a9c:	82 81       	ldd	r24, Z+2	; 0x02
     a9e:	93 81       	ldd	r25, Z+3	; 0x03
     aa0:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <buffer_get_item>
     aa4:	81 11       	cpse	r24, r1
     aa6:	04 c0       	rjmp	.+8      	; 0xab0 <__vector_21+0x52>
			UDR0 = item;
     aa8:	89 81       	ldd	r24, Y+1	; 0x01
     aaa:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     aae:	0b c0       	rjmp	.+22     	; 0xac6 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     ab0:	e1 ec       	ldi	r30, 0xC1	; 193
     ab2:	f0 e0       	ldi	r31, 0x00	; 0
     ab4:	80 81       	ld	r24, Z
     ab6:	8f 7d       	andi	r24, 0xDF	; 223
     ab8:	80 83       	st	Z, r24
     aba:	05 c0       	rjmp	.+10     	; 0xac6 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
     abc:	e1 ec       	ldi	r30, 0xC1	; 193
     abe:	f0 e0       	ldi	r31, 0x00	; 0
     ac0:	80 81       	ld	r24, Z
     ac2:	8f 7d       	andi	r24, 0xDF	; 223
     ac4:	80 83       	st	Z, r24
	}
}
     ac6:	0f 90       	pop	r0
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	ff 91       	pop	r31
     ace:	ef 91       	pop	r30
     ad0:	bf 91       	pop	r27
     ad2:	af 91       	pop	r26
     ad4:	9f 91       	pop	r25
     ad6:	8f 91       	pop	r24
     ad8:	7f 91       	pop	r23
     ada:	6f 91       	pop	r22
     adc:	5f 91       	pop	r21
     ade:	4f 91       	pop	r20
     ae0:	3f 91       	pop	r19
     ae2:	2f 91       	pop	r18
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
     ae8:	0f 90       	pop	r0
     aea:	1f 90       	pop	r1
     aec:	18 95       	reti

00000aee <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
     aee:	1f 92       	push	r1
     af0:	0f 92       	push	r0
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	0f 92       	push	r0
     af6:	11 24       	eor	r1, r1
     af8:	2f 93       	push	r18
     afa:	3f 93       	push	r19
     afc:	4f 93       	push	r20
     afe:	5f 93       	push	r21
     b00:	6f 93       	push	r22
     b02:	7f 93       	push	r23
     b04:	8f 93       	push	r24
     b06:	9f 93       	push	r25
     b08:	af 93       	push	r26
     b0a:	bf 93       	push	r27
     b0c:	cf 93       	push	r28
     b0e:	ef 93       	push	r30
     b10:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     b12:	e0 91 71 03 	lds	r30, 0x0371	; 0x800371 <_ser_handle+0x2>
     b16:	f0 91 72 03 	lds	r31, 0x0372	; 0x800372 <_ser_handle+0x3>
     b1a:	30 97       	sbiw	r30, 0x00	; 0
     b1c:	a1 f0       	breq	.+40     	; 0xb46 <__vector_28+0x58>
		item = UDR1;
     b1e:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
     b22:	6c 2f       	mov	r22, r28
     b24:	84 81       	ldd	r24, Z+4	; 0x04
     b26:	95 81       	ldd	r25, Z+5	; 0x05
     b28:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
     b2c:	80 91 71 03 	lds	r24, 0x0371	; 0x800371 <_ser_handle+0x2>
     b30:	90 91 72 03 	lds	r25, 0x0372	; 0x800372 <_ser_handle+0x3>
     b34:	dc 01       	movw	r26, r24
     b36:	16 96       	adiw	r26, 0x06	; 6
     b38:	ed 91       	ld	r30, X+
     b3a:	fc 91       	ld	r31, X
     b3c:	17 97       	sbiw	r26, 0x07	; 7
     b3e:	30 97       	sbiw	r30, 0x00	; 0
     b40:	11 f0       	breq	.+4      	; 0xb46 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
     b42:	6c 2f       	mov	r22, r28
     b44:	09 95       	icall
		}
	}
}
     b46:	ff 91       	pop	r31
     b48:	ef 91       	pop	r30
     b4a:	cf 91       	pop	r28
     b4c:	bf 91       	pop	r27
     b4e:	af 91       	pop	r26
     b50:	9f 91       	pop	r25
     b52:	8f 91       	pop	r24
     b54:	7f 91       	pop	r23
     b56:	6f 91       	pop	r22
     b58:	5f 91       	pop	r21
     b5a:	4f 91       	pop	r20
     b5c:	3f 91       	pop	r19
     b5e:	2f 91       	pop	r18
     b60:	0f 90       	pop	r0
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	0f 90       	pop	r0
     b66:	1f 90       	pop	r1
     b68:	18 95       	reti

00000b6a <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
     b6a:	1f 92       	push	r1
     b6c:	0f 92       	push	r0
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	0f 92       	push	r0
     b72:	11 24       	eor	r1, r1
     b74:	2f 93       	push	r18
     b76:	3f 93       	push	r19
     b78:	4f 93       	push	r20
     b7a:	5f 93       	push	r21
     b7c:	6f 93       	push	r22
     b7e:	7f 93       	push	r23
     b80:	8f 93       	push	r24
     b82:	9f 93       	push	r25
     b84:	af 93       	push	r26
     b86:	bf 93       	push	r27
     b88:	ef 93       	push	r30
     b8a:	ff 93       	push	r31
     b8c:	cf 93       	push	r28
     b8e:	df 93       	push	r29
     b90:	1f 92       	push	r1
     b92:	cd b7       	in	r28, 0x3d	; 61
     b94:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     b96:	e0 91 71 03 	lds	r30, 0x0371	; 0x800371 <_ser_handle+0x2>
     b9a:	f0 91 72 03 	lds	r31, 0x0372	; 0x800372 <_ser_handle+0x3>
     b9e:	30 97       	sbiw	r30, 0x00	; 0
     ba0:	99 f0       	breq	.+38     	; 0xbc8 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
     ba2:	be 01       	movw	r22, r28
     ba4:	6f 5f       	subi	r22, 0xFF	; 255
     ba6:	7f 4f       	sbci	r23, 0xFF	; 255
     ba8:	82 81       	ldd	r24, Z+2	; 0x02
     baa:	93 81       	ldd	r25, Z+3	; 0x03
     bac:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <buffer_get_item>
     bb0:	81 11       	cpse	r24, r1
     bb2:	04 c0       	rjmp	.+8      	; 0xbbc <__vector_29+0x52>
			UDR1 = item;
     bb4:	89 81       	ldd	r24, Y+1	; 0x01
     bb6:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     bba:	0b c0       	rjmp	.+22     	; 0xbd2 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
     bbc:	e9 ec       	ldi	r30, 0xC9	; 201
     bbe:	f0 e0       	ldi	r31, 0x00	; 0
     bc0:	80 81       	ld	r24, Z
     bc2:	8f 7d       	andi	r24, 0xDF	; 223
     bc4:	80 83       	st	Z, r24
     bc6:	05 c0       	rjmp	.+10     	; 0xbd2 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
     bc8:	e9 ec       	ldi	r30, 0xC9	; 201
     bca:	f0 e0       	ldi	r31, 0x00	; 0
     bcc:	80 81       	ld	r24, Z
     bce:	8f 7d       	andi	r24, 0xDF	; 223
     bd0:	80 83       	st	Z, r24
	}
}
     bd2:	0f 90       	pop	r0
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	ff 91       	pop	r31
     bda:	ef 91       	pop	r30
     bdc:	bf 91       	pop	r27
     bde:	af 91       	pop	r26
     be0:	9f 91       	pop	r25
     be2:	8f 91       	pop	r24
     be4:	7f 91       	pop	r23
     be6:	6f 91       	pop	r22
     be8:	5f 91       	pop	r21
     bea:	4f 91       	pop	r20
     bec:	3f 91       	pop	r19
     bee:	2f 91       	pop	r18
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
     bf4:	0f 90       	pop	r0
     bf6:	1f 90       	pop	r1
     bf8:	18 95       	reti

00000bfa <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	ec 01       	movw	r28, r24
     c04:	04 2f       	mov	r16, r20
     c06:	1a 8d       	ldd	r17, Y+26	; 0x1a
     c08:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c0a:	88 23       	and	r24, r24
     c0c:	c9 f1       	breq	.+114    	; 0xc80 <prvCopyDataToQueue+0x86>
     c0e:	41 11       	cpse	r20, r1
     c10:	17 c0       	rjmp	.+46     	; 0xc40 <prvCopyDataToQueue+0x46>
     c12:	48 2f       	mov	r20, r24
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	8c 81       	ldd	r24, Y+4	; 0x04
     c18:	9d 81       	ldd	r25, Y+5	; 0x05
     c1a:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <memcpy>
     c1e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c20:	8c 81       	ldd	r24, Y+4	; 0x04
     c22:	9d 81       	ldd	r25, Y+5	; 0x05
     c24:	82 0f       	add	r24, r18
     c26:	91 1d       	adc	r25, r1
     c28:	9d 83       	std	Y+5, r25	; 0x05
     c2a:	8c 83       	std	Y+4, r24	; 0x04
     c2c:	2a 81       	ldd	r18, Y+2	; 0x02
     c2e:	3b 81       	ldd	r19, Y+3	; 0x03
     c30:	82 17       	cp	r24, r18
     c32:	93 07       	cpc	r25, r19
     c34:	28 f1       	brcs	.+74     	; 0xc80 <prvCopyDataToQueue+0x86>
     c36:	88 81       	ld	r24, Y
     c38:	99 81       	ldd	r25, Y+1	; 0x01
     c3a:	9d 83       	std	Y+5, r25	; 0x05
     c3c:	8c 83       	std	Y+4, r24	; 0x04
     c3e:	20 c0       	rjmp	.+64     	; 0xc80 <prvCopyDataToQueue+0x86>
     c40:	48 2f       	mov	r20, r24
     c42:	50 e0       	ldi	r21, 0x00	; 0
     c44:	8e 81       	ldd	r24, Y+6	; 0x06
     c46:	9f 81       	ldd	r25, Y+7	; 0x07
     c48:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <memcpy>
     c4c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	91 95       	neg	r25
     c52:	81 95       	neg	r24
     c54:	91 09       	sbc	r25, r1
     c56:	2e 81       	ldd	r18, Y+6	; 0x06
     c58:	3f 81       	ldd	r19, Y+7	; 0x07
     c5a:	28 0f       	add	r18, r24
     c5c:	39 1f       	adc	r19, r25
     c5e:	3f 83       	std	Y+7, r19	; 0x07
     c60:	2e 83       	std	Y+6, r18	; 0x06
     c62:	48 81       	ld	r20, Y
     c64:	59 81       	ldd	r21, Y+1	; 0x01
     c66:	24 17       	cp	r18, r20
     c68:	35 07       	cpc	r19, r21
     c6a:	30 f4       	brcc	.+12     	; 0xc78 <prvCopyDataToQueue+0x7e>
     c6c:	2a 81       	ldd	r18, Y+2	; 0x02
     c6e:	3b 81       	ldd	r19, Y+3	; 0x03
     c70:	82 0f       	add	r24, r18
     c72:	93 1f       	adc	r25, r19
     c74:	9f 83       	std	Y+7, r25	; 0x07
     c76:	8e 83       	std	Y+6, r24	; 0x06
     c78:	02 30       	cpi	r16, 0x02	; 2
     c7a:	11 f4       	brne	.+4      	; 0xc80 <prvCopyDataToQueue+0x86>
     c7c:	11 11       	cpse	r17, r1
     c7e:	11 50       	subi	r17, 0x01	; 1
     c80:	1f 5f       	subi	r17, 0xFF	; 255
     c82:	1a 8f       	std	Y+26, r17	; 0x1a
     c84:	80 e0       	ldi	r24, 0x00	; 0
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	08 95       	ret

00000c90 <prvCopyDataFromQueue>:
     c90:	fc 01       	movw	r30, r24
     c92:	44 8d       	ldd	r20, Z+28	; 0x1c
     c94:	44 23       	and	r20, r20
     c96:	a9 f0       	breq	.+42     	; 0xcc2 <prvCopyDataFromQueue+0x32>
     c98:	50 e0       	ldi	r21, 0x00	; 0
     c9a:	26 81       	ldd	r18, Z+6	; 0x06
     c9c:	37 81       	ldd	r19, Z+7	; 0x07
     c9e:	24 0f       	add	r18, r20
     ca0:	35 1f       	adc	r19, r21
     ca2:	37 83       	std	Z+7, r19	; 0x07
     ca4:	26 83       	std	Z+6, r18	; 0x06
     ca6:	82 81       	ldd	r24, Z+2	; 0x02
     ca8:	93 81       	ldd	r25, Z+3	; 0x03
     caa:	28 17       	cp	r18, r24
     cac:	39 07       	cpc	r19, r25
     cae:	20 f0       	brcs	.+8      	; 0xcb8 <prvCopyDataFromQueue+0x28>
     cb0:	80 81       	ld	r24, Z
     cb2:	91 81       	ldd	r25, Z+1	; 0x01
     cb4:	97 83       	std	Z+7, r25	; 0x07
     cb6:	86 83       	std	Z+6, r24	; 0x06
     cb8:	cb 01       	movw	r24, r22
     cba:	66 81       	ldd	r22, Z+6	; 0x06
     cbc:	77 81       	ldd	r23, Z+7	; 0x07
     cbe:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <memcpy>
     cc2:	08 95       	ret

00000cc4 <prvUnlockQueue>:
     cc4:	ef 92       	push	r14
     cc6:	ff 92       	push	r15
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	cf 93       	push	r28
     cce:	8c 01       	movw	r16, r24
     cd0:	0f b6       	in	r0, 0x3f	; 63
     cd2:	f8 94       	cli
     cd4:	0f 92       	push	r0
     cd6:	fc 01       	movw	r30, r24
     cd8:	c6 8d       	ldd	r28, Z+30	; 0x1e
     cda:	1c 16       	cp	r1, r28
     cdc:	ac f4       	brge	.+42     	; 0xd08 <prvUnlockQueue+0x44>
     cde:	81 89       	ldd	r24, Z+17	; 0x11
     ce0:	81 11       	cpse	r24, r1
     ce2:	06 c0       	rjmp	.+12     	; 0xcf0 <prvUnlockQueue+0x2c>
     ce4:	11 c0       	rjmp	.+34     	; 0xd08 <prvUnlockQueue+0x44>
     ce6:	f8 01       	movw	r30, r16
     ce8:	91 89       	ldd	r25, Z+17	; 0x11
     cea:	91 11       	cpse	r25, r1
     cec:	05 c0       	rjmp	.+10     	; 0xcf8 <prvUnlockQueue+0x34>
     cee:	0c c0       	rjmp	.+24     	; 0xd08 <prvUnlockQueue+0x44>
     cf0:	78 01       	movw	r14, r16
     cf2:	f1 e1       	ldi	r31, 0x11	; 17
     cf4:	ef 0e       	add	r14, r31
     cf6:	f1 1c       	adc	r15, r1
     cf8:	c7 01       	movw	r24, r14
     cfa:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     cfe:	81 11       	cpse	r24, r1
     d00:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskMissedYield>
     d04:	c1 50       	subi	r28, 0x01	; 1
     d06:	79 f7       	brne	.-34     	; 0xce6 <prvUnlockQueue+0x22>
     d08:	8f ef       	ldi	r24, 0xFF	; 255
     d0a:	f8 01       	movw	r30, r16
     d0c:	86 8f       	std	Z+30, r24	; 0x1e
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63
     d12:	0f b6       	in	r0, 0x3f	; 63
     d14:	f8 94       	cli
     d16:	0f 92       	push	r0
     d18:	c5 8d       	ldd	r28, Z+29	; 0x1d
     d1a:	1c 16       	cp	r1, r28
     d1c:	ac f4       	brge	.+42     	; 0xd48 <prvUnlockQueue+0x84>
     d1e:	80 85       	ldd	r24, Z+8	; 0x08
     d20:	81 11       	cpse	r24, r1
     d22:	06 c0       	rjmp	.+12     	; 0xd30 <prvUnlockQueue+0x6c>
     d24:	11 c0       	rjmp	.+34     	; 0xd48 <prvUnlockQueue+0x84>
     d26:	f8 01       	movw	r30, r16
     d28:	90 85       	ldd	r25, Z+8	; 0x08
     d2a:	91 11       	cpse	r25, r1
     d2c:	05 c0       	rjmp	.+10     	; 0xd38 <prvUnlockQueue+0x74>
     d2e:	0c c0       	rjmp	.+24     	; 0xd48 <prvUnlockQueue+0x84>
     d30:	78 01       	movw	r14, r16
     d32:	f8 e0       	ldi	r31, 0x08	; 8
     d34:	ef 0e       	add	r14, r31
     d36:	f1 1c       	adc	r15, r1
     d38:	c7 01       	movw	r24, r14
     d3a:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     d3e:	81 11       	cpse	r24, r1
     d40:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskMissedYield>
     d44:	c1 50       	subi	r28, 0x01	; 1
     d46:	79 f7       	brne	.-34     	; 0xd26 <prvUnlockQueue+0x62>
     d48:	8f ef       	ldi	r24, 0xFF	; 255
     d4a:	f8 01       	movw	r30, r16
     d4c:	85 8f       	std	Z+29, r24	; 0x1d
     d4e:	0f 90       	pop	r0
     d50:	0f be       	out	0x3f, r0	; 63
     d52:	cf 91       	pop	r28
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	ef 90       	pop	r14
     d5c:	08 95       	ret

00000d5e <xQueueGenericReset>:
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	ec 01       	movw	r28, r24
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
     d6a:	48 81       	ld	r20, Y
     d6c:	59 81       	ldd	r21, Y+1	; 0x01
     d6e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d70:	30 e0       	ldi	r19, 0x00	; 0
     d72:	7b 8d       	ldd	r23, Y+27	; 0x1b
     d74:	72 9f       	mul	r23, r18
     d76:	c0 01       	movw	r24, r0
     d78:	73 9f       	mul	r23, r19
     d7a:	90 0d       	add	r25, r0
     d7c:	11 24       	eor	r1, r1
     d7e:	fa 01       	movw	r30, r20
     d80:	e8 0f       	add	r30, r24
     d82:	f9 1f       	adc	r31, r25
     d84:	fb 83       	std	Y+3, r31	; 0x03
     d86:	ea 83       	std	Y+2, r30	; 0x02
     d88:	1a 8e       	std	Y+26, r1	; 0x1a
     d8a:	5d 83       	std	Y+5, r21	; 0x05
     d8c:	4c 83       	std	Y+4, r20	; 0x04
     d8e:	82 1b       	sub	r24, r18
     d90:	93 0b       	sbc	r25, r19
     d92:	84 0f       	add	r24, r20
     d94:	95 1f       	adc	r25, r21
     d96:	9f 83       	std	Y+7, r25	; 0x07
     d98:	8e 83       	std	Y+6, r24	; 0x06
     d9a:	8f ef       	ldi	r24, 0xFF	; 255
     d9c:	8d 8f       	std	Y+29, r24	; 0x1d
     d9e:	8e 8f       	std	Y+30, r24	; 0x1e
     da0:	61 11       	cpse	r22, r1
     da2:	0c c0       	rjmp	.+24     	; 0xdbc <xQueueGenericReset+0x5e>
     da4:	88 85       	ldd	r24, Y+8	; 0x08
     da6:	88 23       	and	r24, r24
     da8:	89 f0       	breq	.+34     	; 0xdcc <xQueueGenericReset+0x6e>
     daa:	ce 01       	movw	r24, r28
     dac:	08 96       	adiw	r24, 0x08	; 8
     dae:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     db2:	88 23       	and	r24, r24
     db4:	59 f0       	breq	.+22     	; 0xdcc <xQueueGenericReset+0x6e>
     db6:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
     dba:	08 c0       	rjmp	.+16     	; 0xdcc <xQueueGenericReset+0x6e>
     dbc:	ce 01       	movw	r24, r28
     dbe:	08 96       	adiw	r24, 0x08	; 8
     dc0:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
     dc4:	ce 01       	movw	r24, r28
     dc6:	41 96       	adiw	r24, 0x11	; 17
     dc8:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
     dcc:	0f 90       	pop	r0
     dce:	0f be       	out	0x3f, r0	; 63
     dd0:	81 e0       	ldi	r24, 0x01	; 1
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	08 95       	ret

00000dd8 <xQueueGenericCreate>:
     dd8:	ff 92       	push	r15
     dda:	0f 93       	push	r16
     ddc:	1f 93       	push	r17
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	08 2f       	mov	r16, r24
     de4:	16 2f       	mov	r17, r22
     de6:	f4 2e       	mov	r15, r20
     de8:	66 23       	and	r22, r22
     dea:	c9 f0       	breq	.+50     	; 0xe1e <xQueueGenericCreate+0x46>
     dec:	86 9f       	mul	r24, r22
     dee:	c0 01       	movw	r24, r0
     df0:	11 24       	eor	r1, r1
     df2:	81 96       	adiw	r24, 0x21	; 33
     df4:	0e 94 fe 03 	call	0x7fc	; 0x7fc <pvPortMalloc>
     df8:	ec 01       	movw	r28, r24
     dfa:	00 97       	sbiw	r24, 0x00	; 0
     dfc:	49 f4       	brne	.+18     	; 0xe10 <xQueueGenericCreate+0x38>
     dfe:	16 c0       	rjmp	.+44     	; 0xe2c <xQueueGenericCreate+0x54>
     e00:	0b 8f       	std	Y+27, r16	; 0x1b
     e02:	1c 8f       	std	Y+28, r17	; 0x1c
     e04:	61 e0       	ldi	r22, 0x01	; 1
     e06:	ce 01       	movw	r24, r28
     e08:	0e 94 af 06 	call	0xd5e	; 0xd5e <xQueueGenericReset>
     e0c:	f8 a2       	std	Y+32, r15	; 0x20
     e0e:	0e c0       	rjmp	.+28     	; 0xe2c <xQueueGenericCreate+0x54>
     e10:	81 96       	adiw	r24, 0x21	; 33
     e12:	99 83       	std	Y+1, r25	; 0x01
     e14:	88 83       	st	Y, r24
     e16:	f4 cf       	rjmp	.-24     	; 0xe00 <xQueueGenericCreate+0x28>
     e18:	d9 83       	std	Y+1, r29	; 0x01
     e1a:	c8 83       	st	Y, r28
     e1c:	f1 cf       	rjmp	.-30     	; 0xe00 <xQueueGenericCreate+0x28>
     e1e:	81 e2       	ldi	r24, 0x21	; 33
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	0e 94 fe 03 	call	0x7fc	; 0x7fc <pvPortMalloc>
     e26:	ec 01       	movw	r28, r24
     e28:	89 2b       	or	r24, r25
     e2a:	b1 f7       	brne	.-20     	; 0xe18 <xQueueGenericCreate+0x40>
     e2c:	ce 01       	movw	r24, r28
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
     e32:	1f 91       	pop	r17
     e34:	0f 91       	pop	r16
     e36:	ff 90       	pop	r15
     e38:	08 95       	ret

00000e3a <xQueueGenericSendFromISR>:
     e3a:	ef 92       	push	r14
     e3c:	ff 92       	push	r15
     e3e:	0f 93       	push	r16
     e40:	1f 93       	push	r17
     e42:	cf 93       	push	r28
     e44:	df 93       	push	r29
     e46:	8a 01       	movw	r16, r20
     e48:	fc 01       	movw	r30, r24
     e4a:	52 8d       	ldd	r21, Z+26	; 0x1a
     e4c:	33 8d       	ldd	r19, Z+27	; 0x1b
     e4e:	53 17       	cp	r21, r19
     e50:	10 f0       	brcs	.+4      	; 0xe56 <xQueueGenericSendFromISR+0x1c>
     e52:	22 30       	cpi	r18, 0x02	; 2
     e54:	f1 f4       	brne	.+60     	; 0xe92 <xQueueGenericSendFromISR+0x58>
     e56:	42 2f       	mov	r20, r18
     e58:	78 01       	movw	r14, r16
     e5a:	ec 01       	movw	r28, r24
     e5c:	1e 8d       	ldd	r17, Y+30	; 0x1e
     e5e:	0e 94 fd 05 	call	0xbfa	; 0xbfa <prvCopyDataToQueue>
     e62:	1f 3f       	cpi	r17, 0xFF	; 255
     e64:	81 f4       	brne	.+32     	; 0xe86 <xQueueGenericSendFromISR+0x4c>
     e66:	89 89       	ldd	r24, Y+17	; 0x11
     e68:	88 23       	and	r24, r24
     e6a:	a9 f0       	breq	.+42     	; 0xe96 <xQueueGenericSendFromISR+0x5c>
     e6c:	ce 01       	movw	r24, r28
     e6e:	41 96       	adiw	r24, 0x11	; 17
     e70:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     e74:	88 23       	and	r24, r24
     e76:	89 f0       	breq	.+34     	; 0xe9a <xQueueGenericSendFromISR+0x60>
     e78:	e1 14       	cp	r14, r1
     e7a:	f1 04       	cpc	r15, r1
     e7c:	81 f0       	breq	.+32     	; 0xe9e <xQueueGenericSendFromISR+0x64>
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	f7 01       	movw	r30, r14
     e82:	80 83       	st	Z, r24
     e84:	0d c0       	rjmp	.+26     	; 0xea0 <xQueueGenericSendFromISR+0x66>
     e86:	ff 24       	eor	r15, r15
     e88:	f3 94       	inc	r15
     e8a:	f1 0e       	add	r15, r17
     e8c:	fe 8e       	std	Y+30, r15	; 0x1e
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	07 c0       	rjmp	.+14     	; 0xea0 <xQueueGenericSendFromISR+0x66>
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	05 c0       	rjmp	.+10     	; 0xea0 <xQueueGenericSendFromISR+0x66>
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	03 c0       	rjmp	.+6      	; 0xea0 <xQueueGenericSendFromISR+0x66>
     e9a:	81 e0       	ldi	r24, 0x01	; 1
     e9c:	01 c0       	rjmp	.+2      	; 0xea0 <xQueueGenericSendFromISR+0x66>
     e9e:	81 e0       	ldi	r24, 0x01	; 1
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	08 95       	ret

00000eae <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     eae:	8f 92       	push	r8
     eb0:	9f 92       	push	r9
     eb2:	af 92       	push	r10
     eb4:	bf 92       	push	r11
     eb6:	cf 92       	push	r12
     eb8:	df 92       	push	r13
     eba:	ef 92       	push	r14
     ebc:	ff 92       	push	r15
     ebe:	0f 93       	push	r16
     ec0:	1f 93       	push	r17
     ec2:	cf 93       	push	r28
     ec4:	df 93       	push	r29
     ec6:	00 d0       	rcall	.+0      	; 0xec8 <xQueueGenericReceive+0x1a>
     ec8:	00 d0       	rcall	.+0      	; 0xeca <xQueueGenericReceive+0x1c>
     eca:	1f 92       	push	r1
     ecc:	cd b7       	in	r28, 0x3d	; 61
     ece:	de b7       	in	r29, 0x3e	; 62
     ed0:	8c 01       	movw	r16, r24
     ed2:	5b 01       	movw	r10, r22
     ed4:	5d 83       	std	Y+5, r21	; 0x05
     ed6:	4c 83       	std	Y+4, r20	; 0x04
     ed8:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     eda:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     edc:	99 24       	eor	r9, r9
     ede:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ee0:	6c 01       	movw	r12, r24
     ee2:	81 e1       	ldi	r24, 0x11	; 17
     ee4:	c8 0e       	add	r12, r24
     ee6:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ee8:	0f b6       	in	r0, 0x3f	; 63
     eea:	f8 94       	cli
     eec:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     eee:	f8 01       	movw	r30, r16
     ef0:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ef2:	ff 20       	and	r15, r15
     ef4:	41 f1       	breq	.+80     	; 0xf46 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ef6:	c6 80       	ldd	r12, Z+6	; 0x06
     ef8:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     efa:	b5 01       	movw	r22, r10
     efc:	c8 01       	movw	r24, r16
     efe:	0e 94 48 06 	call	0xc90	; 0xc90 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     f02:	81 10       	cpse	r8, r1
     f04:	0f c0       	rjmp	.+30     	; 0xf24 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     f06:	fa 94       	dec	r15
     f08:	f8 01       	movw	r30, r16
     f0a:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f0c:	80 85       	ldd	r24, Z+8	; 0x08
     f0e:	88 23       	and	r24, r24
     f10:	b1 f0       	breq	.+44     	; 0xf3e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f12:	c8 01       	movw	r24, r16
     f14:	08 96       	adiw	r24, 0x08	; 8
     f16:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     f1a:	88 23       	and	r24, r24
     f1c:	81 f0       	breq	.+32     	; 0xf3e <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     f1e:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
     f22:	0d c0       	rjmp	.+26     	; 0xf3e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     f24:	f8 01       	movw	r30, r16
     f26:	d7 82       	std	Z+7, r13	; 0x07
     f28:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f2a:	81 89       	ldd	r24, Z+17	; 0x11
     f2c:	88 23       	and	r24, r24
     f2e:	39 f0       	breq	.+14     	; 0xf3e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f30:	c8 01       	movw	r24, r16
     f32:	41 96       	adiw	r24, 0x11	; 17
     f34:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskRemoveFromEventList>
     f38:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     f3a:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     f3e:	0f 90       	pop	r0
     f40:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f42:	81 e0       	ldi	r24, 0x01	; 1
     f44:	57 c0       	rjmp	.+174    	; 0xff4 <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f46:	4c 81       	ldd	r20, Y+4	; 0x04
     f48:	5d 81       	ldd	r21, Y+5	; 0x05
     f4a:	45 2b       	or	r20, r21
     f4c:	21 f4       	brne	.+8      	; 0xf56 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f4e:	0f 90       	pop	r0
     f50:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     f52:	80 e0       	ldi	r24, 0x00	; 0
     f54:	4f c0       	rjmp	.+158    	; 0xff4 <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     f56:	e1 10       	cpse	r14, r1
     f58:	05 c0       	rjmp	.+10     	; 0xf64 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f5a:	ce 01       	movw	r24, r28
     f5c:	01 96       	adiw	r24, 0x01	; 1
     f5e:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f62:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f68:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f6c:	0f b6       	in	r0, 0x3f	; 63
     f6e:	f8 94       	cli
     f70:	0f 92       	push	r0
     f72:	f8 01       	movw	r30, r16
     f74:	85 8d       	ldd	r24, Z+29	; 0x1d
     f76:	8f 3f       	cpi	r24, 0xFF	; 255
     f78:	09 f4       	brne	.+2      	; 0xf7c <xQueueGenericReceive+0xce>
     f7a:	15 8e       	std	Z+29, r1	; 0x1d
     f7c:	f8 01       	movw	r30, r16
     f7e:	96 8d       	ldd	r25, Z+30	; 0x1e
     f80:	9f 3f       	cpi	r25, 0xFF	; 255
     f82:	09 f4       	brne	.+2      	; 0xf86 <xQueueGenericReceive+0xd8>
     f84:	16 8e       	std	Z+30, r1	; 0x1e
     f86:	0f 90       	pop	r0
     f88:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f8a:	be 01       	movw	r22, r28
     f8c:	6c 5f       	subi	r22, 0xFC	; 252
     f8e:	7f 4f       	sbci	r23, 0xFF	; 255
     f90:	ce 01       	movw	r24, r28
     f92:	01 96       	adiw	r24, 0x01	; 1
     f94:	0e 94 16 0c 	call	0x182c	; 0x182c <xTaskCheckForTimeOut>
     f98:	81 11       	cpse	r24, r1
     f9a:	1e c0       	rjmp	.+60     	; 0xfd8 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     f9c:	0f b6       	in	r0, 0x3f	; 63
     f9e:	f8 94       	cli
     fa0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     fa2:	f8 01       	movw	r30, r16
     fa4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     faa:	81 11       	cpse	r24, r1
     fac:	0f c0       	rjmp	.+30     	; 0xfcc <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     fae:	6c 81       	ldd	r22, Y+4	; 0x04
     fb0:	7d 81       	ldd	r23, Y+5	; 0x05
     fb2:	c6 01       	movw	r24, r12
     fb4:	0e 94 b0 0b 	call	0x1760	; 0x1760 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     fb8:	c8 01       	movw	r24, r16
     fba:	0e 94 62 06 	call	0xcc4	; 0xcc4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     fbe:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskResumeAll>
     fc2:	81 11       	cpse	r24, r1
     fc4:	91 cf       	rjmp	.-222    	; 0xee8 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     fc6:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
     fca:	8e cf       	rjmp	.-228    	; 0xee8 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     fcc:	c8 01       	movw	r24, r16
     fce:	0e 94 62 06 	call	0xcc4	; 0xcc4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fd2:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskResumeAll>
     fd6:	88 cf       	rjmp	.-240    	; 0xee8 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     fd8:	c8 01       	movw	r24, r16
     fda:	0e 94 62 06 	call	0xcc4	; 0xcc4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fde:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     fe2:	0f b6       	in	r0, 0x3f	; 63
     fe4:	f8 94       	cli
     fe6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     fe8:	f8 01       	movw	r30, r16
     fea:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ff0:	81 11       	cpse	r24, r1
     ff2:	7a cf       	rjmp	.-268    	; 0xee8 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     ff4:	0f 90       	pop	r0
     ff6:	0f 90       	pop	r0
     ff8:	0f 90       	pop	r0
     ffa:	0f 90       	pop	r0
     ffc:	0f 90       	pop	r0
     ffe:	df 91       	pop	r29
    1000:	cf 91       	pop	r28
    1002:	1f 91       	pop	r17
    1004:	0f 91       	pop	r16
    1006:	ff 90       	pop	r15
    1008:	ef 90       	pop	r14
    100a:	df 90       	pop	r13
    100c:	cf 90       	pop	r12
    100e:	bf 90       	pop	r11
    1010:	af 90       	pop	r10
    1012:	9f 90       	pop	r9
    1014:	8f 90       	pop	r8
    1016:	08 95       	ret

00001018 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1018:	e0 91 96 03 	lds	r30, 0x0396	; 0x800396 <pxDelayedTaskList>
    101c:	f0 91 97 03 	lds	r31, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    1020:	80 81       	ld	r24, Z
    1022:	81 11       	cpse	r24, r1
    1024:	07 c0       	rjmp	.+14     	; 0x1034 <prvResetNextTaskUnblockTime+0x1c>
    1026:	8f ef       	ldi	r24, 0xFF	; 255
    1028:	9f ef       	ldi	r25, 0xFF	; 255
    102a:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <xNextTaskUnblockTime+0x1>
    102e:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <xNextTaskUnblockTime>
    1032:	08 95       	ret
    1034:	e0 91 96 03 	lds	r30, 0x0396	; 0x800396 <pxDelayedTaskList>
    1038:	f0 91 97 03 	lds	r31, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    103c:	05 80       	ldd	r0, Z+5	; 0x05
    103e:	f6 81       	ldd	r31, Z+6	; 0x06
    1040:	e0 2d       	mov	r30, r0
    1042:	06 80       	ldd	r0, Z+6	; 0x06
    1044:	f7 81       	ldd	r31, Z+7	; 0x07
    1046:	e0 2d       	mov	r30, r0
    1048:	82 81       	ldd	r24, Z+2	; 0x02
    104a:	93 81       	ldd	r25, Z+3	; 0x03
    104c:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <xNextTaskUnblockTime+0x1>
    1050:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <xNextTaskUnblockTime>
    1054:	08 95       	ret

00001056 <prvAddCurrentTaskToDelayedList>:
    1056:	0f 93       	push	r16
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	ec 01       	movw	r28, r24
    1060:	00 91 7e 03 	lds	r16, 0x037E	; 0x80037e <xTickCount>
    1064:	10 91 7f 03 	lds	r17, 0x037F	; 0x80037f <xTickCount+0x1>
    1068:	80 91 ce 03 	lds	r24, 0x03CE	; 0x8003ce <pxCurrentTCB>
    106c:	90 91 cf 03 	lds	r25, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1070:	02 96       	adiw	r24, 0x02	; 2
    1072:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    1076:	c0 0f       	add	r28, r16
    1078:	d1 1f       	adc	r29, r17
    107a:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    107e:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1082:	d3 83       	std	Z+3, r29	; 0x03
    1084:	c2 83       	std	Z+2, r28	; 0x02
    1086:	c0 17       	cp	r28, r16
    1088:	d1 07       	cpc	r29, r17
    108a:	68 f4       	brcc	.+26     	; 0x10a6 <prvAddCurrentTaskToDelayedList+0x50>
    108c:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1090:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1094:	80 91 94 03 	lds	r24, 0x0394	; 0x800394 <pxOverflowDelayedTaskList>
    1098:	90 91 95 03 	lds	r25, 0x0395	; 0x800395 <pxOverflowDelayedTaskList+0x1>
    109c:	6e 5f       	subi	r22, 0xFE	; 254
    109e:	7f 4f       	sbci	r23, 0xFF	; 255
    10a0:	0e 94 49 02 	call	0x492	; 0x492 <vListInsert>
    10a4:	17 c0       	rjmp	.+46     	; 0x10d4 <prvAddCurrentTaskToDelayedList+0x7e>
    10a6:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <pxCurrentTCB>
    10aa:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    10ae:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <pxDelayedTaskList>
    10b2:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    10b6:	6e 5f       	subi	r22, 0xFE	; 254
    10b8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ba:	0e 94 49 02 	call	0x492	; 0x492 <vListInsert>
    10be:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <xNextTaskUnblockTime>
    10c2:	90 91 77 03 	lds	r25, 0x0377	; 0x800377 <xNextTaskUnblockTime+0x1>
    10c6:	c8 17       	cp	r28, r24
    10c8:	d9 07       	cpc	r29, r25
    10ca:	20 f4       	brcc	.+8      	; 0x10d4 <prvAddCurrentTaskToDelayedList+0x7e>
    10cc:	d0 93 77 03 	sts	0x0377, r29	; 0x800377 <xNextTaskUnblockTime+0x1>
    10d0:	c0 93 76 03 	sts	0x0376, r28	; 0x800376 <xNextTaskUnblockTime>
    10d4:	df 91       	pop	r29
    10d6:	cf 91       	pop	r28
    10d8:	1f 91       	pop	r17
    10da:	0f 91       	pop	r16
    10dc:	08 95       	ret

000010de <xTaskCreate>:
    10de:	4f 92       	push	r4
    10e0:	5f 92       	push	r5
    10e2:	6f 92       	push	r6
    10e4:	7f 92       	push	r7
    10e6:	8f 92       	push	r8
    10e8:	9f 92       	push	r9
    10ea:	af 92       	push	r10
    10ec:	bf 92       	push	r11
    10ee:	cf 92       	push	r12
    10f0:	df 92       	push	r13
    10f2:	ef 92       	push	r14
    10f4:	ff 92       	push	r15
    10f6:	0f 93       	push	r16
    10f8:	cf 93       	push	r28
    10fa:	df 93       	push	r29
    10fc:	4c 01       	movw	r8, r24
    10fe:	eb 01       	movw	r28, r22
    1100:	6a 01       	movw	r12, r20
    1102:	29 01       	movw	r4, r18
    1104:	ca 01       	movw	r24, r20
    1106:	0e 94 fe 03 	call	0x7fc	; 0x7fc <pvPortMalloc>
    110a:	5c 01       	movw	r10, r24
    110c:	89 2b       	or	r24, r25
    110e:	09 f4       	brne	.+2      	; 0x1112 <xTaskCreate+0x34>
    1110:	ea c0       	rjmp	.+468    	; 0x12e6 <xTaskCreate+0x208>
    1112:	8a e2       	ldi	r24, 0x2A	; 42
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	0e 94 fe 03 	call	0x7fc	; 0x7fc <pvPortMalloc>
    111a:	3c 01       	movw	r6, r24
    111c:	00 97       	sbiw	r24, 0x00	; 0
    111e:	b9 f0       	breq	.+46     	; 0x114e <xTaskCreate+0x70>
    1120:	fc 01       	movw	r30, r24
    1122:	b0 8e       	std	Z+24, r11	; 0x18
    1124:	a7 8a       	std	Z+23, r10	; 0x17
    1126:	a6 01       	movw	r20, r12
    1128:	65 ea       	ldi	r22, 0xA5	; 165
    112a:	70 e0       	ldi	r23, 0x00	; 0
    112c:	c5 01       	movw	r24, r10
    112e:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <memset>
    1132:	f1 e0       	ldi	r31, 0x01	; 1
    1134:	cf 1a       	sub	r12, r31
    1136:	d1 08       	sbc	r13, r1
    1138:	f3 01       	movw	r30, r6
    113a:	87 89       	ldd	r24, Z+23	; 0x17
    113c:	90 8d       	ldd	r25, Z+24	; 0x18
    113e:	c8 0e       	add	r12, r24
    1140:	d9 1e       	adc	r13, r25
    1142:	88 81       	ld	r24, Y
    1144:	81 8f       	std	Z+25, r24	; 0x19
    1146:	88 81       	ld	r24, Y
    1148:	81 11       	cpse	r24, r1
    114a:	05 c0       	rjmp	.+10     	; 0x1156 <xTaskCreate+0x78>
    114c:	14 c0       	rjmp	.+40     	; 0x1176 <xTaskCreate+0x98>
    114e:	c5 01       	movw	r24, r10
    1150:	0e 94 33 04 	call	0x866	; 0x866 <vPortFree>
    1154:	c8 c0       	rjmp	.+400    	; 0x12e6 <xTaskCreate+0x208>
    1156:	d3 01       	movw	r26, r6
    1158:	5a 96       	adiw	r26, 0x1a	; 26
    115a:	fe 01       	movw	r30, r28
    115c:	31 96       	adiw	r30, 0x01	; 1
    115e:	9e 01       	movw	r18, r28
    1160:	28 5f       	subi	r18, 0xF8	; 248
    1162:	3f 4f       	sbci	r19, 0xFF	; 255
    1164:	ef 01       	movw	r28, r30
    1166:	81 91       	ld	r24, Z+
    1168:	8d 93       	st	X+, r24
    116a:	88 81       	ld	r24, Y
    116c:	88 23       	and	r24, r24
    116e:	19 f0       	breq	.+6      	; 0x1176 <xTaskCreate+0x98>
    1170:	e2 17       	cp	r30, r18
    1172:	f3 07       	cpc	r31, r19
    1174:	b9 f7       	brne	.-18     	; 0x1164 <xTaskCreate+0x86>
    1176:	f3 01       	movw	r30, r6
    1178:	10 a2       	std	Z+32, r1	; 0x20
    117a:	04 30       	cpi	r16, 0x04	; 4
    117c:	08 f0       	brcs	.+2      	; 0x1180 <xTaskCreate+0xa2>
    117e:	03 e0       	ldi	r16, 0x03	; 3
    1180:	f3 01       	movw	r30, r6
    1182:	06 8b       	std	Z+22, r16	; 0x16
    1184:	e3 01       	movw	r28, r6
    1186:	22 96       	adiw	r28, 0x02	; 2
    1188:	ce 01       	movw	r24, r28
    118a:	0e 94 24 02 	call	0x448	; 0x448 <vListInitialiseItem>
    118e:	c3 01       	movw	r24, r6
    1190:	0c 96       	adiw	r24, 0x0c	; 12
    1192:	0e 94 24 02 	call	0x448	; 0x448 <vListInitialiseItem>
    1196:	f3 01       	movw	r30, r6
    1198:	71 86       	std	Z+9, r7	; 0x09
    119a:	60 86       	std	Z+8, r6	; 0x08
    119c:	84 e0       	ldi	r24, 0x04	; 4
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	80 1b       	sub	r24, r16
    11a2:	91 09       	sbc	r25, r1
    11a4:	95 87       	std	Z+13, r25	; 0x0d
    11a6:	84 87       	std	Z+12, r24	; 0x0c
    11a8:	73 8a       	std	Z+19, r7	; 0x13
    11aa:	62 8a       	std	Z+18, r6	; 0x12
    11ac:	14 a2       	std	Z+36, r1	; 0x24
    11ae:	13 a2       	std	Z+35, r1	; 0x23
    11b0:	15 a2       	std	Z+37, r1	; 0x25
    11b2:	16 a2       	std	Z+38, r1	; 0x26
    11b4:	17 a2       	std	Z+39, r1	; 0x27
    11b6:	10 a6       	std	Z+40, r1	; 0x28
    11b8:	11 a6       	std	Z+41, r1	; 0x29
    11ba:	a2 01       	movw	r20, r4
    11bc:	b4 01       	movw	r22, r8
    11be:	c6 01       	movw	r24, r12
    11c0:	0e 94 a0 02 	call	0x540	; 0x540 <pxPortInitialiseStack>
    11c4:	f3 01       	movw	r30, r6
    11c6:	91 83       	std	Z+1, r25	; 0x01
    11c8:	80 83       	st	Z, r24
    11ca:	e1 14       	cp	r14, r1
    11cc:	f1 04       	cpc	r15, r1
    11ce:	19 f0       	breq	.+6      	; 0x11d6 <xTaskCreate+0xf8>
    11d0:	f7 01       	movw	r30, r14
    11d2:	71 82       	std	Z+1, r7	; 0x01
    11d4:	60 82       	st	Z, r6
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	f8 94       	cli
    11da:	0f 92       	push	r0
    11dc:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <uxCurrentNumberOfTasks>
    11e0:	8f 5f       	subi	r24, 0xFF	; 255
    11e2:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <uxCurrentNumberOfTasks>
    11e6:	80 91 ce 03 	lds	r24, 0x03CE	; 0x8003ce <pxCurrentTCB>
    11ea:	90 91 cf 03 	lds	r25, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    11ee:	89 2b       	or	r24, r25
    11f0:	a9 f5       	brne	.+106    	; 0x125c <xTaskCreate+0x17e>
    11f2:	70 92 cf 03 	sts	0x03CF, r7	; 0x8003cf <pxCurrentTCB+0x1>
    11f6:	60 92 ce 03 	sts	0x03CE, r6	; 0x8003ce <pxCurrentTCB>
    11fa:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <uxCurrentNumberOfTasks>
    11fe:	81 30       	cpi	r24, 0x01	; 1
    1200:	f1 f5       	brne	.+124    	; 0x127e <xTaskCreate+0x1a0>
    1202:	8a ea       	ldi	r24, 0xAA	; 170
    1204:	93 e0       	ldi	r25, 0x03	; 3
    1206:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    120a:	83 eb       	ldi	r24, 0xB3	; 179
    120c:	93 e0       	ldi	r25, 0x03	; 3
    120e:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    1212:	8c eb       	ldi	r24, 0xBC	; 188
    1214:	93 e0       	ldi	r25, 0x03	; 3
    1216:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    121a:	85 ec       	ldi	r24, 0xC5	; 197
    121c:	93 e0       	ldi	r25, 0x03	; 3
    121e:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    1222:	81 ea       	ldi	r24, 0xA1	; 161
    1224:	93 e0       	ldi	r25, 0x03	; 3
    1226:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    122a:	88 e9       	ldi	r24, 0x98	; 152
    122c:	93 e0       	ldi	r25, 0x03	; 3
    122e:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    1232:	8b e8       	ldi	r24, 0x8B	; 139
    1234:	93 e0       	ldi	r25, 0x03	; 3
    1236:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    123a:	82 e8       	ldi	r24, 0x82	; 130
    123c:	93 e0       	ldi	r25, 0x03	; 3
    123e:	0e 94 16 02 	call	0x42c	; 0x42c <vListInitialise>
    1242:	81 ea       	ldi	r24, 0xA1	; 161
    1244:	93 e0       	ldi	r25, 0x03	; 3
    1246:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <pxDelayedTaskList+0x1>
    124a:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <pxDelayedTaskList>
    124e:	88 e9       	ldi	r24, 0x98	; 152
    1250:	93 e0       	ldi	r25, 0x03	; 3
    1252:	90 93 95 03 	sts	0x0395, r25	; 0x800395 <pxOverflowDelayedTaskList+0x1>
    1256:	80 93 94 03 	sts	0x0394, r24	; 0x800394 <pxOverflowDelayedTaskList>
    125a:	11 c0       	rjmp	.+34     	; 0x127e <xTaskCreate+0x1a0>
    125c:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <xSchedulerRunning>
    1260:	81 11       	cpse	r24, r1
    1262:	0d c0       	rjmp	.+26     	; 0x127e <xTaskCreate+0x1a0>
    1264:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1268:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    126c:	96 89       	ldd	r25, Z+22	; 0x16
    126e:	f3 01       	movw	r30, r6
    1270:	86 89       	ldd	r24, Z+22	; 0x16
    1272:	89 17       	cp	r24, r25
    1274:	20 f0       	brcs	.+8      	; 0x127e <xTaskCreate+0x1a0>
    1276:	70 92 cf 03 	sts	0x03CF, r7	; 0x8003cf <pxCurrentTCB+0x1>
    127a:	60 92 ce 03 	sts	0x03CE, r6	; 0x8003ce <pxCurrentTCB>
    127e:	80 91 78 03 	lds	r24, 0x0378	; 0x800378 <uxTaskNumber>
    1282:	8f 5f       	subi	r24, 0xFF	; 255
    1284:	80 93 78 03 	sts	0x0378, r24	; 0x800378 <uxTaskNumber>
    1288:	f3 01       	movw	r30, r6
    128a:	81 a3       	std	Z+33, r24	; 0x21
    128c:	86 89       	ldd	r24, Z+22	; 0x16
    128e:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <uxTopReadyPriority>
    1292:	98 17       	cp	r25, r24
    1294:	10 f4       	brcc	.+4      	; 0x129a <xTaskCreate+0x1bc>
    1296:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <uxTopReadyPriority>
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	9c 01       	movw	r18, r24
    129e:	22 0f       	add	r18, r18
    12a0:	33 1f       	adc	r19, r19
    12a2:	22 0f       	add	r18, r18
    12a4:	33 1f       	adc	r19, r19
    12a6:	22 0f       	add	r18, r18
    12a8:	33 1f       	adc	r19, r19
    12aa:	82 0f       	add	r24, r18
    12ac:	93 1f       	adc	r25, r19
    12ae:	be 01       	movw	r22, r28
    12b0:	86 55       	subi	r24, 0x56	; 86
    12b2:	9c 4f       	sbci	r25, 0xFC	; 252
    12b4:	0e 94 28 02 	call	0x450	; 0x450 <vListInsertEnd>
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <xSchedulerRunning>
    12c0:	88 23       	and	r24, r24
    12c2:	69 f0       	breq	.+26     	; 0x12de <xTaskCreate+0x200>
    12c4:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    12c8:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    12cc:	96 89       	ldd	r25, Z+22	; 0x16
    12ce:	f3 01       	movw	r30, r6
    12d0:	86 89       	ldd	r24, Z+22	; 0x16
    12d2:	98 17       	cp	r25, r24
    12d4:	30 f4       	brcc	.+12     	; 0x12e2 <xTaskCreate+0x204>
    12d6:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	05 c0       	rjmp	.+10     	; 0x12e8 <xTaskCreate+0x20a>
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	03 c0       	rjmp	.+6      	; 0x12e8 <xTaskCreate+0x20a>
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	01 c0       	rjmp	.+2      	; 0x12e8 <xTaskCreate+0x20a>
    12e6:	8f ef       	ldi	r24, 0xFF	; 255
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	0f 91       	pop	r16
    12ee:	ff 90       	pop	r15
    12f0:	ef 90       	pop	r14
    12f2:	df 90       	pop	r13
    12f4:	cf 90       	pop	r12
    12f6:	bf 90       	pop	r11
    12f8:	af 90       	pop	r10
    12fa:	9f 90       	pop	r9
    12fc:	8f 90       	pop	r8
    12fe:	7f 90       	pop	r7
    1300:	6f 90       	pop	r6
    1302:	5f 90       	pop	r5
    1304:	4f 90       	pop	r4
    1306:	08 95       	ret

00001308 <vTaskStartScheduler>:
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	0f 2e       	mov	r0, r31
    1310:	f4 e7       	ldi	r31, 0x74	; 116
    1312:	ef 2e       	mov	r14, r31
    1314:	f3 e0       	ldi	r31, 0x03	; 3
    1316:	ff 2e       	mov	r15, r31
    1318:	f0 2d       	mov	r31, r0
    131a:	00 e0       	ldi	r16, 0x00	; 0
    131c:	20 e0       	ldi	r18, 0x00	; 0
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	45 e5       	ldi	r20, 0x55	; 85
    1322:	50 e0       	ldi	r21, 0x00	; 0
    1324:	63 e4       	ldi	r22, 0x43	; 67
    1326:	71 e0       	ldi	r23, 0x01	; 1
    1328:	8e ee       	ldi	r24, 0xEE	; 238
    132a:	9a e0       	ldi	r25, 0x0A	; 10
    132c:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskCreate>
    1330:	81 30       	cpi	r24, 0x01	; 1
    1332:	81 f4       	brne	.+32     	; 0x1354 <vTaskStartScheduler+0x4c>
    1334:	f8 94       	cli
    1336:	8f ef       	ldi	r24, 0xFF	; 255
    1338:	9f ef       	ldi	r25, 0xFF	; 255
    133a:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <xNextTaskUnblockTime+0x1>
    133e:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <xNextTaskUnblockTime>
    1342:	81 e0       	ldi	r24, 0x01	; 1
    1344:	80 93 7c 03 	sts	0x037C, r24	; 0x80037c <xSchedulerRunning>
    1348:	10 92 7f 03 	sts	0x037F, r1	; 0x80037f <xTickCount+0x1>
    134c:	10 92 7e 03 	sts	0x037E, r1	; 0x80037e <xTickCount>
    1350:	0e 94 0c 03 	call	0x618	; 0x618 <xPortStartScheduler>
    1354:	0f 91       	pop	r16
    1356:	ff 90       	pop	r15
    1358:	ef 90       	pop	r14
    135a:	08 95       	ret

0000135c <vTaskSuspendAll>:
    135c:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    1360:	8f 5f       	subi	r24, 0xFF	; 255
    1362:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <uxSchedulerSuspended>
    1366:	08 95       	ret

00001368 <xTaskIncrementTick>:
    1368:	cf 92       	push	r12
    136a:	df 92       	push	r13
    136c:	ef 92       	push	r14
    136e:	ff 92       	push	r15
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    137c:	81 11       	cpse	r24, r1
    137e:	99 c0       	rjmp	.+306    	; 0x14b2 <xTaskIncrementTick+0x14a>
    1380:	e0 90 7e 03 	lds	r14, 0x037E	; 0x80037e <xTickCount>
    1384:	f0 90 7f 03 	lds	r15, 0x037F	; 0x80037f <xTickCount+0x1>
    1388:	8f ef       	ldi	r24, 0xFF	; 255
    138a:	e8 1a       	sub	r14, r24
    138c:	f8 0a       	sbc	r15, r24
    138e:	f0 92 7f 03 	sts	0x037F, r15	; 0x80037f <xTickCount+0x1>
    1392:	e0 92 7e 03 	sts	0x037E, r14	; 0x80037e <xTickCount>
    1396:	e1 14       	cp	r14, r1
    1398:	f1 04       	cpc	r15, r1
    139a:	b9 f4       	brne	.+46     	; 0x13ca <xTaskIncrementTick+0x62>
    139c:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <pxDelayedTaskList>
    13a0:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    13a4:	20 91 94 03 	lds	r18, 0x0394	; 0x800394 <pxOverflowDelayedTaskList>
    13a8:	30 91 95 03 	lds	r19, 0x0395	; 0x800395 <pxOverflowDelayedTaskList+0x1>
    13ac:	30 93 97 03 	sts	0x0397, r19	; 0x800397 <pxDelayedTaskList+0x1>
    13b0:	20 93 96 03 	sts	0x0396, r18	; 0x800396 <pxDelayedTaskList>
    13b4:	90 93 95 03 	sts	0x0395, r25	; 0x800395 <pxOverflowDelayedTaskList+0x1>
    13b8:	80 93 94 03 	sts	0x0394, r24	; 0x800394 <pxOverflowDelayedTaskList>
    13bc:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <xNumOfOverflows>
    13c0:	8f 5f       	subi	r24, 0xFF	; 255
    13c2:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <xNumOfOverflows>
    13c6:	0e 94 0c 08 	call	0x1018	; 0x1018 <prvResetNextTaskUnblockTime>
    13ca:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <xNextTaskUnblockTime>
    13ce:	90 91 77 03 	lds	r25, 0x0377	; 0x800377 <xNextTaskUnblockTime+0x1>
    13d2:	e8 16       	cp	r14, r24
    13d4:	f9 06       	cpc	r15, r25
    13d6:	10 f4       	brcc	.+4      	; 0x13dc <xTaskIncrementTick+0x74>
    13d8:	d1 2c       	mov	r13, r1
    13da:	53 c0       	rjmp	.+166    	; 0x1482 <xTaskIncrementTick+0x11a>
    13dc:	d1 2c       	mov	r13, r1
    13de:	cc 24       	eor	r12, r12
    13e0:	c3 94       	inc	r12
    13e2:	e0 91 96 03 	lds	r30, 0x0396	; 0x800396 <pxDelayedTaskList>
    13e6:	f0 91 97 03 	lds	r31, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    13ea:	90 81       	ld	r25, Z
    13ec:	91 11       	cpse	r25, r1
    13ee:	07 c0       	rjmp	.+14     	; 0x13fe <xTaskIncrementTick+0x96>
    13f0:	8f ef       	ldi	r24, 0xFF	; 255
    13f2:	9f ef       	ldi	r25, 0xFF	; 255
    13f4:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <xNextTaskUnblockTime+0x1>
    13f8:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <xNextTaskUnblockTime>
    13fc:	42 c0       	rjmp	.+132    	; 0x1482 <xTaskIncrementTick+0x11a>
    13fe:	e0 91 96 03 	lds	r30, 0x0396	; 0x800396 <pxDelayedTaskList>
    1402:	f0 91 97 03 	lds	r31, 0x0397	; 0x800397 <pxDelayedTaskList+0x1>
    1406:	05 80       	ldd	r0, Z+5	; 0x05
    1408:	f6 81       	ldd	r31, Z+6	; 0x06
    140a:	e0 2d       	mov	r30, r0
    140c:	c6 81       	ldd	r28, Z+6	; 0x06
    140e:	d7 81       	ldd	r29, Z+7	; 0x07
    1410:	2a 81       	ldd	r18, Y+2	; 0x02
    1412:	3b 81       	ldd	r19, Y+3	; 0x03
    1414:	e2 16       	cp	r14, r18
    1416:	f3 06       	cpc	r15, r19
    1418:	28 f4       	brcc	.+10     	; 0x1424 <xTaskIncrementTick+0xbc>
    141a:	30 93 77 03 	sts	0x0377, r19	; 0x800377 <xNextTaskUnblockTime+0x1>
    141e:	20 93 76 03 	sts	0x0376, r18	; 0x800376 <xNextTaskUnblockTime>
    1422:	2f c0       	rjmp	.+94     	; 0x1482 <xTaskIncrementTick+0x11a>
    1424:	8e 01       	movw	r16, r28
    1426:	0e 5f       	subi	r16, 0xFE	; 254
    1428:	1f 4f       	sbci	r17, 0xFF	; 255
    142a:	c8 01       	movw	r24, r16
    142c:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    1430:	8c 89       	ldd	r24, Y+20	; 0x14
    1432:	9d 89       	ldd	r25, Y+21	; 0x15
    1434:	89 2b       	or	r24, r25
    1436:	21 f0       	breq	.+8      	; 0x1440 <xTaskIncrementTick+0xd8>
    1438:	ce 01       	movw	r24, r28
    143a:	0c 96       	adiw	r24, 0x0c	; 12
    143c:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    1440:	2e 89       	ldd	r18, Y+22	; 0x16
    1442:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <uxTopReadyPriority>
    1446:	82 17       	cp	r24, r18
    1448:	10 f4       	brcc	.+4      	; 0x144e <xTaskIncrementTick+0xe6>
    144a:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <uxTopReadyPriority>
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	c9 01       	movw	r24, r18
    1452:	88 0f       	add	r24, r24
    1454:	99 1f       	adc	r25, r25
    1456:	88 0f       	add	r24, r24
    1458:	99 1f       	adc	r25, r25
    145a:	88 0f       	add	r24, r24
    145c:	99 1f       	adc	r25, r25
    145e:	82 0f       	add	r24, r18
    1460:	93 1f       	adc	r25, r19
    1462:	b8 01       	movw	r22, r16
    1464:	86 55       	subi	r24, 0x56	; 86
    1466:	9c 4f       	sbci	r25, 0xFC	; 252
    1468:	0e 94 28 02 	call	0x450	; 0x450 <vListInsertEnd>
    146c:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1470:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1474:	9e 89       	ldd	r25, Y+22	; 0x16
    1476:	86 89       	ldd	r24, Z+22	; 0x16
    1478:	98 17       	cp	r25, r24
    147a:	08 f4       	brcc	.+2      	; 0x147e <xTaskIncrementTick+0x116>
    147c:	b2 cf       	rjmp	.-156    	; 0x13e2 <xTaskIncrementTick+0x7a>
    147e:	dc 2c       	mov	r13, r12
    1480:	b0 cf       	rjmp	.-160    	; 0x13e2 <xTaskIncrementTick+0x7a>
    1482:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1486:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    148a:	86 89       	ldd	r24, Z+22	; 0x16
    148c:	90 e0       	ldi	r25, 0x00	; 0
    148e:	fc 01       	movw	r30, r24
    1490:	ee 0f       	add	r30, r30
    1492:	ff 1f       	adc	r31, r31
    1494:	ee 0f       	add	r30, r30
    1496:	ff 1f       	adc	r31, r31
    1498:	ee 0f       	add	r30, r30
    149a:	ff 1f       	adc	r31, r31
    149c:	8e 0f       	add	r24, r30
    149e:	9f 1f       	adc	r25, r31
    14a0:	fc 01       	movw	r30, r24
    14a2:	e6 55       	subi	r30, 0x56	; 86
    14a4:	fc 4f       	sbci	r31, 0xFC	; 252
    14a6:	80 81       	ld	r24, Z
    14a8:	82 30       	cpi	r24, 0x02	; 2
    14aa:	48 f0       	brcs	.+18     	; 0x14be <xTaskIncrementTick+0x156>
    14ac:	dd 24       	eor	r13, r13
    14ae:	d3 94       	inc	r13
    14b0:	06 c0       	rjmp	.+12     	; 0x14be <xTaskIncrementTick+0x156>
    14b2:	80 91 7b 03 	lds	r24, 0x037B	; 0x80037b <uxPendedTicks>
    14b6:	8f 5f       	subi	r24, 0xFF	; 255
    14b8:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <uxPendedTicks>
    14bc:	d1 2c       	mov	r13, r1
    14be:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xYieldPending>
    14c2:	88 23       	and	r24, r24
    14c4:	11 f0       	breq	.+4      	; 0x14ca <xTaskIncrementTick+0x162>
    14c6:	dd 24       	eor	r13, r13
    14c8:	d3 94       	inc	r13
    14ca:	8d 2d       	mov	r24, r13
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	1f 91       	pop	r17
    14d2:	0f 91       	pop	r16
    14d4:	ff 90       	pop	r15
    14d6:	ef 90       	pop	r14
    14d8:	df 90       	pop	r13
    14da:	cf 90       	pop	r12
    14dc:	08 95       	ret

000014de <xTaskResumeAll>:
    14de:	df 92       	push	r13
    14e0:	ef 92       	push	r14
    14e2:	ff 92       	push	r15
    14e4:	0f 93       	push	r16
    14e6:	1f 93       	push	r17
    14e8:	cf 93       	push	r28
    14ea:	df 93       	push	r29
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	0f 92       	push	r0
    14f2:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    14f6:	81 50       	subi	r24, 0x01	; 1
    14f8:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <uxSchedulerSuspended>
    14fc:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    1500:	81 11       	cpse	r24, r1
    1502:	5f c0       	rjmp	.+190    	; 0x15c2 <xTaskResumeAll+0xe4>
    1504:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <uxCurrentNumberOfTasks>
    1508:	81 11       	cpse	r24, r1
    150a:	33 c0       	rjmp	.+102    	; 0x1572 <xTaskResumeAll+0x94>
    150c:	5d c0       	rjmp	.+186    	; 0x15c8 <xTaskResumeAll+0xea>
    150e:	d7 01       	movw	r26, r14
    1510:	15 96       	adiw	r26, 0x05	; 5
    1512:	ed 91       	ld	r30, X+
    1514:	fc 91       	ld	r31, X
    1516:	16 97       	sbiw	r26, 0x06	; 6
    1518:	c6 81       	ldd	r28, Z+6	; 0x06
    151a:	d7 81       	ldd	r29, Z+7	; 0x07
    151c:	ce 01       	movw	r24, r28
    151e:	0c 96       	adiw	r24, 0x0c	; 12
    1520:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    1524:	8e 01       	movw	r16, r28
    1526:	0e 5f       	subi	r16, 0xFE	; 254
    1528:	1f 4f       	sbci	r17, 0xFF	; 255
    152a:	c8 01       	movw	r24, r16
    152c:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    1530:	2e 89       	ldd	r18, Y+22	; 0x16
    1532:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <uxTopReadyPriority>
    1536:	82 17       	cp	r24, r18
    1538:	10 f4       	brcc	.+4      	; 0x153e <xTaskResumeAll+0x60>
    153a:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <uxTopReadyPriority>
    153e:	30 e0       	ldi	r19, 0x00	; 0
    1540:	c9 01       	movw	r24, r18
    1542:	88 0f       	add	r24, r24
    1544:	99 1f       	adc	r25, r25
    1546:	88 0f       	add	r24, r24
    1548:	99 1f       	adc	r25, r25
    154a:	88 0f       	add	r24, r24
    154c:	99 1f       	adc	r25, r25
    154e:	82 0f       	add	r24, r18
    1550:	93 1f       	adc	r25, r19
    1552:	b8 01       	movw	r22, r16
    1554:	86 55       	subi	r24, 0x56	; 86
    1556:	9c 4f       	sbci	r25, 0xFC	; 252
    1558:	0e 94 28 02 	call	0x450	; 0x450 <vListInsertEnd>
    155c:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1560:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1564:	9e 89       	ldd	r25, Y+22	; 0x16
    1566:	86 89       	ldd	r24, Z+22	; 0x16
    1568:	98 17       	cp	r25, r24
    156a:	68 f0       	brcs	.+26     	; 0x1586 <xTaskResumeAll+0xa8>
    156c:	d0 92 7a 03 	sts	0x037A, r13	; 0x80037a <xYieldPending>
    1570:	0a c0       	rjmp	.+20     	; 0x1586 <xTaskResumeAll+0xa8>
    1572:	c0 e0       	ldi	r28, 0x00	; 0
    1574:	d0 e0       	ldi	r29, 0x00	; 0
    1576:	0f 2e       	mov	r0, r31
    1578:	fb e8       	ldi	r31, 0x8B	; 139
    157a:	ef 2e       	mov	r14, r31
    157c:	f3 e0       	ldi	r31, 0x03	; 3
    157e:	ff 2e       	mov	r15, r31
    1580:	f0 2d       	mov	r31, r0
    1582:	dd 24       	eor	r13, r13
    1584:	d3 94       	inc	r13
    1586:	f7 01       	movw	r30, r14
    1588:	80 81       	ld	r24, Z
    158a:	81 11       	cpse	r24, r1
    158c:	c0 cf       	rjmp	.-128    	; 0x150e <xTaskResumeAll+0x30>
    158e:	cd 2b       	or	r28, r29
    1590:	11 f0       	breq	.+4      	; 0x1596 <xTaskResumeAll+0xb8>
    1592:	0e 94 0c 08 	call	0x1018	; 0x1018 <prvResetNextTaskUnblockTime>
    1596:	c0 91 7b 03 	lds	r28, 0x037B	; 0x80037b <uxPendedTicks>
    159a:	cc 23       	and	r28, r28
    159c:	51 f0       	breq	.+20     	; 0x15b2 <xTaskResumeAll+0xd4>
    159e:	d1 e0       	ldi	r29, 0x01	; 1
    15a0:	0e 94 b4 09 	call	0x1368	; 0x1368 <xTaskIncrementTick>
    15a4:	81 11       	cpse	r24, r1
    15a6:	d0 93 7a 03 	sts	0x037A, r29	; 0x80037a <xYieldPending>
    15aa:	c1 50       	subi	r28, 0x01	; 1
    15ac:	c9 f7       	brne	.-14     	; 0x15a0 <xTaskResumeAll+0xc2>
    15ae:	10 92 7b 03 	sts	0x037B, r1	; 0x80037b <uxPendedTicks>
    15b2:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xYieldPending>
    15b6:	88 23       	and	r24, r24
    15b8:	31 f0       	breq	.+12     	; 0x15c6 <xTaskResumeAll+0xe8>
    15ba:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
    15be:	81 e0       	ldi	r24, 0x01	; 1
    15c0:	03 c0       	rjmp	.+6      	; 0x15c8 <xTaskResumeAll+0xea>
    15c2:	80 e0       	ldi	r24, 0x00	; 0
    15c4:	01 c0       	rjmp	.+2      	; 0x15c8 <xTaskResumeAll+0xea>
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	0f 90       	pop	r0
    15ca:	0f be       	out	0x3f, r0	; 63
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	ff 90       	pop	r15
    15d6:	ef 90       	pop	r14
    15d8:	df 90       	pop	r13
    15da:	08 95       	ret

000015dc <prvIdleTask>:
    15dc:	02 e8       	ldi	r16, 0x82	; 130
    15de:	13 e0       	ldi	r17, 0x03	; 3
    15e0:	0f 2e       	mov	r0, r31
    15e2:	fa ea       	ldi	r31, 0xAA	; 170
    15e4:	ef 2e       	mov	r14, r31
    15e6:	f3 e0       	ldi	r31, 0x03	; 3
    15e8:	ff 2e       	mov	r15, r31
    15ea:	f0 2d       	mov	r31, r0
    15ec:	29 c0       	rjmp	.+82     	; 0x1640 <prvIdleTask+0x64>
    15ee:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskSuspendAll>
    15f2:	d8 01       	movw	r26, r16
    15f4:	cc 91       	ld	r28, X
    15f6:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskResumeAll>
    15fa:	cc 23       	and	r28, r28
    15fc:	09 f1       	breq	.+66     	; 0x1640 <prvIdleTask+0x64>
    15fe:	0f b6       	in	r0, 0x3f	; 63
    1600:	f8 94       	cli
    1602:	0f 92       	push	r0
    1604:	d8 01       	movw	r26, r16
    1606:	15 96       	adiw	r26, 0x05	; 5
    1608:	ed 91       	ld	r30, X+
    160a:	fc 91       	ld	r31, X
    160c:	16 97       	sbiw	r26, 0x06	; 6
    160e:	c6 81       	ldd	r28, Z+6	; 0x06
    1610:	d7 81       	ldd	r29, Z+7	; 0x07
    1612:	ce 01       	movw	r24, r28
    1614:	02 96       	adiw	r24, 0x02	; 2
    1616:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    161a:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <uxCurrentNumberOfTasks>
    161e:	81 50       	subi	r24, 0x01	; 1
    1620:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <uxCurrentNumberOfTasks>
    1624:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <uxDeletedTasksWaitingCleanUp>
    1628:	81 50       	subi	r24, 0x01	; 1
    162a:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <uxDeletedTasksWaitingCleanUp>
    162e:	0f 90       	pop	r0
    1630:	0f be       	out	0x3f, r0	; 63
    1632:	8f 89       	ldd	r24, Y+23	; 0x17
    1634:	98 8d       	ldd	r25, Y+24	; 0x18
    1636:	0e 94 33 04 	call	0x866	; 0x866 <vPortFree>
    163a:	ce 01       	movw	r24, r28
    163c:	0e 94 33 04 	call	0x866	; 0x866 <vPortFree>
    1640:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <uxDeletedTasksWaitingCleanUp>
    1644:	81 11       	cpse	r24, r1
    1646:	d3 cf       	rjmp	.-90     	; 0x15ee <prvIdleTask+0x12>
    1648:	f7 01       	movw	r30, r14
    164a:	80 81       	ld	r24, Z
    164c:	82 30       	cpi	r24, 0x02	; 2
    164e:	10 f0       	brcs	.+4      	; 0x1654 <prvIdleTask+0x78>
    1650:	0e 94 46 03 	call	0x68c	; 0x68c <vPortYield>
    1654:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <vApplicationIdleHook>
    1658:	f3 cf       	rjmp	.-26     	; 0x1640 <prvIdleTask+0x64>

0000165a <vTaskSetApplicationTaskTag>:
    165a:	00 97       	sbiw	r24, 0x00	; 0
    165c:	21 f4       	brne	.+8      	; 0x1666 <vTaskSetApplicationTaskTag+0xc>
    165e:	80 91 ce 03 	lds	r24, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1662:	90 91 cf 03 	lds	r25, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1666:	0f b6       	in	r0, 0x3f	; 63
    1668:	f8 94       	cli
    166a:	0f 92       	push	r0
    166c:	fc 01       	movw	r30, r24
    166e:	74 a3       	std	Z+36, r23	; 0x24
    1670:	63 a3       	std	Z+35, r22	; 0x23
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	08 95       	ret

00001678 <vTaskSwitchContext>:
    1678:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    167c:	88 23       	and	r24, r24
    167e:	21 f0       	breq	.+8      	; 0x1688 <vTaskSwitchContext+0x10>
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	80 93 7a 03 	sts	0x037A, r24	; 0x80037a <xYieldPending>
    1686:	08 95       	ret
    1688:	10 92 7a 03 	sts	0x037A, r1	; 0x80037a <xYieldPending>
    168c:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1690:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1694:	83 a1       	ldd	r24, Z+35	; 0x23
    1696:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <switch_out>
    169a:	20 91 7d 03 	lds	r18, 0x037D	; 0x80037d <uxTopReadyPriority>
    169e:	82 2f       	mov	r24, r18
    16a0:	90 e0       	ldi	r25, 0x00	; 0
    16a2:	fc 01       	movw	r30, r24
    16a4:	ee 0f       	add	r30, r30
    16a6:	ff 1f       	adc	r31, r31
    16a8:	ee 0f       	add	r30, r30
    16aa:	ff 1f       	adc	r31, r31
    16ac:	ee 0f       	add	r30, r30
    16ae:	ff 1f       	adc	r31, r31
    16b0:	e8 0f       	add	r30, r24
    16b2:	f9 1f       	adc	r31, r25
    16b4:	e6 55       	subi	r30, 0x56	; 86
    16b6:	fc 4f       	sbci	r31, 0xFC	; 252
    16b8:	30 81       	ld	r19, Z
    16ba:	31 11       	cpse	r19, r1
    16bc:	11 c0       	rjmp	.+34     	; 0x16e0 <vTaskSwitchContext+0x68>
    16be:	21 50       	subi	r18, 0x01	; 1
    16c0:	82 2f       	mov	r24, r18
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	fc 01       	movw	r30, r24
    16c6:	ee 0f       	add	r30, r30
    16c8:	ff 1f       	adc	r31, r31
    16ca:	ee 0f       	add	r30, r30
    16cc:	ff 1f       	adc	r31, r31
    16ce:	ee 0f       	add	r30, r30
    16d0:	ff 1f       	adc	r31, r31
    16d2:	e8 0f       	add	r30, r24
    16d4:	f9 1f       	adc	r31, r25
    16d6:	e6 55       	subi	r30, 0x56	; 86
    16d8:	fc 4f       	sbci	r31, 0xFC	; 252
    16da:	30 81       	ld	r19, Z
    16dc:	33 23       	and	r19, r19
    16de:	79 f3       	breq	.-34     	; 0x16be <vTaskSwitchContext+0x46>
    16e0:	ac 01       	movw	r20, r24
    16e2:	44 0f       	add	r20, r20
    16e4:	55 1f       	adc	r21, r21
    16e6:	44 0f       	add	r20, r20
    16e8:	55 1f       	adc	r21, r21
    16ea:	44 0f       	add	r20, r20
    16ec:	55 1f       	adc	r21, r21
    16ee:	48 0f       	add	r20, r24
    16f0:	59 1f       	adc	r21, r25
    16f2:	da 01       	movw	r26, r20
    16f4:	a6 55       	subi	r26, 0x56	; 86
    16f6:	bc 4f       	sbci	r27, 0xFC	; 252
    16f8:	11 96       	adiw	r26, 0x01	; 1
    16fa:	ed 91       	ld	r30, X+
    16fc:	fc 91       	ld	r31, X
    16fe:	12 97       	sbiw	r26, 0x02	; 2
    1700:	02 80       	ldd	r0, Z+2	; 0x02
    1702:	f3 81       	ldd	r31, Z+3	; 0x03
    1704:	e0 2d       	mov	r30, r0
    1706:	12 96       	adiw	r26, 0x02	; 2
    1708:	fc 93       	st	X, r31
    170a:	ee 93       	st	-X, r30
    170c:	11 97       	sbiw	r26, 0x01	; 1
    170e:	43 55       	subi	r20, 0x53	; 83
    1710:	5c 4f       	sbci	r21, 0xFC	; 252
    1712:	e4 17       	cp	r30, r20
    1714:	f5 07       	cpc	r31, r21
    1716:	29 f4       	brne	.+10     	; 0x1722 <vTaskSwitchContext+0xaa>
    1718:	42 81       	ldd	r20, Z+2	; 0x02
    171a:	53 81       	ldd	r21, Z+3	; 0x03
    171c:	fd 01       	movw	r30, r26
    171e:	52 83       	std	Z+2, r21	; 0x02
    1720:	41 83       	std	Z+1, r20	; 0x01
    1722:	fc 01       	movw	r30, r24
    1724:	ee 0f       	add	r30, r30
    1726:	ff 1f       	adc	r31, r31
    1728:	ee 0f       	add	r30, r30
    172a:	ff 1f       	adc	r31, r31
    172c:	ee 0f       	add	r30, r30
    172e:	ff 1f       	adc	r31, r31
    1730:	8e 0f       	add	r24, r30
    1732:	9f 1f       	adc	r25, r31
    1734:	fc 01       	movw	r30, r24
    1736:	e6 55       	subi	r30, 0x56	; 86
    1738:	fc 4f       	sbci	r31, 0xFC	; 252
    173a:	01 80       	ldd	r0, Z+1	; 0x01
    173c:	f2 81       	ldd	r31, Z+2	; 0x02
    173e:	e0 2d       	mov	r30, r0
    1740:	86 81       	ldd	r24, Z+6	; 0x06
    1742:	97 81       	ldd	r25, Z+7	; 0x07
    1744:	90 93 cf 03 	sts	0x03CF, r25	; 0x8003cf <pxCurrentTCB+0x1>
    1748:	80 93 ce 03 	sts	0x03CE, r24	; 0x8003ce <pxCurrentTCB>
    174c:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <uxTopReadyPriority>
    1750:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    1754:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    1758:	83 a1       	ldd	r24, Z+35	; 0x23
    175a:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <switch_in>
    175e:	08 95       	ret

00001760 <vTaskPlaceOnEventList>:
    1760:	cf 93       	push	r28
    1762:	df 93       	push	r29
    1764:	eb 01       	movw	r28, r22
    1766:	20 91 ce 03 	lds	r18, 0x03CE	; 0x8003ce <pxCurrentTCB>
    176a:	30 91 cf 03 	lds	r19, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    176e:	b9 01       	movw	r22, r18
    1770:	64 5f       	subi	r22, 0xF4	; 244
    1772:	7f 4f       	sbci	r23, 0xFF	; 255
    1774:	0e 94 49 02 	call	0x492	; 0x492 <vListInsert>
    1778:	61 e0       	ldi	r22, 0x01	; 1
    177a:	ce 01       	movw	r24, r28
    177c:	0e 94 2b 08 	call	0x1056	; 0x1056 <prvAddCurrentTaskToDelayedList>
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	08 95       	ret

00001786 <xTaskRemoveFromEventList>:
    1786:	0f 93       	push	r16
    1788:	1f 93       	push	r17
    178a:	cf 93       	push	r28
    178c:	df 93       	push	r29
    178e:	dc 01       	movw	r26, r24
    1790:	15 96       	adiw	r26, 0x05	; 5
    1792:	ed 91       	ld	r30, X+
    1794:	fc 91       	ld	r31, X
    1796:	16 97       	sbiw	r26, 0x06	; 6
    1798:	c6 81       	ldd	r28, Z+6	; 0x06
    179a:	d7 81       	ldd	r29, Z+7	; 0x07
    179c:	8e 01       	movw	r16, r28
    179e:	04 5f       	subi	r16, 0xF4	; 244
    17a0:	1f 4f       	sbci	r17, 0xFF	; 255
    17a2:	c8 01       	movw	r24, r16
    17a4:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    17a8:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxSchedulerSuspended>
    17ac:	81 11       	cpse	r24, r1
    17ae:	1c c0       	rjmp	.+56     	; 0x17e8 <xTaskRemoveFromEventList+0x62>
    17b0:	0a 50       	subi	r16, 0x0A	; 10
    17b2:	11 09       	sbc	r17, r1
    17b4:	c8 01       	movw	r24, r16
    17b6:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <uxListRemove>
    17ba:	2e 89       	ldd	r18, Y+22	; 0x16
    17bc:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <uxTopReadyPriority>
    17c0:	82 17       	cp	r24, r18
    17c2:	10 f4       	brcc	.+4      	; 0x17c8 <xTaskRemoveFromEventList+0x42>
    17c4:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <uxTopReadyPriority>
    17c8:	30 e0       	ldi	r19, 0x00	; 0
    17ca:	c9 01       	movw	r24, r18
    17cc:	88 0f       	add	r24, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	88 0f       	add	r24, r24
    17d2:	99 1f       	adc	r25, r25
    17d4:	88 0f       	add	r24, r24
    17d6:	99 1f       	adc	r25, r25
    17d8:	82 0f       	add	r24, r18
    17da:	93 1f       	adc	r25, r19
    17dc:	b8 01       	movw	r22, r16
    17de:	86 55       	subi	r24, 0x56	; 86
    17e0:	9c 4f       	sbci	r25, 0xFC	; 252
    17e2:	0e 94 28 02 	call	0x450	; 0x450 <vListInsertEnd>
    17e6:	05 c0       	rjmp	.+10     	; 0x17f2 <xTaskRemoveFromEventList+0x6c>
    17e8:	b8 01       	movw	r22, r16
    17ea:	8b e8       	ldi	r24, 0x8B	; 139
    17ec:	93 e0       	ldi	r25, 0x03	; 3
    17ee:	0e 94 28 02 	call	0x450	; 0x450 <vListInsertEnd>
    17f2:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <pxCurrentTCB>
    17f6:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <pxCurrentTCB+0x1>
    17fa:	9e 89       	ldd	r25, Y+22	; 0x16
    17fc:	86 89       	ldd	r24, Z+22	; 0x16
    17fe:	89 17       	cp	r24, r25
    1800:	20 f4       	brcc	.+8      	; 0x180a <xTaskRemoveFromEventList+0x84>
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	80 93 7a 03 	sts	0x037A, r24	; 0x80037a <xYieldPending>
    1808:	01 c0       	rjmp	.+2      	; 0x180c <xTaskRemoveFromEventList+0x86>
    180a:	80 e0       	ldi	r24, 0x00	; 0
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	1f 91       	pop	r17
    1812:	0f 91       	pop	r16
    1814:	08 95       	ret

00001816 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1816:	20 91 79 03 	lds	r18, 0x0379	; 0x800379 <xNumOfOverflows>
    181a:	fc 01       	movw	r30, r24
    181c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    181e:	20 91 7e 03 	lds	r18, 0x037E	; 0x80037e <xTickCount>
    1822:	30 91 7f 03 	lds	r19, 0x037F	; 0x80037f <xTickCount+0x1>
    1826:	32 83       	std	Z+2, r19	; 0x02
    1828:	21 83       	std	Z+1, r18	; 0x01
    182a:	08 95       	ret

0000182c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    182c:	cf 93       	push	r28
    182e:	df 93       	push	r29
    1830:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	f8 94       	cli
    1836:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1838:	20 91 7e 03 	lds	r18, 0x037E	; 0x80037e <xTickCount>
    183c:	30 91 7f 03 	lds	r19, 0x037F	; 0x80037f <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1840:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <xNumOfOverflows>
    1844:	90 81       	ld	r25, Z
    1846:	98 17       	cp	r25, r24
    1848:	29 f0       	breq	.+10     	; 0x1854 <xTaskCheckForTimeOut+0x28>
    184a:	81 81       	ldd	r24, Z+1	; 0x01
    184c:	92 81       	ldd	r25, Z+2	; 0x02
    184e:	28 17       	cp	r18, r24
    1850:	39 07       	cpc	r19, r25
    1852:	b0 f4       	brcc	.+44     	; 0x1880 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1854:	a1 81       	ldd	r26, Z+1	; 0x01
    1856:	b2 81       	ldd	r27, Z+2	; 0x02
    1858:	eb 01       	movw	r28, r22
    185a:	48 81       	ld	r20, Y
    185c:	59 81       	ldd	r21, Y+1	; 0x01
    185e:	c9 01       	movw	r24, r18
    1860:	8a 1b       	sub	r24, r26
    1862:	9b 0b       	sbc	r25, r27
    1864:	84 17       	cp	r24, r20
    1866:	95 07       	cpc	r25, r21
    1868:	68 f4       	brcc	.+26     	; 0x1884 <xTaskCheckForTimeOut+0x58>
    186a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    186c:	a2 1b       	sub	r26, r18
    186e:	b3 0b       	sbc	r27, r19
    1870:	4a 0f       	add	r20, r26
    1872:	5b 1f       	adc	r21, r27
    1874:	59 83       	std	Y+1, r21	; 0x01
    1876:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    1878:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	03 c0       	rjmp	.+6      	; 0x1886 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1880:	81 e0       	ldi	r24, 0x01	; 1
    1882:	01 c0       	rjmp	.+2      	; 0x1886 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1884:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	08 95       	ret

00001890 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	80 93 7a 03 	sts	0x037A, r24	; 0x80037a <xYieldPending>
    1896:	08 95       	ret

00001898 <__udivmodsi4>:
    1898:	a1 e2       	ldi	r26, 0x21	; 33
    189a:	1a 2e       	mov	r1, r26
    189c:	aa 1b       	sub	r26, r26
    189e:	bb 1b       	sub	r27, r27
    18a0:	fd 01       	movw	r30, r26
    18a2:	0d c0       	rjmp	.+26     	; 0x18be <__udivmodsi4_ep>

000018a4 <__udivmodsi4_loop>:
    18a4:	aa 1f       	adc	r26, r26
    18a6:	bb 1f       	adc	r27, r27
    18a8:	ee 1f       	adc	r30, r30
    18aa:	ff 1f       	adc	r31, r31
    18ac:	a2 17       	cp	r26, r18
    18ae:	b3 07       	cpc	r27, r19
    18b0:	e4 07       	cpc	r30, r20
    18b2:	f5 07       	cpc	r31, r21
    18b4:	20 f0       	brcs	.+8      	; 0x18be <__udivmodsi4_ep>
    18b6:	a2 1b       	sub	r26, r18
    18b8:	b3 0b       	sbc	r27, r19
    18ba:	e4 0b       	sbc	r30, r20
    18bc:	f5 0b       	sbc	r31, r21

000018be <__udivmodsi4_ep>:
    18be:	66 1f       	adc	r22, r22
    18c0:	77 1f       	adc	r23, r23
    18c2:	88 1f       	adc	r24, r24
    18c4:	99 1f       	adc	r25, r25
    18c6:	1a 94       	dec	r1
    18c8:	69 f7       	brne	.-38     	; 0x18a4 <__udivmodsi4_loop>
    18ca:	60 95       	com	r22
    18cc:	70 95       	com	r23
    18ce:	80 95       	com	r24
    18d0:	90 95       	com	r25
    18d2:	9b 01       	movw	r18, r22
    18d4:	ac 01       	movw	r20, r24
    18d6:	bd 01       	movw	r22, r26
    18d8:	cf 01       	movw	r24, r30
    18da:	08 95       	ret

000018dc <malloc>:
    18dc:	cf 93       	push	r28
    18de:	df 93       	push	r29
    18e0:	82 30       	cpi	r24, 0x02	; 2
    18e2:	91 05       	cpc	r25, r1
    18e4:	10 f4       	brcc	.+4      	; 0x18ea <malloc+0xe>
    18e6:	82 e0       	ldi	r24, 0x02	; 2
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	e0 91 d2 03 	lds	r30, 0x03D2	; 0x8003d2 <__flp>
    18ee:	f0 91 d3 03 	lds	r31, 0x03D3	; 0x8003d3 <__flp+0x1>
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	c0 e0       	ldi	r28, 0x00	; 0
    18f8:	d0 e0       	ldi	r29, 0x00	; 0
    18fa:	30 97       	sbiw	r30, 0x00	; 0
    18fc:	11 f1       	breq	.+68     	; 0x1942 <malloc+0x66>
    18fe:	40 81       	ld	r20, Z
    1900:	51 81       	ldd	r21, Z+1	; 0x01
    1902:	48 17       	cp	r20, r24
    1904:	59 07       	cpc	r21, r25
    1906:	c0 f0       	brcs	.+48     	; 0x1938 <malloc+0x5c>
    1908:	48 17       	cp	r20, r24
    190a:	59 07       	cpc	r21, r25
    190c:	61 f4       	brne	.+24     	; 0x1926 <malloc+0x4a>
    190e:	82 81       	ldd	r24, Z+2	; 0x02
    1910:	93 81       	ldd	r25, Z+3	; 0x03
    1912:	20 97       	sbiw	r28, 0x00	; 0
    1914:	19 f0       	breq	.+6      	; 0x191c <malloc+0x40>
    1916:	9b 83       	std	Y+3, r25	; 0x03
    1918:	8a 83       	std	Y+2, r24	; 0x02
    191a:	2b c0       	rjmp	.+86     	; 0x1972 <malloc+0x96>
    191c:	90 93 d3 03 	sts	0x03D3, r25	; 0x8003d3 <__flp+0x1>
    1920:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <__flp>
    1924:	26 c0       	rjmp	.+76     	; 0x1972 <malloc+0x96>
    1926:	21 15       	cp	r18, r1
    1928:	31 05       	cpc	r19, r1
    192a:	19 f0       	breq	.+6      	; 0x1932 <malloc+0x56>
    192c:	42 17       	cp	r20, r18
    192e:	53 07       	cpc	r21, r19
    1930:	18 f4       	brcc	.+6      	; 0x1938 <malloc+0x5c>
    1932:	9a 01       	movw	r18, r20
    1934:	be 01       	movw	r22, r28
    1936:	df 01       	movw	r26, r30
    1938:	ef 01       	movw	r28, r30
    193a:	02 80       	ldd	r0, Z+2	; 0x02
    193c:	f3 81       	ldd	r31, Z+3	; 0x03
    193e:	e0 2d       	mov	r30, r0
    1940:	dc cf       	rjmp	.-72     	; 0x18fa <malloc+0x1e>
    1942:	21 15       	cp	r18, r1
    1944:	31 05       	cpc	r19, r1
    1946:	09 f1       	breq	.+66     	; 0x198a <malloc+0xae>
    1948:	28 1b       	sub	r18, r24
    194a:	39 0b       	sbc	r19, r25
    194c:	24 30       	cpi	r18, 0x04	; 4
    194e:	31 05       	cpc	r19, r1
    1950:	90 f4       	brcc	.+36     	; 0x1976 <malloc+0x9a>
    1952:	12 96       	adiw	r26, 0x02	; 2
    1954:	8d 91       	ld	r24, X+
    1956:	9c 91       	ld	r25, X
    1958:	13 97       	sbiw	r26, 0x03	; 3
    195a:	61 15       	cp	r22, r1
    195c:	71 05       	cpc	r23, r1
    195e:	21 f0       	breq	.+8      	; 0x1968 <malloc+0x8c>
    1960:	fb 01       	movw	r30, r22
    1962:	93 83       	std	Z+3, r25	; 0x03
    1964:	82 83       	std	Z+2, r24	; 0x02
    1966:	04 c0       	rjmp	.+8      	; 0x1970 <malloc+0x94>
    1968:	90 93 d3 03 	sts	0x03D3, r25	; 0x8003d3 <__flp+0x1>
    196c:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <__flp>
    1970:	fd 01       	movw	r30, r26
    1972:	32 96       	adiw	r30, 0x02	; 2
    1974:	44 c0       	rjmp	.+136    	; 0x19fe <malloc+0x122>
    1976:	fd 01       	movw	r30, r26
    1978:	e2 0f       	add	r30, r18
    197a:	f3 1f       	adc	r31, r19
    197c:	81 93       	st	Z+, r24
    197e:	91 93       	st	Z+, r25
    1980:	22 50       	subi	r18, 0x02	; 2
    1982:	31 09       	sbc	r19, r1
    1984:	2d 93       	st	X+, r18
    1986:	3c 93       	st	X, r19
    1988:	3a c0       	rjmp	.+116    	; 0x19fe <malloc+0x122>
    198a:	20 91 d0 03 	lds	r18, 0x03D0	; 0x8003d0 <__brkval>
    198e:	30 91 d1 03 	lds	r19, 0x03D1	; 0x8003d1 <__brkval+0x1>
    1992:	23 2b       	or	r18, r19
    1994:	41 f4       	brne	.+16     	; 0x19a6 <malloc+0xca>
    1996:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    199a:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    199e:	30 93 d1 03 	sts	0x03D1, r19	; 0x8003d1 <__brkval+0x1>
    19a2:	20 93 d0 03 	sts	0x03D0, r18	; 0x8003d0 <__brkval>
    19a6:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    19aa:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    19ae:	21 15       	cp	r18, r1
    19b0:	31 05       	cpc	r19, r1
    19b2:	41 f4       	brne	.+16     	; 0x19c4 <malloc+0xe8>
    19b4:	2d b7       	in	r18, 0x3d	; 61
    19b6:	3e b7       	in	r19, 0x3e	; 62
    19b8:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    19bc:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    19c0:	24 1b       	sub	r18, r20
    19c2:	35 0b       	sbc	r19, r21
    19c4:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <__brkval>
    19c8:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <__brkval+0x1>
    19cc:	e2 17       	cp	r30, r18
    19ce:	f3 07       	cpc	r31, r19
    19d0:	a0 f4       	brcc	.+40     	; 0x19fa <malloc+0x11e>
    19d2:	2e 1b       	sub	r18, r30
    19d4:	3f 0b       	sbc	r19, r31
    19d6:	28 17       	cp	r18, r24
    19d8:	39 07       	cpc	r19, r25
    19da:	78 f0       	brcs	.+30     	; 0x19fa <malloc+0x11e>
    19dc:	ac 01       	movw	r20, r24
    19de:	4e 5f       	subi	r20, 0xFE	; 254
    19e0:	5f 4f       	sbci	r21, 0xFF	; 255
    19e2:	24 17       	cp	r18, r20
    19e4:	35 07       	cpc	r19, r21
    19e6:	48 f0       	brcs	.+18     	; 0x19fa <malloc+0x11e>
    19e8:	4e 0f       	add	r20, r30
    19ea:	5f 1f       	adc	r21, r31
    19ec:	50 93 d1 03 	sts	0x03D1, r21	; 0x8003d1 <__brkval+0x1>
    19f0:	40 93 d0 03 	sts	0x03D0, r20	; 0x8003d0 <__brkval>
    19f4:	81 93       	st	Z+, r24
    19f6:	91 93       	st	Z+, r25
    19f8:	02 c0       	rjmp	.+4      	; 0x19fe <malloc+0x122>
    19fa:	e0 e0       	ldi	r30, 0x00	; 0
    19fc:	f0 e0       	ldi	r31, 0x00	; 0
    19fe:	cf 01       	movw	r24, r30
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	08 95       	ret

00001a06 <free>:
    1a06:	0f 93       	push	r16
    1a08:	1f 93       	push	r17
    1a0a:	cf 93       	push	r28
    1a0c:	df 93       	push	r29
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	09 f4       	brne	.+2      	; 0x1a14 <free+0xe>
    1a12:	8c c0       	rjmp	.+280    	; 0x1b2c <free+0x126>
    1a14:	fc 01       	movw	r30, r24
    1a16:	32 97       	sbiw	r30, 0x02	; 2
    1a18:	13 82       	std	Z+3, r1	; 0x03
    1a1a:	12 82       	std	Z+2, r1	; 0x02
    1a1c:	00 91 d2 03 	lds	r16, 0x03D2	; 0x8003d2 <__flp>
    1a20:	10 91 d3 03 	lds	r17, 0x03D3	; 0x8003d3 <__flp+0x1>
    1a24:	01 15       	cp	r16, r1
    1a26:	11 05       	cpc	r17, r1
    1a28:	81 f4       	brne	.+32     	; 0x1a4a <free+0x44>
    1a2a:	20 81       	ld	r18, Z
    1a2c:	31 81       	ldd	r19, Z+1	; 0x01
    1a2e:	82 0f       	add	r24, r18
    1a30:	93 1f       	adc	r25, r19
    1a32:	20 91 d0 03 	lds	r18, 0x03D0	; 0x8003d0 <__brkval>
    1a36:	30 91 d1 03 	lds	r19, 0x03D1	; 0x8003d1 <__brkval+0x1>
    1a3a:	28 17       	cp	r18, r24
    1a3c:	39 07       	cpc	r19, r25
    1a3e:	79 f5       	brne	.+94     	; 0x1a9e <free+0x98>
    1a40:	f0 93 d1 03 	sts	0x03D1, r31	; 0x8003d1 <__brkval+0x1>
    1a44:	e0 93 d0 03 	sts	0x03D0, r30	; 0x8003d0 <__brkval>
    1a48:	71 c0       	rjmp	.+226    	; 0x1b2c <free+0x126>
    1a4a:	d8 01       	movw	r26, r16
    1a4c:	40 e0       	ldi	r20, 0x00	; 0
    1a4e:	50 e0       	ldi	r21, 0x00	; 0
    1a50:	ae 17       	cp	r26, r30
    1a52:	bf 07       	cpc	r27, r31
    1a54:	50 f4       	brcc	.+20     	; 0x1a6a <free+0x64>
    1a56:	12 96       	adiw	r26, 0x02	; 2
    1a58:	2d 91       	ld	r18, X+
    1a5a:	3c 91       	ld	r19, X
    1a5c:	13 97       	sbiw	r26, 0x03	; 3
    1a5e:	ad 01       	movw	r20, r26
    1a60:	21 15       	cp	r18, r1
    1a62:	31 05       	cpc	r19, r1
    1a64:	09 f1       	breq	.+66     	; 0x1aa8 <free+0xa2>
    1a66:	d9 01       	movw	r26, r18
    1a68:	f3 cf       	rjmp	.-26     	; 0x1a50 <free+0x4a>
    1a6a:	9d 01       	movw	r18, r26
    1a6c:	da 01       	movw	r26, r20
    1a6e:	33 83       	std	Z+3, r19	; 0x03
    1a70:	22 83       	std	Z+2, r18	; 0x02
    1a72:	60 81       	ld	r22, Z
    1a74:	71 81       	ldd	r23, Z+1	; 0x01
    1a76:	86 0f       	add	r24, r22
    1a78:	97 1f       	adc	r25, r23
    1a7a:	82 17       	cp	r24, r18
    1a7c:	93 07       	cpc	r25, r19
    1a7e:	69 f4       	brne	.+26     	; 0x1a9a <free+0x94>
    1a80:	ec 01       	movw	r28, r24
    1a82:	28 81       	ld	r18, Y
    1a84:	39 81       	ldd	r19, Y+1	; 0x01
    1a86:	26 0f       	add	r18, r22
    1a88:	37 1f       	adc	r19, r23
    1a8a:	2e 5f       	subi	r18, 0xFE	; 254
    1a8c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8e:	31 83       	std	Z+1, r19	; 0x01
    1a90:	20 83       	st	Z, r18
    1a92:	8a 81       	ldd	r24, Y+2	; 0x02
    1a94:	9b 81       	ldd	r25, Y+3	; 0x03
    1a96:	93 83       	std	Z+3, r25	; 0x03
    1a98:	82 83       	std	Z+2, r24	; 0x02
    1a9a:	45 2b       	or	r20, r21
    1a9c:	29 f4       	brne	.+10     	; 0x1aa8 <free+0xa2>
    1a9e:	f0 93 d3 03 	sts	0x03D3, r31	; 0x8003d3 <__flp+0x1>
    1aa2:	e0 93 d2 03 	sts	0x03D2, r30	; 0x8003d2 <__flp>
    1aa6:	42 c0       	rjmp	.+132    	; 0x1b2c <free+0x126>
    1aa8:	13 96       	adiw	r26, 0x03	; 3
    1aaa:	fc 93       	st	X, r31
    1aac:	ee 93       	st	-X, r30
    1aae:	12 97       	sbiw	r26, 0x02	; 2
    1ab0:	ed 01       	movw	r28, r26
    1ab2:	49 91       	ld	r20, Y+
    1ab4:	59 91       	ld	r21, Y+
    1ab6:	9e 01       	movw	r18, r28
    1ab8:	24 0f       	add	r18, r20
    1aba:	35 1f       	adc	r19, r21
    1abc:	e2 17       	cp	r30, r18
    1abe:	f3 07       	cpc	r31, r19
    1ac0:	71 f4       	brne	.+28     	; 0x1ade <free+0xd8>
    1ac2:	80 81       	ld	r24, Z
    1ac4:	91 81       	ldd	r25, Z+1	; 0x01
    1ac6:	84 0f       	add	r24, r20
    1ac8:	95 1f       	adc	r25, r21
    1aca:	02 96       	adiw	r24, 0x02	; 2
    1acc:	11 96       	adiw	r26, 0x01	; 1
    1ace:	9c 93       	st	X, r25
    1ad0:	8e 93       	st	-X, r24
    1ad2:	82 81       	ldd	r24, Z+2	; 0x02
    1ad4:	93 81       	ldd	r25, Z+3	; 0x03
    1ad6:	13 96       	adiw	r26, 0x03	; 3
    1ad8:	9c 93       	st	X, r25
    1ada:	8e 93       	st	-X, r24
    1adc:	12 97       	sbiw	r26, 0x02	; 2
    1ade:	e0 e0       	ldi	r30, 0x00	; 0
    1ae0:	f0 e0       	ldi	r31, 0x00	; 0
    1ae2:	d8 01       	movw	r26, r16
    1ae4:	12 96       	adiw	r26, 0x02	; 2
    1ae6:	8d 91       	ld	r24, X+
    1ae8:	9c 91       	ld	r25, X
    1aea:	13 97       	sbiw	r26, 0x03	; 3
    1aec:	00 97       	sbiw	r24, 0x00	; 0
    1aee:	19 f0       	breq	.+6      	; 0x1af6 <free+0xf0>
    1af0:	f8 01       	movw	r30, r16
    1af2:	8c 01       	movw	r16, r24
    1af4:	f6 cf       	rjmp	.-20     	; 0x1ae2 <free+0xdc>
    1af6:	8d 91       	ld	r24, X+
    1af8:	9c 91       	ld	r25, X
    1afa:	98 01       	movw	r18, r16
    1afc:	2e 5f       	subi	r18, 0xFE	; 254
    1afe:	3f 4f       	sbci	r19, 0xFF	; 255
    1b00:	82 0f       	add	r24, r18
    1b02:	93 1f       	adc	r25, r19
    1b04:	20 91 d0 03 	lds	r18, 0x03D0	; 0x8003d0 <__brkval>
    1b08:	30 91 d1 03 	lds	r19, 0x03D1	; 0x8003d1 <__brkval+0x1>
    1b0c:	28 17       	cp	r18, r24
    1b0e:	39 07       	cpc	r19, r25
    1b10:	69 f4       	brne	.+26     	; 0x1b2c <free+0x126>
    1b12:	30 97       	sbiw	r30, 0x00	; 0
    1b14:	29 f4       	brne	.+10     	; 0x1b20 <free+0x11a>
    1b16:	10 92 d3 03 	sts	0x03D3, r1	; 0x8003d3 <__flp+0x1>
    1b1a:	10 92 d2 03 	sts	0x03D2, r1	; 0x8003d2 <__flp>
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <free+0x11e>
    1b20:	13 82       	std	Z+3, r1	; 0x03
    1b22:	12 82       	std	Z+2, r1	; 0x02
    1b24:	10 93 d1 03 	sts	0x03D1, r17	; 0x8003d1 <__brkval+0x1>
    1b28:	00 93 d0 03 	sts	0x03D0, r16	; 0x8003d0 <__brkval>
    1b2c:	df 91       	pop	r29
    1b2e:	cf 91       	pop	r28
    1b30:	1f 91       	pop	r17
    1b32:	0f 91       	pop	r16
    1b34:	08 95       	ret

00001b36 <memcpy>:
    1b36:	fb 01       	movw	r30, r22
    1b38:	dc 01       	movw	r26, r24
    1b3a:	02 c0       	rjmp	.+4      	; 0x1b40 <memcpy+0xa>
    1b3c:	01 90       	ld	r0, Z+
    1b3e:	0d 92       	st	X+, r0
    1b40:	41 50       	subi	r20, 0x01	; 1
    1b42:	50 40       	sbci	r21, 0x00	; 0
    1b44:	d8 f7       	brcc	.-10     	; 0x1b3c <memcpy+0x6>
    1b46:	08 95       	ret

00001b48 <memset>:
    1b48:	dc 01       	movw	r26, r24
    1b4a:	01 c0       	rjmp	.+2      	; 0x1b4e <memset+0x6>
    1b4c:	6d 93       	st	X+, r22
    1b4e:	41 50       	subi	r20, 0x01	; 1
    1b50:	50 40       	sbci	r21, 0x00	; 0
    1b52:	e0 f7       	brcc	.-8      	; 0x1b4c <memset+0x4>
    1b54:	08 95       	ret

00001b56 <_exit>:
    1b56:	f8 94       	cli

00001b58 <__stop_program>:
    1b58:	ff cf       	rjmp	.-2      	; 0x1b58 <__stop_program>
